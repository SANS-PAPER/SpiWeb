import { GraphQLClient } from 'graphql-request';
//import { RequestInit } from 'graphql-request/dist/types.dom';
import { useQuery, useInfiniteQuery, UseQueryOptions, UseInfiniteQueryOptions } from '@tanstack/react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };

function fetcher<TData, TVariables extends { [key: string]: any }>(client: GraphQLClient, query: string, variables?: TVariables, requestHeaders?: RequestInit['headers']) {
  return async (): Promise<TData> => client.request({
    document: query,
    variables,
    requestHeaders
  });
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Date: { input: any; output: any; }
  Datetime: { input: any; output: any; }
  InternetAddress: { input: any; output: any; }
  JSON: { input: any; output: any; }
  UUID: { input: any; output: any; }
};

/** A connection to a list of `Ability` values. */
export type AbilitiesConnection = {
  __typename?: 'AbilitiesConnection';
  /** A list of edges which contains the `Ability` and cursor to aid in pagination. */
  edges: Array<AbilitiesEdge>;
  /** A list of `Ability` objects. */
  nodes: Array<Ability>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ability` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Ability` edge in the connection. */
export type AbilitiesEdge = {
  __typename?: 'AbilitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Ability` at the end of the edge. */
  node: Ability;
};

/** Methods to use when ordering `Ability`. */
export enum AbilitiesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Ability = Node & {
  __typename?: 'Ability';
  /** Reads and enables pagination through a set of `AbilityRole`. */
  abilityRoles: AbilityRolesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  label?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Role`. */
  rolesByAbilityRoleAbilityIdAndRoleId: AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type AbilityAbilityRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AbilityRoleCondition>;
  filter?: InputMaybe<AbilityRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};


export type AbilityRolesByAbilityRoleAbilityIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** A condition to be used against `Ability` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AbilityCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Ability` object types. All fields are combined with a logical ‘and.’ */
export type AbilityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AbilityFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AbilityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AbilityFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Ability` */
export type AbilityInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Ability`. Fields that are set will be updated. */
export type AbilityPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type AbilityRole = Node & {
  __typename?: 'AbilityRole';
  /** Reads a single `Ability` that is related to this `AbilityRole`. */
  ability?: Maybe<Ability>;
  abilityId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Role` that is related to this `AbilityRole`. */
  role?: Maybe<Role>;
  roleId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `AbilityRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AbilityRoleCondition = {
  /** Checks for equality with the object’s `abilityId` field. */
  abilityId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `AbilityRole` object types. All fields are combined with a logical ‘and.’ */
export type AbilityRoleFilter = {
  /** Filter by the object’s `abilityId` field. */
  abilityId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AbilityRoleFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AbilityRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AbilityRoleFilter>>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `AbilityRole` */
export type AbilityRoleInput = {
  abilityId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  roleId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `AbilityRole`. Fields that are set will be updated. */
export type AbilityRolePatch = {
  abilityId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Role` values, with data from `AbilityRole`. */
export type AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyConnection = {
  __typename?: 'AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `AbilityRole`, and the cursor to aid in pagination. */
  edges: Array<AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `AbilityRole`. */
export type AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyEdge = {
  __typename?: 'AbilityRolesByAbilityRoleAbilityIdAndRoleIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `AbilityRole` values. */
export type AbilityRolesConnection = {
  __typename?: 'AbilityRolesConnection';
  /** A list of edges which contains the `AbilityRole` and cursor to aid in pagination. */
  edges: Array<AbilityRolesEdge>;
  /** A list of `AbilityRole` objects. */
  nodes: Array<AbilityRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AbilityRole` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AbilityRole` edge in the connection. */
export type AbilityRolesEdge = {
  __typename?: 'AbilityRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AbilityRole` at the end of the edge. */
  node: AbilityRole;
};

/** Methods to use when ordering `AbilityRole`. */
export enum AbilityRolesOrderBy {
  AbilityIdAsc = 'ABILITY_ID_ASC',
  AbilityIdDesc = 'ABILITY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Admin = Node & {
  __typename?: 'Admin';
  /** Reads and enables pagination through a set of `Company`. */
  companies: CompaniesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerAdminIdAndFillupformId: AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormAdminIdAndCreatedFromTemplateId: AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerAdminIdAndFormTemplateId: AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFillupFormAdminIdAndFormId: AdminFormsByFillupFormAdminIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerAdminIdAndFormId: AdminFormsBySchedulerAdminIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByFormAdminIdAndGroupId: AdminGroupsByFormAdminIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByGroupAdminIdAndParentId: AdminGroupsByGroupAdminIdAndParentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerAdminIdAndGroupId: AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Metric`. */
  metricsByToolAdminIdAndMetricId: AdminMetricsByToolAdminIdAndMetricIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizations: OrganizationsConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByCompanyAdminIdAndOrganizationId: AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByGroupAdminIdAndOrganizationId: AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByProjectAdminIdAndOrganizationId: AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerAdminIdAndOrgId: AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByTeamAdminIdAndOrganizationId: AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByToolAdminIdAndOrganizationId: AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Project`. */
  projects: ProjectsConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerAdminIdAndSchedulerFieldsId: AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teams: TeamsConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByFormAdminIdAndTeamId: AdminTeamsByFormAdminIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerAdminIdAndTeamId: AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
  /** Reads and enables pagination through a set of `Tooltype`. */
  tooltypesByToolAdminIdAndTooltypeId: AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Admin`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormAdminIdAndApprovedBy: AdminUsersByFillupFormAdminIdAndApprovedByManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormAdminIdAndUserId: AdminUsersByFillupFormAdminIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerAdminIdAndUserId: AdminUsersBySchedulerAdminIdAndUserIdManyToManyConnection;
};


export type AdminCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type AdminFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type AdminFillupFormsBySchedulerAdminIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type AdminFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type AdminFormsByFillupFormAdminIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type AdminFormsBySchedulerAdminIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type AdminGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type AdminGroupsByFormAdminIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type AdminGroupsByGroupAdminIdAndParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type AdminGroupsBySchedulerAdminIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type AdminMetricsByToolAdminIdAndMetricIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MetricCondition>;
  filter?: InputMaybe<MetricFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};


export type AdminOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsByCompanyAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsByGroupAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsByProjectAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsBySchedulerAdminIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsByTeamAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminOrganizationsByToolAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type AdminProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};


export type AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type AdminSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type AdminTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type AdminTeamsByFormAdminIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type AdminTeamsBySchedulerAdminIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type AdminToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};


export type AdminTooltypesByToolAdminIdAndTooltypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TooltypeCondition>;
  filter?: InputMaybe<TooltypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};


export type AdminUsersByFillupFormAdminIdAndApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type AdminUsersByFillupFormAdminIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type AdminUsersBySchedulerAdminIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Admin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AdminCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyConnection = {
  __typename?: 'AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyEdge = {
  __typename?: 'AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type AdminFillupFormsBySchedulerAdminIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `Admin` object types. All fields are combined with a logical ‘and.’ */
export type AdminFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AdminFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AdminFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AdminFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `Form`. */
export type AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyConnection = {
  __typename?: 'AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyEdge = {
  __typename?: 'AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  formsByCreatedFromTemplateId: FormsConnection;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
};


/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type AdminFormTemplatesByFormAdminIdAndCreatedFromTemplateIdManyToManyEdgeFormsByCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type AdminFormTemplatesBySchedulerAdminIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `FillupForm`. */
export type AdminFormsByFillupFormAdminIdAndFormIdManyToManyConnection = {
  __typename?: 'AdminFormsByFillupFormAdminIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<AdminFormsByFillupFormAdminIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `FillupForm`. */
export type AdminFormsByFillupFormAdminIdAndFormIdManyToManyEdge = {
  __typename?: 'AdminFormsByFillupFormAdminIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Form` at the end of the edge. */
  node: Form;
};


/** A `Form` edge in the connection, with data from `FillupForm`. */
export type AdminFormsByFillupFormAdminIdAndFormIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type AdminFormsBySchedulerAdminIdAndFormIdManyToManyConnection = {
  __typename?: 'AdminFormsBySchedulerAdminIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminFormsBySchedulerAdminIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type AdminFormsBySchedulerAdminIdAndFormIdManyToManyEdge = {
  __typename?: 'AdminFormsBySchedulerAdminIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type AdminFormsBySchedulerAdminIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Form`. */
export type AdminGroupsByFormAdminIdAndGroupIdManyToManyConnection = {
  __typename?: 'AdminGroupsByFormAdminIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<AdminGroupsByFormAdminIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Form`. */
export type AdminGroupsByFormAdminIdAndGroupIdManyToManyEdge = {
  __typename?: 'AdminGroupsByFormAdminIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `Form`. */
export type AdminGroupsByFormAdminIdAndGroupIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Group`. */
export type AdminGroupsByGroupAdminIdAndParentIdManyToManyConnection = {
  __typename?: 'AdminGroupsByGroupAdminIdAndParentIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<AdminGroupsByGroupAdminIdAndParentIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Group`. */
export type AdminGroupsByGroupAdminIdAndParentIdManyToManyEdge = {
  __typename?: 'AdminGroupsByGroupAdminIdAndParentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Group`. */
  childGroups: GroupsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `Group`. */
export type AdminGroupsByGroupAdminIdAndParentIdManyToManyEdgeChildGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyConnection = {
  __typename?: 'AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyEdge = {
  __typename?: 'AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type AdminGroupsBySchedulerAdminIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `Admin` */
export type AdminInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Metric` values, with data from `Tool`. */
export type AdminMetricsByToolAdminIdAndMetricIdManyToManyConnection = {
  __typename?: 'AdminMetricsByToolAdminIdAndMetricIdManyToManyConnection';
  /** A list of edges which contains the `Metric`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<AdminMetricsByToolAdminIdAndMetricIdManyToManyEdge>;
  /** A list of `Metric` objects. */
  nodes: Array<Metric>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Metric` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Metric` edge in the connection, with data from `Tool`. */
export type AdminMetricsByToolAdminIdAndMetricIdManyToManyEdge = {
  __typename?: 'AdminMetricsByToolAdminIdAndMetricIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Metric` at the end of the edge. */
  node: Metric;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Metric` edge in the connection, with data from `Tool`. */
export type AdminMetricsByToolAdminIdAndMetricIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Company`. */
export type AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Company`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Company`. */
export type AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Company`. */
  companies: CompaniesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Company`. */
export type AdminOrganizationsByCompanyAdminIdAndOrganizationIdManyToManyEdgeCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Group`. */
export type AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Group`. */
export type AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Group`. */
export type AdminOrganizationsByGroupAdminIdAndOrganizationIdManyToManyEdgeGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Project`. */
export type AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Project`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Project`. */
export type AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Project`. */
  projects: ProjectsConnection;
};


/** A `Organization` edge in the connection, with data from `Project`. */
export type AdminOrganizationsByProjectAdminIdAndOrganizationIdManyToManyEdgeProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type AdminOrganizationsBySchedulerAdminIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Team`. */
export type AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Team`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Team`. */
export type AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Team`. */
  teams: TeamsConnection;
};


/** A `Organization` edge in the connection, with data from `Team`. */
export type AdminOrganizationsByTeamAdminIdAndOrganizationIdManyToManyEdgeTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Tool`. */
export type AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Tool`. */
export type AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Organization` edge in the connection, with data from `Tool`. */
export type AdminOrganizationsByToolAdminIdAndOrganizationIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** Represents an update to a `Admin`. Fields that are set will be updated. */
export type AdminPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type AdminSchedulerFieldsBySchedulerAdminIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Form`. */
export type AdminTeamsByFormAdminIdAndTeamIdManyToManyConnection = {
  __typename?: 'AdminTeamsByFormAdminIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<AdminTeamsByFormAdminIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Form`. */
export type AdminTeamsByFormAdminIdAndTeamIdManyToManyEdge = {
  __typename?: 'AdminTeamsByFormAdminIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Team` at the end of the edge. */
  node: Team;
};


/** A `Team` edge in the connection, with data from `Form`. */
export type AdminTeamsByFormAdminIdAndTeamIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyConnection = {
  __typename?: 'AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyEdge = {
  __typename?: 'AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type AdminTeamsBySchedulerAdminIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Tooltype` values, with data from `Tool`. */
export type AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyConnection = {
  __typename?: 'AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyConnection';
  /** A list of edges which contains the `Tooltype`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyEdge>;
  /** A list of `Tooltype` objects. */
  nodes: Array<Tooltype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tooltype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyEdge = {
  __typename?: 'AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tooltype` at the end of the edge. */
  node: Tooltype;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type AdminTooltypesByToolAdminIdAndTooltypeIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndApprovedByManyToManyConnection = {
  __typename?: 'AdminUsersByFillupFormAdminIdAndApprovedByManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<AdminUsersByFillupFormAdminIdAndApprovedByManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndApprovedByManyToManyEdge = {
  __typename?: 'AdminUsersByFillupFormAdminIdAndApprovedByManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsByApprovedBy: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndApprovedByManyToManyEdgeFillupFormsByApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndUserIdManyToManyConnection = {
  __typename?: 'AdminUsersByFillupFormAdminIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<AdminUsersByFillupFormAdminIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndUserIdManyToManyEdge = {
  __typename?: 'AdminUsersByFillupFormAdminIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type AdminUsersByFillupFormAdminIdAndUserIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type AdminUsersBySchedulerAdminIdAndUserIdManyToManyConnection = {
  __typename?: 'AdminUsersBySchedulerAdminIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<AdminUsersBySchedulerAdminIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type AdminUsersBySchedulerAdminIdAndUserIdManyToManyEdge = {
  __typename?: 'AdminUsersBySchedulerAdminIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type AdminUsersBySchedulerAdminIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Admin` values. */
export type AdminsConnection = {
  __typename?: 'AdminsConnection';
  /** A list of edges which contains the `Admin` and cursor to aid in pagination. */
  edges: Array<AdminsEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection. */
export type AdminsEdge = {
  __typename?: 'AdminsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};

/** Methods to use when ordering `Admin`. */
export enum AdminsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type AllowedSettingValue = Node & {
  __typename?: 'AllowedSettingValue';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Setting` that is related to this `AllowedSettingValue`. */
  setting?: Maybe<Setting>;
  settingId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
  value: Scalars['JSON']['output'];
};

/**
 * A condition to be used against `AllowedSettingValue` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type AllowedSettingValueCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `settingId` field. */
  settingId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `AllowedSettingValue` object types. All fields are combined with a logical ‘and.’ */
export type AllowedSettingValueFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AllowedSettingValueFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AllowedSettingValueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AllowedSettingValueFilter>>;
  /** Filter by the object’s `settingId` field. */
  settingId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `AllowedSettingValue` */
export type AllowedSettingValueInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  settingId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
  value: Scalars['JSON']['input'];
};

/** Represents an update to a `AllowedSettingValue`. Fields that are set will be updated. */
export type AllowedSettingValuePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  settingId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `AllowedSettingValue` values. */
export type AllowedSettingValuesConnection = {
  __typename?: 'AllowedSettingValuesConnection';
  /** A list of edges which contains the `AllowedSettingValue` and cursor to aid in pagination. */
  edges: Array<AllowedSettingValuesEdge>;
  /** A list of `AllowedSettingValue` objects. */
  nodes: Array<AllowedSettingValue>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AllowedSettingValue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AllowedSettingValue` edge in the connection. */
export type AllowedSettingValuesEdge = {
  __typename?: 'AllowedSettingValuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AllowedSettingValue` at the end of the edge. */
  node: AllowedSettingValue;
};

/** Methods to use when ordering `AllowedSettingValue`. */
export enum AllowedSettingValuesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SettingIdAsc = 'SETTING_ID_ASC',
  SettingIdDesc = 'SETTING_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type Attachment = Node & {
  __typename?: 'Attachment';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['BigInt']['output'];
  mimetype: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Tool` that is related to this `Attachment`. */
  tool?: Maybe<Tool>;
  toolId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `Attachment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AttachmentCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `mimetype` field. */
  mimetype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `toolId` field. */
  toolId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Attachment` object types. All fields are combined with a logical ‘and.’ */
export type AttachmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AttachmentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `mimetype` field. */
  mimetype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AttachmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AttachmentFilter>>;
  /** Filter by the object’s `toolId` field. */
  toolId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Attachment` */
export type AttachmentInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  mimetype: Scalars['String']['input'];
  name: Scalars['String']['input'];
  toolId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Attachment`. Fields that are set will be updated. */
export type AttachmentPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  toolId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Attachment` values. */
export type AttachmentsConnection = {
  __typename?: 'AttachmentsConnection';
  /** A list of edges which contains the `Attachment` and cursor to aid in pagination. */
  edges: Array<AttachmentsEdge>;
  /** A list of `Attachment` objects. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attachment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Attachment` edge in the connection. */
export type AttachmentsEdge = {
  __typename?: 'AttachmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Attachment` at the end of the edge. */
  node: Attachment;
};

/** Methods to use when ordering `Attachment`. */
export enum AttachmentsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MimetypeAsc = 'MIMETYPE_ASC',
  MimetypeDesc = 'MIMETYPE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ToolIdAsc = 'TOOL_ID_ASC',
  ToolIdDesc = 'TOOL_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type Certification = Node & {
  __typename?: 'Certification';
  /** Reads a single `User` that is related to this `Certification`. */
  admin?: Maybe<User>;
  adminId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Certification`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `Certification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CertificationCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Certification` object types. All fields are combined with a logical ‘and.’ */
export type CertificationFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CertificationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CertificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CertificationFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Certification` */
export type CertificationInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Certification`. Fields that are set will be updated. */
export type CertificationPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Certification` values. */
export type CertificationsConnection = {
  __typename?: 'CertificationsConnection';
  /** A list of edges which contains the `Certification` and cursor to aid in pagination. */
  edges: Array<CertificationsEdge>;
  /** A list of `Certification` objects. */
  nodes: Array<Certification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Certification` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Certification` edge in the connection. */
export type CertificationsEdge = {
  __typename?: 'CertificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Certification` at the end of the edge. */
  node: Certification;
};

/** Methods to use when ordering `Certification`. */
export enum CertificationsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `Company` values. */
export type CompaniesConnection = {
  __typename?: 'CompaniesConnection';
  /** A list of edges which contains the `Company` and cursor to aid in pagination. */
  edges: Array<CompaniesEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection. */
export type CompaniesEdge = {
  __typename?: 'CompaniesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Company` at the end of the edge. */
  node: Company;
};

/** Methods to use when ordering `Company`. */
export enum CompaniesOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Company = Node & {
  __typename?: 'Company';
  /** Reads a single `Admin` that is related to this `Company`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  email: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Company`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByCompanyUserCompanyIdAndUserId: CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
};


export type CompanyCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


export type CompanyUsersByCompanyUserCompanyIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Company` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CompanyCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Company` object types. All fields are combined with a logical ‘and.’ */
export type CompanyFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompanyFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CompanyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompanyFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Company` */
export type CompanyInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  email: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `Company`. Fields that are set will be updated. */
export type CompanyPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

export type CompanyUser = {
  __typename?: 'CompanyUser';
  /** Reads a single `Company` that is related to this `CompanyUser`. */
  company?: Maybe<Company>;
  companyId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `CompanyUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CompanyUserCondition = {
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `CompanyUser` object types. All fields are combined with a logical ‘and.’ */
export type CompanyUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CompanyUserFilter>>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CompanyUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CompanyUserFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `CompanyUser` */
export type CompanyUserInput = {
  companyId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** A connection to a list of `User` values, with data from `CompanyUser`. */
export type CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyConnection = {
  __typename?: 'CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `CompanyUser`, and the cursor to aid in pagination. */
  edges: Array<CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `CompanyUser`. */
export type CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyEdge = {
  __typename?: 'CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `CompanyUser`. */
export type CompanyUsersByCompanyUserCompanyIdAndUserIdManyToManyEdgeCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

/** A connection to a list of `CompanyUser` values. */
export type CompanyUsersConnection = {
  __typename?: 'CompanyUsersConnection';
  /** A list of edges which contains the `CompanyUser` and cursor to aid in pagination. */
  edges: Array<CompanyUsersEdge>;
  /** A list of `CompanyUser` objects. */
  nodes: Array<CompanyUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CompanyUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CompanyUser` edge in the connection. */
export type CompanyUsersEdge = {
  __typename?: 'CompanyUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CompanyUser` at the end of the edge. */
  node: CompanyUser;
};

/** Methods to use when ordering `CompanyUser`. */
export enum CompanyUsersOrderBy {
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  Natural = 'NATURAL',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Component = Node & {
  __typename?: 'Component';
  /** Reads and enables pagination through a set of `Component`. */
  childComponents: ComponentsConnection;
  /** Reads and enables pagination through a set of `ComponentEvent`. */
  componentEvents: ComponentEventsConnection;
  /** Reads and enables pagination through a set of `ComponentProperty`. */
  componentProperties: ComponentPropertiesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Event`. */
  eventsByComponentEventComponentIdAndEventId: ComponentEventsByComponentEventComponentIdAndEventIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fields: FieldsConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFieldComponentIdAndFormId: ComponentFormsByFieldComponentIdAndFormIdManyToManyConnection;
  hint: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Component` that is related to this `Component`. */
  parent?: Maybe<Component>;
  parentId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByComponentPropertyComponentIdAndPropertyId: ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyConnection;
  slug: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type ComponentChildComponentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentCondition>;
  filter?: InputMaybe<ComponentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};


export type ComponentComponentEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentEventCondition>;
  filter?: InputMaybe<ComponentEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};


export type ComponentComponentPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentPropertyCondition>;
  filter?: InputMaybe<ComponentPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};


export type ComponentEventsByComponentEventComponentIdAndEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type ComponentFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type ComponentFormsByFieldComponentIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/**
 * A condition to be used against `Component` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ComponentCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hint` field. */
  hint?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type ComponentEvent = Node & {
  __typename?: 'ComponentEvent';
  /** Reads a single `Component` that is related to this `ComponentEvent`. */
  component?: Maybe<Component>;
  componentId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Event` that is related to this `ComponentEvent`. */
  event?: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `ComponentEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ComponentEventCondition = {
  /** Checks for equality with the object’s `componentId` field. */
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ComponentEvent` object types. All fields are combined with a logical ‘and.’ */
export type ComponentEventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ComponentEventFilter>>;
  /** Filter by the object’s `componentId` field. */
  componentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ComponentEventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ComponentEventFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ComponentEvent` */
export type ComponentEventInput = {
  componentId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  eventId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `ComponentEvent`. Fields that are set will be updated. */
export type ComponentEventPatch = {
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Event` values, with data from `ComponentEvent`. */
export type ComponentEventsByComponentEventComponentIdAndEventIdManyToManyConnection = {
  __typename?: 'ComponentEventsByComponentEventComponentIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `ComponentEvent`, and the cursor to aid in pagination. */
  edges: Array<ComponentEventsByComponentEventComponentIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `ComponentEvent`. */
export type ComponentEventsByComponentEventComponentIdAndEventIdManyToManyEdge = {
  __typename?: 'ComponentEventsByComponentEventComponentIdAndEventIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ComponentEvent`. */
  componentEvents: ComponentEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `ComponentEvent`. */
export type ComponentEventsByComponentEventComponentIdAndEventIdManyToManyEdgeComponentEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentEventCondition>;
  filter?: InputMaybe<ComponentEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};

/** A connection to a list of `ComponentEvent` values. */
export type ComponentEventsConnection = {
  __typename?: 'ComponentEventsConnection';
  /** A list of edges which contains the `ComponentEvent` and cursor to aid in pagination. */
  edges: Array<ComponentEventsEdge>;
  /** A list of `ComponentEvent` objects. */
  nodes: Array<ComponentEvent>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ComponentEvent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ComponentEvent` edge in the connection. */
export type ComponentEventsEdge = {
  __typename?: 'ComponentEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ComponentEvent` at the end of the edge. */
  node: ComponentEvent;
};

/** Methods to use when ordering `ComponentEvent`. */
export enum ComponentEventsOrderBy {
  ComponentIdAsc = 'COMPONENT_ID_ASC',
  ComponentIdDesc = 'COMPONENT_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A filter to be used against `Component` object types. All fields are combined with a logical ‘and.’ */
export type ComponentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ComponentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hint` field. */
  hint?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ComponentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ComponentFilter>>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `Form` values, with data from `Field`. */
export type ComponentFormsByFieldComponentIdAndFormIdManyToManyConnection = {
  __typename?: 'ComponentFormsByFieldComponentIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Field`, and the cursor to aid in pagination. */
  edges: Array<ComponentFormsByFieldComponentIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Field`. */
export type ComponentFormsByFieldComponentIdAndFormIdManyToManyEdge = {
  __typename?: 'ComponentFormsByFieldComponentIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Field`. */
  fields: FieldsConnection;
  /** The `Form` at the end of the edge. */
  node: Form;
};


/** A `Form` edge in the connection, with data from `Field`. */
export type ComponentFormsByFieldComponentIdAndFormIdManyToManyEdgeFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** An input for mutations affecting `Component` */
export type ComponentInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  hint: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  slug: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Component`. Fields that are set will be updated. */
export type ComponentPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Property` values, with data from `ComponentProperty`. */
export type ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyConnection = {
  __typename?: 'ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyConnection';
  /** A list of edges which contains the `Property`, info from the `ComponentProperty`, and the cursor to aid in pagination. */
  edges: Array<ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Property>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection, with data from `ComponentProperty`. */
export type ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyEdge = {
  __typename?: 'ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ComponentProperty`. */
  componentProperties: ComponentPropertiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Property` at the end of the edge. */
  node: Property;
};


/** A `Property` edge in the connection, with data from `ComponentProperty`. */
export type ComponentPropertiesByComponentPropertyComponentIdAndPropertyIdManyToManyEdgeComponentPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentPropertyCondition>;
  filter?: InputMaybe<ComponentPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};

/** A connection to a list of `ComponentProperty` values. */
export type ComponentPropertiesConnection = {
  __typename?: 'ComponentPropertiesConnection';
  /** A list of edges which contains the `ComponentProperty` and cursor to aid in pagination. */
  edges: Array<ComponentPropertiesEdge>;
  /** A list of `ComponentProperty` objects. */
  nodes: Array<ComponentProperty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ComponentProperty` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ComponentProperty` edge in the connection. */
export type ComponentPropertiesEdge = {
  __typename?: 'ComponentPropertiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ComponentProperty` at the end of the edge. */
  node: ComponentProperty;
};

/** Methods to use when ordering `ComponentProperty`. */
export enum ComponentPropertiesOrderBy {
  ComponentIdAsc = 'COMPONENT_ID_ASC',
  ComponentIdDesc = 'COMPONENT_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DefaultValueAsc = 'DEFAULT_VALUE_ASC',
  DefaultValueDesc = 'DEFAULT_VALUE_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type ComponentProperty = Node & {
  __typename?: 'ComponentProperty';
  /** Reads a single `Component` that is related to this `ComponentProperty`. */
  component?: Maybe<Component>;
  componentId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  defaultValue: Scalars['String']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Property` that is related to this `ComponentProperty`. */
  property?: Maybe<Property>;
  propertyId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `ComponentProperty` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ComponentPropertyCondition = {
  /** Checks for equality with the object’s `componentId` field. */
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `defaultValue` field. */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ComponentProperty` object types. All fields are combined with a logical ‘and.’ */
export type ComponentPropertyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ComponentPropertyFilter>>;
  /** Filter by the object’s `componentId` field. */
  componentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `defaultValue` field. */
  defaultValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ComponentPropertyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ComponentPropertyFilter>>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ComponentProperty` */
export type ComponentPropertyInput = {
  componentId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  defaultValue: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `ComponentProperty`. Fields that are set will be updated. */
export type ComponentPropertyPatch = {
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Component` values. */
export type ComponentsConnection = {
  __typename?: 'ComponentsConnection';
  /** A list of edges which contains the `Component` and cursor to aid in pagination. */
  edges: Array<ComponentsEdge>;
  /** A list of `Component` objects. */
  nodes: Array<Component>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Component` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Component` edge in the connection. */
export type ComponentsEdge = {
  __typename?: 'ComponentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Component` at the end of the edge. */
  node: Component;
};

/** Methods to use when ordering `Component`. */
export enum ComponentsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  HintAsc = 'HINT_ASC',
  HintDesc = 'HINT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Course = Node & {
  __typename?: 'Course';
  /** Reads a single `User` that is related to this `Course`. */
  admin?: Maybe<User>;
  adminId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Course`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `Course` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CourseCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Course` object types. All fields are combined with a logical ‘and.’ */
export type CourseFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CourseFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CourseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CourseFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Course` */
export type CourseInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Course`. Fields that are set will be updated. */
export type CoursePatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Course` values. */
export type CoursesConnection = {
  __typename?: 'CoursesConnection';
  /** A list of edges which contains the `Course` and cursor to aid in pagination. */
  edges: Array<CoursesEdge>;
  /** A list of `Course` objects. */
  nodes: Array<Course>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Course` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Course` edge in the connection. */
export type CoursesEdge = {
  __typename?: 'CoursesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Course` at the end of the edge. */
  node: Course;
};

/** Methods to use when ordering `Course`. */
export enum CoursesOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** All input for the create `Ability` mutation. */
export type CreateAbilityInput = {
  /** The `Ability` to be created by this mutation. */
  ability: AbilityInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Ability` mutation. */
export type CreateAbilityPayload = {
  __typename?: 'CreateAbilityPayload';
  /** The `Ability` that was created by this mutation. */
  ability?: Maybe<Ability>;
  /** An edge for our `Ability`. May be used by Relay 1. */
  abilityEdge?: Maybe<AbilitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Ability` mutation. */
export type CreateAbilityPayloadAbilityEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilitiesOrderBy>>;
};

/** All input for the create `AbilityRole` mutation. */
export type CreateAbilityRoleInput = {
  /** The `AbilityRole` to be created by this mutation. */
  abilityRole: AbilityRoleInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AbilityRole` mutation. */
export type CreateAbilityRolePayload = {
  __typename?: 'CreateAbilityRolePayload';
  /** Reads a single `Ability` that is related to this `AbilityRole`. */
  ability?: Maybe<Ability>;
  /** The `AbilityRole` that was created by this mutation. */
  abilityRole?: Maybe<AbilityRole>;
  /** An edge for our `AbilityRole`. May be used by Relay 1. */
  abilityRoleEdge?: Maybe<AbilityRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `AbilityRole`. */
  role?: Maybe<Role>;
};


/** The output of our create `AbilityRole` mutation. */
export type CreateAbilityRolePayloadAbilityRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};

/** All input for the create `Admin` mutation. */
export type CreateAdminInput = {
  /** The `Admin` to be created by this mutation. */
  admin: AdminInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Admin` mutation. */
export type CreateAdminPayload = {
  __typename?: 'CreateAdminPayload';
  /** The `Admin` that was created by this mutation. */
  admin?: Maybe<Admin>;
  /** An edge for our `Admin`. May be used by Relay 1. */
  adminEdge?: Maybe<AdminsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Admin`. */
  user?: Maybe<User>;
};


/** The output of our create `Admin` mutation. */
export type CreateAdminPayloadAdminEdgeArgs = {
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};

/** All input for the create `AllowedSettingValue` mutation. */
export type CreateAllowedSettingValueInput = {
  /** The `AllowedSettingValue` to be created by this mutation. */
  allowedSettingValue: AllowedSettingValueInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AllowedSettingValue` mutation. */
export type CreateAllowedSettingValuePayload = {
  __typename?: 'CreateAllowedSettingValuePayload';
  /** The `AllowedSettingValue` that was created by this mutation. */
  allowedSettingValue?: Maybe<AllowedSettingValue>;
  /** An edge for our `AllowedSettingValue`. May be used by Relay 1. */
  allowedSettingValueEdge?: Maybe<AllowedSettingValuesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `AllowedSettingValue`. */
  setting?: Maybe<Setting>;
};


/** The output of our create `AllowedSettingValue` mutation. */
export type CreateAllowedSettingValuePayloadAllowedSettingValueEdgeArgs = {
  orderBy?: InputMaybe<Array<AllowedSettingValuesOrderBy>>;
};

/** All input for the create `Attachment` mutation. */
export type CreateAttachmentInput = {
  /** The `Attachment` to be created by this mutation. */
  attachment: AttachmentInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayload = {
  __typename?: 'CreateAttachmentPayload';
  /** The `Attachment` that was created by this mutation. */
  attachment?: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge?: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tool` that is related to this `Attachment`. */
  tool?: Maybe<Tool>;
};


/** The output of our create `Attachment` mutation. */
export type CreateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the create `Certification` mutation. */
export type CreateCertificationInput = {
  /** The `Certification` to be created by this mutation. */
  certification: CertificationInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Certification` mutation. */
export type CreateCertificationPayload = {
  __typename?: 'CreateCertificationPayload';
  /** Reads a single `User` that is related to this `Certification`. */
  admin?: Maybe<User>;
  /** The `Certification` that was created by this mutation. */
  certification?: Maybe<Certification>;
  /** An edge for our `Certification`. May be used by Relay 1. */
  certificationEdge?: Maybe<CertificationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Certification`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Certification` mutation. */
export type CreateCertificationPayloadCertificationEdgeArgs = {
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};

/** All input for the create `Company` mutation. */
export type CreateCompanyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Company` to be created by this mutation. */
  company: CompanyInput;
};

/** The output of our create `Company` mutation. */
export type CreateCompanyPayload = {
  __typename?: 'CreateCompanyPayload';
  /** Reads a single `Admin` that is related to this `Company`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Company` that was created by this mutation. */
  company?: Maybe<Company>;
  /** An edge for our `Company`. May be used by Relay 1. */
  companyEdge?: Maybe<CompaniesEdge>;
  /** Reads a single `Organization` that is related to this `Company`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Company` mutation. */
export type CreateCompanyPayloadCompanyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** All input for the create `CompanyUser` mutation. */
export type CreateCompanyUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CompanyUser` to be created by this mutation. */
  companyUser: CompanyUserInput;
};

/** The output of our create `CompanyUser` mutation. */
export type CreateCompanyUserPayload = {
  __typename?: 'CreateCompanyUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Company` that is related to this `CompanyUser`. */
  company?: Maybe<Company>;
  /** The `CompanyUser` that was created by this mutation. */
  companyUser?: Maybe<CompanyUser>;
  /** An edge for our `CompanyUser`. May be used by Relay 1. */
  companyUserEdge?: Maybe<CompanyUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CompanyUser`. */
  user?: Maybe<User>;
};


/** The output of our create `CompanyUser` mutation. */
export type CreateCompanyUserPayloadCompanyUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

/** All input for the create `ComponentEvent` mutation. */
export type CreateComponentEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ComponentEvent` to be created by this mutation. */
  componentEvent: ComponentEventInput;
};

/** The output of our create `ComponentEvent` mutation. */
export type CreateComponentEventPayload = {
  __typename?: 'CreateComponentEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentEvent`. */
  component?: Maybe<Component>;
  /** The `ComponentEvent` that was created by this mutation. */
  componentEvent?: Maybe<ComponentEvent>;
  /** An edge for our `ComponentEvent`. May be used by Relay 1. */
  componentEventEdge?: Maybe<ComponentEventsEdge>;
  /** Reads a single `Event` that is related to this `ComponentEvent`. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ComponentEvent` mutation. */
export type CreateComponentEventPayloadComponentEventEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};

/** All input for the create `Component` mutation. */
export type CreateComponentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Component` to be created by this mutation. */
  component: ComponentInput;
};

/** The output of our create `Component` mutation. */
export type CreateComponentPayload = {
  __typename?: 'CreateComponentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Component` that was created by this mutation. */
  component?: Maybe<Component>;
  /** An edge for our `Component`. May be used by Relay 1. */
  componentEdge?: Maybe<ComponentsEdge>;
  /** Reads a single `Component` that is related to this `Component`. */
  parent?: Maybe<Component>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Component` mutation. */
export type CreateComponentPayloadComponentEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};

/** All input for the create `ComponentProperty` mutation. */
export type CreateComponentPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ComponentProperty` to be created by this mutation. */
  componentProperty: ComponentPropertyInput;
};

/** The output of our create `ComponentProperty` mutation. */
export type CreateComponentPropertyPayload = {
  __typename?: 'CreateComponentPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentProperty`. */
  component?: Maybe<Component>;
  /** The `ComponentProperty` that was created by this mutation. */
  componentProperty?: Maybe<ComponentProperty>;
  /** An edge for our `ComponentProperty`. May be used by Relay 1. */
  componentPropertyEdge?: Maybe<ComponentPropertiesEdge>;
  /** Reads a single `Property` that is related to this `ComponentProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ComponentProperty` mutation. */
export type CreateComponentPropertyPayloadComponentPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};

/** All input for the create `Course` mutation. */
export type CreateCourseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Course` to be created by this mutation. */
  course: CourseInput;
};

/** The output of our create `Course` mutation. */
export type CreateCoursePayload = {
  __typename?: 'CreateCoursePayload';
  /** Reads a single `User` that is related to this `Course`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Course` that was created by this mutation. */
  course?: Maybe<Course>;
  /** An edge for our `Course`. May be used by Relay 1. */
  courseEdge?: Maybe<CoursesEdge>;
  /** Reads a single `Organization` that is related to this `Course`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Course` mutation. */
export type CreateCoursePayloadCourseEdgeArgs = {
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};

/** All input for the create `Datatype` mutation. */
export type CreateDatatypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Datatype` to be created by this mutation. */
  datatype: DatatypeInput;
};

/** The output of our create `Datatype` mutation. */
export type CreateDatatypePayload = {
  __typename?: 'CreateDatatypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Datatype` that was created by this mutation. */
  datatype?: Maybe<Datatype>;
  /** An edge for our `Datatype`. May be used by Relay 1. */
  datatypeEdge?: Maybe<DatatypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Datatype` mutation. */
export type CreateDatatypePayloadDatatypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DatatypesOrderBy>>;
};

/** All input for the create `Equipment` mutation. */
export type CreateEquipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Equipment` to be created by this mutation. */
  equipment: EquipmentInput;
};

/** The output of our create `Equipment` mutation. */
export type CreateEquipmentPayload = {
  __typename?: 'CreateEquipmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Equipment` that was created by this mutation. */
  equipment?: Maybe<Equipment>;
  /** An edge for our `Equipment`. May be used by Relay 1. */
  equipmentEdge?: Maybe<EquipmentEdge>;
  /** Reads a single `EquipmentType` that is related to this `Equipment`. */
  equipmentType?: Maybe<EquipmentType>;
  /** Reads a single `Organization` that is related to this `Equipment`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Equipment`. */
  userByPreparedBy?: Maybe<User>;
};


/** The output of our create `Equipment` mutation. */
export type CreateEquipmentPayloadEquipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** All input for the create `EquipmentType` mutation. */
export type CreateEquipmentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EquipmentType` to be created by this mutation. */
  equipmentType: EquipmentTypeInput;
};

/** The output of our create `EquipmentType` mutation. */
export type CreateEquipmentTypePayload = {
  __typename?: 'CreateEquipmentTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `EquipmentType` that was created by this mutation. */
  equipmentType?: Maybe<EquipmentType>;
  /** An edge for our `EquipmentType`. May be used by Relay 1. */
  equipmentTypeEdge?: Maybe<EquipmentTypesEdge>;
  /** Reads a single `Organization` that is related to this `EquipmentType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `EquipmentType` mutation. */
export type CreateEquipmentTypePayloadEquipmentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};

/** All input for the create `ErrorReport` mutation. */
export type CreateErrorReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ErrorReport` to be created by this mutation. */
  errorReport: ErrorReportInput;
};

/** The output of our create `ErrorReport` mutation. */
export type CreateErrorReportPayload = {
  __typename?: 'CreateErrorReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ErrorReport` that was created by this mutation. */
  errorReport?: Maybe<ErrorReport>;
  /** An edge for our `ErrorReport`. May be used by Relay 1. */
  errorReportEdge?: Maybe<ErrorReportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ErrorReport` mutation. */
export type CreateErrorReportPayloadErrorReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ErrorReportsOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Event` that was created by this mutation. */
  event?: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `FailedJob` mutation. */
export type CreateFailedJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FailedJob` to be created by this mutation. */
  failedJob: FailedJobInput;
};

/** The output of our create `FailedJob` mutation. */
export type CreateFailedJobPayload = {
  __typename?: 'CreateFailedJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FailedJob` that was created by this mutation. */
  failedJob?: Maybe<FailedJob>;
  /** An edge for our `FailedJob`. May be used by Relay 1. */
  failedJobEdge?: Maybe<FailedJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FailedJob` mutation. */
export type CreateFailedJobPayloadFailedJobEdgeArgs = {
  orderBy?: InputMaybe<Array<FailedJobsOrderBy>>;
};

/** All input for the create `FieldAction` mutation. */
export type CreateFieldActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FieldAction` to be created by this mutation. */
  fieldAction: FieldActionInput;
};

/** The output of our create `FieldAction` mutation. */
export type CreateFieldActionPayload = {
  __typename?: 'CreateFieldActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `FieldAction`. */
  event?: Maybe<Event>;
  /** Reads a single `Field` that is related to this `FieldAction`. */
  field?: Maybe<Field>;
  /** The `FieldAction` that was created by this mutation. */
  fieldAction?: Maybe<FieldAction>;
  /** An edge for our `FieldAction`. May be used by Relay 1. */
  fieldActionEdge?: Maybe<FieldActionsEdge>;
  /** Reads a single `Property` that is related to this `FieldAction`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FieldAction` mutation. */
export type CreateFieldActionPayloadFieldActionEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** All input for the create `Field` mutation. */
export type CreateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Field` to be created by this mutation. */
  field: FieldInput;
};

/** The output of our create `Field` mutation. */
export type CreateFieldPayload = {
  __typename?: 'CreateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `Field`. */
  component?: Maybe<Component>;
  /** The `Field` that was created by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Form` that is related to this `Field`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Field` mutation. */
export type CreateFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the create `FieldProperty` mutation. */
export type CreateFieldPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FieldProperty` to be created by this mutation. */
  fieldProperty: FieldPropertyInput;
};

/** The output of our create `FieldProperty` mutation. */
export type CreateFieldPropertyPayload = {
  __typename?: 'CreateFieldPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FieldProperty`. */
  field?: Maybe<Field>;
  /** The `FieldProperty` that was created by this mutation. */
  fieldProperty?: Maybe<FieldProperty>;
  /** An edge for our `FieldProperty`. May be used by Relay 1. */
  fieldPropertyEdge?: Maybe<FieldPropertiesEdge>;
  /** Reads a single `Property` that is related to this `FieldProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FieldProperty` mutation. */
export type CreateFieldPropertyPayloadFieldPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};

/** All input for the create `FieldTranslation` mutation. */
export type CreateFieldTranslationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FieldTranslation` to be created by this mutation. */
  fieldTranslation: FieldTranslationInput;
};

/** The output of our create `FieldTranslation` mutation. */
export type CreateFieldTranslationPayload = {
  __typename?: 'CreateFieldTranslationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FieldTranslation`. */
  field?: Maybe<Field>;
  /** The `FieldTranslation` that was created by this mutation. */
  fieldTranslation?: Maybe<FieldTranslation>;
  /** An edge for our `FieldTranslation`. May be used by Relay 1. */
  fieldTranslationEdge?: Maybe<FieldTranslationsEdge>;
  /** Reads a single `Language` that is related to this `FieldTranslation`. */
  language?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FieldTranslation` mutation. */
export type CreateFieldTranslationPayloadFieldTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};

/** All input for the create `FillupFormField` mutation. */
export type CreateFillupFormFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FillupFormField` to be created by this mutation. */
  fillupFormField: FillupFormFieldInput;
};

/** The output of our create `FillupFormField` mutation. */
export type CreateFillupFormFieldPayload = {
  __typename?: 'CreateFillupFormFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FillupFormField`. */
  field?: Maybe<Field>;
  /** Reads a single `FillupForm` that is related to this `FillupFormField`. */
  fillupForm?: Maybe<FillupForm>;
  /** The `FillupFormField` that was created by this mutation. */
  fillupFormField?: Maybe<FillupFormField>;
  /** An edge for our `FillupFormField`. May be used by Relay 1. */
  fillupFormFieldEdge?: Maybe<FillupFormFieldsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FillupFormField` mutation. */
export type CreateFillupFormFieldPayloadFillupFormFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};

/** All input for the create `FillupForm` mutation. */
export type CreateFillupFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FillupForm` to be created by this mutation. */
  fillupForm: FillupFormInput;
};

/** The output of our create `FillupForm` mutation. */
export type CreateFillupFormPayload = {
  __typename?: 'CreateFillupFormPayload';
  /** Reads a single `Admin` that is related to this `FillupForm`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FillupForm` that was created by this mutation. */
  fillupForm?: Maybe<FillupForm>;
  /** An edge for our `FillupForm`. May be used by Relay 1. */
  fillupFormEdge?: Maybe<FillupFormsEdge>;
  /** Reads a single `Form` that is related to this `FillupForm`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  user?: Maybe<User>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  userByApprovedBy?: Maybe<User>;
};


/** The output of our create `FillupForm` mutation. */
export type CreateFillupFormPayloadFillupFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** All input for the create `Form` mutation. */
export type CreateFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Form` to be created by this mutation. */
  form: FormInput;
};

/** All input for the create `FormOrganization` mutation. */
export type CreateFormOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormOrganization` to be created by this mutation. */
  formOrganization: FormOrganizationInput;
};

/** The output of our create `FormOrganization` mutation. */
export type CreateFormOrganizationPayload = {
  __typename?: 'CreateFormOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormOrganization`. */
  form?: Maybe<Form>;
  /** The `FormOrganization` that was created by this mutation. */
  formOrganization?: Maybe<FormOrganization>;
  /** An edge for our `FormOrganization`. May be used by Relay 1. */
  formOrganizationEdge?: Maybe<FormOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FormOrganization` mutation. */
export type CreateFormOrganizationPayloadFormOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};

/** The output of our create `Form` mutation. */
export type CreateFormPayload = {
  __typename?: 'CreateFormPayload';
  /** Reads a single `Admin` that is related to this `Form`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `Form`. */
  createdFromTemplate?: Maybe<FormTemplate>;
  /** The `Form` that was created by this mutation. */
  form?: Maybe<Form>;
  /** An edge for our `Form`. May be used by Relay 1. */
  formEdge?: Maybe<FormsEdge>;
  /** Reads a single `Group` that is related to this `Form`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Form`. */
  team?: Maybe<Team>;
};


/** The output of our create `Form` mutation. */
export type CreateFormPayloadFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** All input for the create `FormTemplateGroup` mutation. */
export type CreateFormTemplateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplateGroup` to be created by this mutation. */
  formTemplateGroup: FormTemplateGroupInput;
};

/** The output of our create `FormTemplateGroup` mutation. */
export type CreateFormTemplateGroupPayload = {
  __typename?: 'CreateFormTemplateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateGroup`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateGroup` that was created by this mutation. */
  formTemplateGroup?: Maybe<FormTemplateGroup>;
  /** An edge for our `FormTemplateGroup`. May be used by Relay 1. */
  formTemplateGroupEdge?: Maybe<FormTemplateGroupsEdge>;
  /** Reads a single `Group` that is related to this `FormTemplateGroup`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FormTemplateGroup` mutation. */
export type CreateFormTemplateGroupPayloadFormTemplateGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};

/** All input for the create `FormTemplate` mutation. */
export type CreateFormTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplate` to be created by this mutation. */
  formTemplate: FormTemplateInput;
};

/** All input for the create `FormTemplateOrganization` mutation. */
export type CreateFormTemplateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplateOrganization` to be created by this mutation. */
  formTemplateOrganization: FormTemplateOrganizationInput;
};

/** The output of our create `FormTemplateOrganization` mutation. */
export type CreateFormTemplateOrganizationPayload = {
  __typename?: 'CreateFormTemplateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateOrganization`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateOrganization` that was created by this mutation. */
  formTemplateOrganization?: Maybe<FormTemplateOrganization>;
  /** An edge for our `FormTemplateOrganization`. May be used by Relay 1. */
  formTemplateOrganizationEdge?: Maybe<FormTemplateOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormTemplateOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FormTemplateOrganization` mutation. */
export type CreateFormTemplateOrganizationPayloadFormTemplateOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};

/** The output of our create `FormTemplate` mutation. */
export type CreateFormTemplatePayload = {
  __typename?: 'CreateFormTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormTemplate`. */
  form?: Maybe<Form>;
  /** The `FormTemplate` that was created by this mutation. */
  formTemplate?: Maybe<FormTemplate>;
  /** An edge for our `FormTemplate`. May be used by Relay 1. */
  formTemplateEdge?: Maybe<FormTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FormTemplate` mutation. */
export type CreateFormTemplatePayloadFormTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};

/** All input for the create `FormTemplateProject` mutation. */
export type CreateFormTemplateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplateProject` to be created by this mutation. */
  formTemplateProject: FormTemplateProjectInput;
};

/** The output of our create `FormTemplateProject` mutation. */
export type CreateFormTemplateProjectPayload = {
  __typename?: 'CreateFormTemplateProjectPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateProject`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateProject` that was created by this mutation. */
  formTemplateProject?: Maybe<FormTemplateProject>;
  /** An edge for our `FormTemplateProject`. May be used by Relay 1. */
  formTemplateProjectEdge?: Maybe<FormTemplateProjectsEdge>;
  /** Reads a single `Project` that is related to this `FormTemplateProject`. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FormTemplateProject` mutation. */
export type CreateFormTemplateProjectPayloadFormTemplateProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};

/** All input for the create `FormTemplateTeam` mutation. */
export type CreateFormTemplateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplateTeam` to be created by this mutation. */
  formTemplateTeam: FormTemplateTeamInput;
};

/** The output of our create `FormTemplateTeam` mutation. */
export type CreateFormTemplateTeamPayload = {
  __typename?: 'CreateFormTemplateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateTeam`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateTeam` that was created by this mutation. */
  formTemplateTeam?: Maybe<FormTemplateTeam>;
  /** An edge for our `FormTemplateTeam`. May be used by Relay 1. */
  formTemplateTeamEdge?: Maybe<FormTemplateTeamsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `FormTemplateTeam`. */
  team?: Maybe<Team>;
};


/** The output of our create `FormTemplateTeam` mutation. */
export type CreateFormTemplateTeamPayloadFormTemplateTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};

/** All input for the create `FormTemplateUser` mutation. */
export type CreateFormTemplateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormTemplateUser` to be created by this mutation. */
  formTemplateUser: FormTemplateUserInput;
};

/** The output of our create `FormTemplateUser` mutation. */
export type CreateFormTemplateUserPayload = {
  __typename?: 'CreateFormTemplateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateUser`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateUser` that was created by this mutation. */
  formTemplateUser?: Maybe<FormTemplateUser>;
  /** An edge for our `FormTemplateUser`. May be used by Relay 1. */
  formTemplateUserEdge?: Maybe<FormTemplateUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormTemplateUser`. */
  user?: Maybe<User>;
};


/** The output of our create `FormTemplateUser` mutation. */
export type CreateFormTemplateUserPayloadFormTemplateUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};

/** All input for the create `FormUser` mutation. */
export type CreateFormUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FormUser` to be created by this mutation. */
  formUser: FormUserInput;
};

/** The output of our create `FormUser` mutation. */
export type CreateFormUserPayload = {
  __typename?: 'CreateFormUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormUser`. */
  form?: Maybe<Form>;
  /** The `FormUser` that was created by this mutation. */
  formUser?: Maybe<FormUser>;
  /** An edge for our `FormUser`. May be used by Relay 1. */
  formUserEdge?: Maybe<FormUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormUser`. */
  user?: Maybe<User>;
};


/** The output of our create `FormUser` mutation. */
export type CreateFormUserPayloadFormUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /** Reads a single `Admin` that is related to this `Group`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Group` that was created by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Organization` that is related to this `Group`. */
  organization?: Maybe<Organization>;
  /** Reads a single `Group` that is related to this `Group`. */
  parent?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Group` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the create `GroupUser` mutation. */
export type CreateGroupUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GroupUser` to be created by this mutation. */
  groupUser: GroupUserInput;
};

/** The output of our create `GroupUser` mutation. */
export type CreateGroupUserPayload = {
  __typename?: 'CreateGroupUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  /** The `GroupUser` that was created by this mutation. */
  groupUser?: Maybe<GroupUser>;
  /** An edge for our `GroupUser`. May be used by Relay 1. */
  groupUserEdge?: Maybe<GroupUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
};


/** The output of our create `GroupUser` mutation. */
export type CreateGroupUserPayloadGroupUserEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};

/** All input for the create `Issuance` mutation. */
export type CreateIssuanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Issuance` to be created by this mutation. */
  issuance: IssuanceInput;
};

/** The output of our create `Issuance` mutation. */
export type CreateIssuancePayload = {
  __typename?: 'CreateIssuancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Equipment` that is related to this `Issuance`. */
  equipment?: Maybe<Equipment>;
  /** The `Issuance` that was created by this mutation. */
  issuance?: Maybe<Issuance>;
  /** An edge for our `Issuance`. May be used by Relay 1. */
  issuanceEdge?: Maybe<IssuancesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Issuance`. */
  user?: Maybe<User>;
};


/** The output of our create `Issuance` mutation. */
export type CreateIssuancePayloadIssuanceEdgeArgs = {
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};

/** All input for the create `Job` mutation. */
export type CreateJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Job` to be created by this mutation. */
  job: JobInput;
};

/** The output of our create `Job` mutation. */
export type CreateJobPayload = {
  __typename?: 'CreateJobPayload';
  /** Reads a single `User` that is related to this `Job`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Job` that was created by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Reads a single `Organization` that is related to this `Job`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Job` mutation. */
export type CreateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the create `JobSendingEmailCategory` mutation. */
export type CreateJobSendingEmailCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobSendingEmailCategory` to be created by this mutation. */
  jobSendingEmailCategory: JobSendingEmailCategoryInput;
};

/** The output of our create `JobSendingEmailCategory` mutation. */
export type CreateJobSendingEmailCategoryPayload = {
  __typename?: 'CreateJobSendingEmailCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JobSendingEmailCategory` that was created by this mutation. */
  jobSendingEmailCategory?: Maybe<JobSendingEmailCategory>;
  /** An edge for our `JobSendingEmailCategory`. May be used by Relay 1. */
  jobSendingEmailCategoryEdge?: Maybe<JobSendingEmailCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobSendingEmailCategory` mutation. */
export type CreateJobSendingEmailCategoryPayloadJobSendingEmailCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};

/** All input for the create `JobSendingEmail` mutation. */
export type CreateJobSendingEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobSendingEmail` to be created by this mutation. */
  jobSendingEmail: JobSendingEmailInput;
};

/** All input for the create `JobSendingEmailLog` mutation. */
export type CreateJobSendingEmailLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JobSendingEmailLog` to be created by this mutation. */
  jobSendingEmailLog: JobSendingEmailLogInput;
};

/** The output of our create `JobSendingEmailLog` mutation. */
export type CreateJobSendingEmailLogPayload = {
  __typename?: 'CreateJobSendingEmailLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `JobSendingEmail` that is related to this `JobSendingEmailLog`. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** The `JobSendingEmailLog` that was created by this mutation. */
  jobSendingEmailLog?: Maybe<JobSendingEmailLog>;
  /** An edge for our `JobSendingEmailLog`. May be used by Relay 1. */
  jobSendingEmailLogEdge?: Maybe<JobSendingEmailLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `JobSendingEmailLog` mutation. */
export type CreateJobSendingEmailLogPayloadJobSendingEmailLogEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailLogsOrderBy>>;
};

/** The output of our create `JobSendingEmail` mutation. */
export type CreateJobSendingEmailPayload = {
  __typename?: 'CreateJobSendingEmailPayload';
  /** Reads a single `JobSendingEmailCategory` that is related to this `JobSendingEmail`. */
  category?: Maybe<JobSendingEmailCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JobSendingEmail` that was created by this mutation. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** An edge for our `JobSendingEmail`. May be used by Relay 1. */
  jobSendingEmailEdge?: Maybe<JobSendingEmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentFrom?: Maybe<User>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentTo?: Maybe<User>;
};


/** The output of our create `JobSendingEmail` mutation. */
export type CreateJobSendingEmailPayloadJobSendingEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** All input for the create `Kind` mutation. */
export type CreateKindInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Kind` to be created by this mutation. */
  kind: KindInput;
};

/** The output of our create `Kind` mutation. */
export type CreateKindPayload = {
  __typename?: 'CreateKindPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Kind` that was created by this mutation. */
  kind?: Maybe<Kind>;
  /** An edge for our `Kind`. May be used by Relay 1. */
  kindEdge?: Maybe<KindsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Kind` mutation. */
export type CreateKindPayloadKindEdgeArgs = {
  orderBy?: InputMaybe<Array<KindsOrderBy>>;
};

/** All input for the create `Language` mutation. */
export type CreateLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Language` to be created by this mutation. */
  language: LanguageInput;
};

/** The output of our create `Language` mutation. */
export type CreateLanguagePayload = {
  __typename?: 'CreateLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Language` that was created by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Language` mutation. */
export type CreateLanguagePayloadLanguageEdgeArgs = {
  orderBy?: InputMaybe<Array<LanguagesOrderBy>>;
};

/** All input for the create `LoginTransaction` mutation. */
export type CreateLoginTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LoginTransaction` to be created by this mutation. */
  loginTransaction: LoginTransactionInput;
};

/** The output of our create `LoginTransaction` mutation. */
export type CreateLoginTransactionPayload = {
  __typename?: 'CreateLoginTransactionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LoginTransaction` that was created by this mutation. */
  loginTransaction?: Maybe<LoginTransaction>;
  /** An edge for our `LoginTransaction`. May be used by Relay 1. */
  loginTransactionEdge?: Maybe<LoginTransactionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoginTransaction`. */
  user?: Maybe<User>;
};


/** The output of our create `LoginTransaction` mutation. */
export type CreateLoginTransactionPayloadLoginTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<LoginTransactionsOrderBy>>;
};

/** All input for the create `Metric` mutation. */
export type CreateMetricInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Metric` to be created by this mutation. */
  metric: MetricInput;
};

/** The output of our create `Metric` mutation. */
export type CreateMetricPayload = {
  __typename?: 'CreateMetricPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Metric` that was created by this mutation. */
  metric?: Maybe<Metric>;
  /** An edge for our `Metric`. May be used by Relay 1. */
  metricEdge?: Maybe<MetricsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Metric` mutation. */
export type CreateMetricPayloadMetricEdgeArgs = {
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};

/** All input for the create `Migration` mutation. */
export type CreateMigrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Migration` to be created by this mutation. */
  migration: MigrationInput;
};

/** The output of our create `Migration` mutation. */
export type CreateMigrationPayload = {
  __typename?: 'CreateMigrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Migration` that was created by this mutation. */
  migration?: Maybe<Migration>;
  /** An edge for our `Migration`. May be used by Relay 1. */
  migrationEdge?: Maybe<MigrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Migration` mutation. */
export type CreateMigrationPayloadMigrationEdgeArgs = {
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};

/** All input for the create `News` mutation. */
export type CreateNewsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `News` to be created by this mutation. */
  news: NewsInput;
};

/** The output of our create `News` mutation. */
export type CreateNewsPayload = {
  __typename?: 'CreateNewsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `News` that was created by this mutation. */
  news?: Maybe<News>;
  /** An edge for our `News`. May be used by Relay 1. */
  newsEdge?: Maybe<NewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `News` mutation. */
export type CreateNewsPayloadNewsEdgeArgs = {
  orderBy?: InputMaybe<Array<NewsOrderBy>>;
};

/** All input for the create `Organization` mutation. */
export type CreateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Organization` to be created by this mutation. */
  organization: OrganizationInput;
};

/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload';
  /** Reads a single `Admin` that is related to this `Organization`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was created by this mutation. */
  organization?: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};

/** All input for the create `OrganizationUser` mutation. */
export type CreateOrganizationUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OrganizationUser` to be created by this mutation. */
  organizationUser: OrganizationUserInput;
};

/** The output of our create `OrganizationUser` mutation. */
export type CreateOrganizationUserPayload = {
  __typename?: 'CreateOrganizationUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationUser`. */
  organization?: Maybe<Organization>;
  /** The `OrganizationUser` that was created by this mutation. */
  organizationUser?: Maybe<OrganizationUser>;
  /** An edge for our `OrganizationUser`. May be used by Relay 1. */
  organizationUserEdge?: Maybe<OrganizationUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationUser`. */
  user?: Maybe<User>;
};


/** The output of our create `OrganizationUser` mutation. */
export type CreateOrganizationUserPayloadOrganizationUserEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};

/** All input for the create `PasswordReset` mutation. */
export type CreatePasswordResetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PasswordReset` to be created by this mutation. */
  passwordReset: PasswordResetInput;
};

/** The output of our create `PasswordReset` mutation. */
export type CreatePasswordResetPayload = {
  __typename?: 'CreatePasswordResetPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PasswordReset` that was created by this mutation. */
  passwordReset?: Maybe<PasswordReset>;
  /** An edge for our `PasswordReset`. May be used by Relay 1. */
  passwordResetEdge?: Maybe<PasswordResetsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PasswordReset` mutation. */
export type CreatePasswordResetPayloadPasswordResetEdgeArgs = {
  orderBy?: InputMaybe<Array<PasswordResetsOrderBy>>;
};

/** All input for the create `PersonalAccessToken` mutation. */
export type CreatePersonalAccessTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PersonalAccessToken` to be created by this mutation. */
  personalAccessToken: PersonalAccessTokenInput;
};

/** The output of our create `PersonalAccessToken` mutation. */
export type CreatePersonalAccessTokenPayload = {
  __typename?: 'CreatePersonalAccessTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PersonalAccessToken` that was created by this mutation. */
  personalAccessToken?: Maybe<PersonalAccessToken>;
  /** An edge for our `PersonalAccessToken`. May be used by Relay 1. */
  personalAccessTokenEdge?: Maybe<PersonalAccessTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PersonalAccessToken` mutation. */
export type CreatePersonalAccessTokenPayloadPersonalAccessTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<PersonalAccessTokensOrderBy>>;
};

/** All input for the create `Profile` mutation. */
export type CreateProfileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Profile` to be created by this mutation. */
  profile: ProfileInput;
};

/** The output of our create `Profile` mutation. */
export type CreateProfilePayload = {
  __typename?: 'CreateProfilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Profile`. */
  pro_id?: Maybe<User>;
  /** The `Profile` that was created by this mutation. */
  profile?: Maybe<Profile>;
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>;
};


/** The output of our create `Profile` mutation. */
export type CreateProfilePayloadProfileEdgeArgs = {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>;
};

/** All input for the create `Project` mutation. */
export type CreateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Project` to be created by this mutation. */
  project: ProjectInput;
};

/** The output of our create `Project` mutation. */
export type CreateProjectPayload = {
  __typename?: 'CreateProjectPayload';
  /** Reads a single `Admin` that is related to this `Project`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Project`. */
  organization?: Maybe<Organization>;
  /** The `Project` that was created by this mutation. */
  project?: Maybe<Project>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Project` mutation. */
export type CreateProjectPayloadProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the create `ProjectUser` mutation. */
export type CreateProjectUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ProjectUser` to be created by this mutation. */
  projectUser: ProjectUserInput;
};

/** The output of our create `ProjectUser` mutation. */
export type CreateProjectUserPayload = {
  __typename?: 'CreateProjectUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Project` that is related to this `ProjectUser`. */
  project?: Maybe<Project>;
  /** The `ProjectUser` that was created by this mutation. */
  projectUser?: Maybe<ProjectUser>;
  /** An edge for our `ProjectUser`. May be used by Relay 1. */
  projectUserEdge?: Maybe<ProjectUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ProjectUser`. */
  user?: Maybe<User>;
};


/** The output of our create `ProjectUser` mutation. */
export type CreateProjectUserPayloadProjectUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};

/** All input for the create `Property` mutation. */
export type CreatePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Property` to be created by this mutation. */
  property: PropertyInput;
};

/** The output of our create `Property` mutation. */
export type CreatePropertyPayload = {
  __typename?: 'CreatePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Datatype` that is related to this `Property`. */
  datatype?: Maybe<Datatype>;
  /** Reads a single `Kind` that is related to this `Property`. */
  kind?: Maybe<Kind>;
  /** The `Property` that was created by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Property` mutation. */
export type CreatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the create `Role` mutation. */
export type CreateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Role` to be created by this mutation. */
  role: RoleInput;
};

/** The output of our create `Role` mutation. */
export type CreateRolePayload = {
  __typename?: 'CreateRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Role` that is related to this `Role`. */
  parentRole?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our create `Role` mutation. */
export type CreateRolePayloadRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the create `RoleUser` mutation. */
export type CreateRoleUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoleUser` to be created by this mutation. */
  roleUser: RoleUserInput;
};

/** All input for the create `RoleUserOrganization` mutation. */
export type CreateRoleUserOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RoleUserOrganization` to be created by this mutation. */
  roleUserOrganization: RoleUserOrganizationInput;
};

/** The output of our create `RoleUserOrganization` mutation. */
export type CreateRoleUserOrganizationPayload = {
  __typename?: 'CreateRoleUserOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `RoleUserOrganization`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUserOrganization`. */
  role?: Maybe<Role>;
  /** The `RoleUserOrganization` that was created by this mutation. */
  roleUserOrganization?: Maybe<RoleUserOrganization>;
  /** An edge for our `RoleUserOrganization`. May be used by Relay 1. */
  roleUserOrganizationEdge?: Maybe<RoleUserOrganizationsEdge>;
  /** Reads a single `User` that is related to this `RoleUserOrganization`. */
  user?: Maybe<User>;
};


/** The output of our create `RoleUserOrganization` mutation. */
export type CreateRoleUserOrganizationPayloadRoleUserOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** The output of our create `RoleUser` mutation. */
export type CreateRoleUserPayload = {
  __typename?: 'CreateRoleUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUser`. */
  role?: Maybe<Role>;
  /** The `RoleUser` that was created by this mutation. */
  roleUser?: Maybe<RoleUser>;
  /** An edge for our `RoleUser`. May be used by Relay 1. */
  roleUserEdge?: Maybe<RoleUsersEdge>;
  /** Reads a single `User` that is related to this `RoleUser`. */
  user?: Maybe<User>;
};


/** The output of our create `RoleUser` mutation. */
export type CreateRoleUserPayloadRoleUserEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};

/** All input for the create `SchedulerField` mutation. */
export type CreateSchedulerFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SchedulerField` to be created by this mutation. */
  schedulerField: SchedulerFieldInput;
};

/** The output of our create `SchedulerField` mutation. */
export type CreateSchedulerFieldPayload = {
  __typename?: 'CreateSchedulerFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `SchedulerField`. */
  field?: Maybe<Field>;
  /** Reads a single `Form` that is related to this `SchedulerField`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `SchedulerField`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SchedulerField` that was created by this mutation. */
  schedulerField?: Maybe<SchedulerField>;
  /** An edge for our `SchedulerField`. May be used by Relay 1. */
  schedulerFieldEdge?: Maybe<SchedulerFieldsEdge>;
};


/** The output of our create `SchedulerField` mutation. */
export type CreateSchedulerFieldPayloadSchedulerFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** All input for the create `Scheduler` mutation. */
export type CreateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Scheduler` to be created by this mutation. */
  scheduler: SchedulerInput;
};

/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayload = {
  __typename?: 'CreateSchedulerPayload';
  /** Reads a single `Admin` that is related to this `Scheduler`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FillupForm` that is related to this `Scheduler`. */
  fillupform?: Maybe<FillupForm>;
  /** Reads a single `Form` that is related to this `Scheduler`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `Scheduler`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Reads a single `Group` that is related to this `Scheduler`. */
  group?: Maybe<Group>;
  /** Reads a single `Organization` that is related to this `Scheduler`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Scheduler` that was created by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
  /** Reads a single `SchedulerField` that is related to this `Scheduler`. */
  schedulerFields?: Maybe<SchedulerField>;
  /** Reads a single `Team` that is related to this `Scheduler`. */
  team?: Maybe<Team>;
  /** Reads a single `User` that is related to this `Scheduler`. */
  user?: Maybe<User>;
};


/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayloadSchedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the create `SentMail` mutation. */
export type CreateSentMailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SentMail` to be created by this mutation. */
  sentMail: SentMailInput;
};

/** The output of our create `SentMail` mutation. */
export type CreateSentMailPayload = {
  __typename?: 'CreateSentMailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SentMail` that was created by this mutation. */
  sentMail?: Maybe<SentMail>;
  /** An edge for our `SentMail`. May be used by Relay 1. */
  sentMailEdge?: Maybe<SentMailEdge>;
};


/** The output of our create `SentMail` mutation. */
export type CreateSentMailPayloadSentMailEdgeArgs = {
  orderBy?: InputMaybe<Array<SentMailOrderBy>>;
};

/** All input for the create `Session` mutation. */
export type CreateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Session` to be created by this mutation. */
  session: SessionInput;
};

/** The output of our create `Session` mutation. */
export type CreateSessionPayload = {
  __typename?: 'CreateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Session` that was created by this mutation. */
  session?: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<SessionsEdge>;
};


/** The output of our create `Session` mutation. */
export type CreateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the create `SettingGroup` mutation. */
export type CreateSettingGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SettingGroup` to be created by this mutation. */
  settingGroup: SettingGroupInput;
};

/** The output of our create `SettingGroup` mutation. */
export type CreateSettingGroupPayload = {
  __typename?: 'CreateSettingGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SettingGroup` that was created by this mutation. */
  settingGroup?: Maybe<SettingGroup>;
  /** An edge for our `SettingGroup`. May be used by Relay 1. */
  settingGroupEdge?: Maybe<SettingGroupsEdge>;
};


/** The output of our create `SettingGroup` mutation. */
export type CreateSettingGroupPayloadSettingGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingGroupsOrderBy>>;
};

/** All input for the create `Setting` mutation. */
export type CreateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Setting` to be created by this mutation. */
  setting: SettingInput;
};

/** The output of our create `Setting` mutation. */
export type CreateSettingPayload = {
  __typename?: 'CreateSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `SettingGroup` that is related to this `Setting`. */
  group?: Maybe<SettingGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<Setting>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our create `Setting` mutation. */
export type CreateSettingPayloadSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the create `Subscription` mutation. */
export type CreateSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Subscription` to be created by this mutation. */
  subscription: SubscriptionInput;
};

/** All input for the create `SubscriptionItem` mutation. */
export type CreateSubscriptionItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SubscriptionItem` to be created by this mutation. */
  subscriptionItem: SubscriptionItemInput;
};

/** The output of our create `SubscriptionItem` mutation. */
export type CreateSubscriptionItemPayload = {
  __typename?: 'CreateSubscriptionItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SubscriptionItem` that was created by this mutation. */
  subscriptionItem?: Maybe<SubscriptionItem>;
  /** An edge for our `SubscriptionItem`. May be used by Relay 1. */
  subscriptionItemEdge?: Maybe<SubscriptionItemsEdge>;
};


/** The output of our create `SubscriptionItem` mutation. */
export type CreateSubscriptionItemPayloadSubscriptionItemEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionItemsOrderBy>>;
};

/** The output of our create `Subscription` mutation. */
export type CreateSubscriptionPayload = {
  __typename?: 'CreateSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Subscription` that was created by this mutation. */
  subscription?: Maybe<Subscription>;
  /** An edge for our `Subscription`. May be used by Relay 1. */
  subscriptionEdge?: Maybe<SubscriptionsEdge>;
};


/** The output of our create `Subscription` mutation. */
export type CreateSubscriptionPayloadSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};

/** All input for the create `SystemEvent` mutation. */
export type CreateSystemEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SystemEvent` to be created by this mutation. */
  systemEvent: SystemEventInput;
};

/** The output of our create `SystemEvent` mutation. */
export type CreateSystemEventPayload = {
  __typename?: 'CreateSystemEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemEvent` that was created by this mutation. */
  systemEvent?: Maybe<SystemEvent>;
  /** An edge for our `SystemEvent`. May be used by Relay 1. */
  systemEventEdge?: Maybe<SystemEventsEdge>;
};


/** The output of our create `SystemEvent` mutation. */
export type CreateSystemEventPayloadSystemEventEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemEventsOrderBy>>;
};

/** All input for the create `Team` mutation. */
export type CreateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Team` to be created by this mutation. */
  team: TeamInput;
};

/** The output of our create `Team` mutation. */
export type CreateTeamPayload = {
  __typename?: 'CreateTeamPayload';
  /** Reads a single `Admin` that is related to this `Team`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Team`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Team` that was created by this mutation. */
  team?: Maybe<Team>;
  /** An edge for our `Team`. May be used by Relay 1. */
  teamEdge?: Maybe<TeamsEdge>;
};


/** The output of our create `Team` mutation. */
export type CreateTeamPayloadTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};

/** All input for the create `TeamUser` mutation. */
export type CreateTeamUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TeamUser` to be created by this mutation. */
  teamUser: TeamUserInput;
};

/** The output of our create `TeamUser` mutation. */
export type CreateTeamUserPayload = {
  __typename?: 'CreateTeamUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `TeamUser`. */
  team?: Maybe<Team>;
  /** The `TeamUser` that was created by this mutation. */
  teamUser?: Maybe<TeamUser>;
  /** An edge for our `TeamUser`. May be used by Relay 1. */
  teamUserEdge?: Maybe<TeamUsersEdge>;
  /** Reads a single `User` that is related to this `TeamUser`. */
  user?: Maybe<User>;
};


/** The output of our create `TeamUser` mutation. */
export type CreateTeamUserPayloadTeamUserEdgeArgs = {
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};

/** All input for the create `TelescopeEntriesTag` mutation. */
export type CreateTelescopeEntriesTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TelescopeEntriesTag` to be created by this mutation. */
  telescopeEntriesTag: TelescopeEntriesTagInput;
};

/** The output of our create `TelescopeEntriesTag` mutation. */
export type CreateTelescopeEntriesTagPayload = {
  __typename?: 'CreateTelescopeEntriesTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `TelescopeEntry` that is related to this `TelescopeEntriesTag`. */
  entry?: Maybe<TelescopeEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TelescopeEntriesTag` that was created by this mutation. */
  telescopeEntriesTag?: Maybe<TelescopeEntriesTag>;
  /** An edge for our `TelescopeEntriesTag`. May be used by Relay 1. */
  telescopeEntriesTagEdge?: Maybe<TelescopeEntriesTagsEdge>;
};


/** The output of our create `TelescopeEntriesTag` mutation. */
export type CreateTelescopeEntriesTagPayloadTelescopeEntriesTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TelescopeEntriesTagsOrderBy>>;
};

/** All input for the create `TelescopeEntry` mutation. */
export type CreateTelescopeEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TelescopeEntry` to be created by this mutation. */
  telescopeEntry: TelescopeEntryInput;
};

/** The output of our create `TelescopeEntry` mutation. */
export type CreateTelescopeEntryPayload = {
  __typename?: 'CreateTelescopeEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TelescopeEntry` that was created by this mutation. */
  telescopeEntry?: Maybe<TelescopeEntry>;
  /** An edge for our `TelescopeEntry`. May be used by Relay 1. */
  telescopeEntryEdge?: Maybe<TelescopeEntriesEdge>;
};


/** The output of our create `TelescopeEntry` mutation. */
export type CreateTelescopeEntryPayloadTelescopeEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<TelescopeEntriesOrderBy>>;
};

/** All input for the create `TelescopeMonitoring` mutation. */
export type CreateTelescopeMonitoringInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TelescopeMonitoring` to be created by this mutation. */
  telescopeMonitoring: TelescopeMonitoringInput;
};

/** The output of our create `TelescopeMonitoring` mutation. */
export type CreateTelescopeMonitoringPayload = {
  __typename?: 'CreateTelescopeMonitoringPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TelescopeMonitoring` that was created by this mutation. */
  telescopeMonitoring?: Maybe<TelescopeMonitoring>;
  /** An edge for our `TelescopeMonitoring`. May be used by Relay 1. */
  telescopeMonitoringEdge?: Maybe<TelescopeMonitoringsEdge>;
};


/** The output of our create `TelescopeMonitoring` mutation. */
export type CreateTelescopeMonitoringPayloadTelescopeMonitoringEdgeArgs = {
  orderBy?: InputMaybe<Array<TelescopeMonitoringsOrderBy>>;
};

/** All input for the create `Tool` mutation. */
export type CreateToolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Tool` to be created by this mutation. */
  tool: ToolInput;
};

/** The output of our create `Tool` mutation. */
export type CreateToolPayload = {
  __typename?: 'CreateToolPayload';
  /** Reads a single `Admin` that is related to this `Tool`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Metric` that is related to this `Tool`. */
  metric?: Maybe<Metric>;
  /** Reads a single `Organization` that is related to this `Tool`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tool` that was created by this mutation. */
  tool?: Maybe<Tool>;
  /** An edge for our `Tool`. May be used by Relay 1. */
  toolEdge?: Maybe<ToolsEdge>;
  /** Reads a single `Tooltype` that is related to this `Tool`. */
  tooltype?: Maybe<Tooltype>;
};


/** The output of our create `Tool` mutation. */
export type CreateToolPayloadToolEdgeArgs = {
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** All input for the create `ToolUser` mutation. */
export type CreateToolUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ToolUser` to be created by this mutation. */
  toolUser: ToolUserInput;
};

/** The output of our create `ToolUser` mutation. */
export type CreateToolUserPayload = {
  __typename?: 'CreateToolUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tool` that is related to this `ToolUser`. */
  tool?: Maybe<Tool>;
  /** The `ToolUser` that was created by this mutation. */
  toolUser?: Maybe<ToolUser>;
  /** An edge for our `ToolUser`. May be used by Relay 1. */
  toolUserEdge?: Maybe<ToolUsersEdge>;
  /** Reads a single `User` that is related to this `ToolUser`. */
  user?: Maybe<User>;
};


/** The output of our create `ToolUser` mutation. */
export type CreateToolUserPayloadToolUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};

/** All input for the create `Tooltype` mutation. */
export type CreateTooltypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Tooltype` to be created by this mutation. */
  tooltype: TooltypeInput;
};

/** The output of our create `Tooltype` mutation. */
export type CreateTooltypePayload = {
  __typename?: 'CreateTooltypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tooltype` that was created by this mutation. */
  tooltype?: Maybe<Tooltype>;
  /** An edge for our `Tooltype`. May be used by Relay 1. */
  tooltypeEdge?: Maybe<TooltypesEdge>;
};


/** The output of our create `Tooltype` mutation. */
export type CreateTooltypePayloadTooltypeEdgeArgs = {
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserInvite` mutation. */
export type CreateUserInviteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserInvite` to be created by this mutation. */
  userInvite: UserInviteInput;
};

/** The output of our create `UserInvite` mutation. */
export type CreateUserInvitePayload = {
  __typename?: 'CreateUserInvitePayload';
  /** Reads a single `User` that is related to this `UserInvite`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `UserInvite`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `UserInvite`. */
  role?: Maybe<Role>;
  /** Reads a single `Team` that is related to this `UserInvite`. */
  team?: Maybe<Team>;
  /** The `UserInvite` that was created by this mutation. */
  userInvite?: Maybe<UserInvite>;
  /** An edge for our `UserInvite`. May be used by Relay 1. */
  userInviteEdge?: Maybe<UserInvitesEdge>;
};


/** The output of our create `UserInvite` mutation. */
export type CreateUserInvitePayloadUserInviteEdgeArgs = {
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `User`. */
  parent?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `UserSetting` mutation. */
export type CreateUserSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserSetting` to be created by this mutation. */
  userSetting: UserSettingInput;
};

/** The output of our create `UserSetting` mutation. */
export type CreateUserSettingPayload = {
  __typename?: 'CreateUserSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  setting?: Maybe<Setting>;
  /** Reads a single `User` that is related to this `UserSetting`. */
  user?: Maybe<User>;
  /** The `UserSetting` that was created by this mutation. */
  userSetting?: Maybe<UserSetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<UserSettingsEdge>;
};


/** The output of our create `UserSetting` mutation. */
export type CreateUserSettingPayloadUserSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};

/** All input for the create `VerificationToken` mutation. */
export type CreateVerificationTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `VerificationToken` to be created by this mutation. */
  verificationToken: VerificationTokenInput;
};

/** The output of our create `VerificationToken` mutation. */
export type CreateVerificationTokenPayload = {
  __typename?: 'CreateVerificationTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `VerificationToken`. */
  user?: Maybe<User>;
  /** The `VerificationToken` that was created by this mutation. */
  verificationToken?: Maybe<VerificationToken>;
  /** An edge for our `VerificationToken`. May be used by Relay 1. */
  verificationTokenEdge?: Maybe<VerificationTokensEdge>;
  /** Reads a single `VerificationTokenType` that is related to this `VerificationToken`. */
  verificationTokenType?: Maybe<VerificationTokenType>;
};


/** The output of our create `VerificationToken` mutation. */
export type CreateVerificationTokenPayloadVerificationTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** All input for the create `VerificationTokenType` mutation. */
export type CreateVerificationTokenTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `VerificationTokenType` to be created by this mutation. */
  verificationTokenType: VerificationTokenTypeInput;
};

/** The output of our create `VerificationTokenType` mutation. */
export type CreateVerificationTokenTypePayload = {
  __typename?: 'CreateVerificationTokenTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VerificationTokenType` that was created by this mutation. */
  verificationTokenType?: Maybe<VerificationTokenType>;
  /** An edge for our `VerificationTokenType`. May be used by Relay 1. */
  verificationTokenTypeEdge?: Maybe<VerificationTokenTypesEdge>;
};


/** The output of our create `VerificationTokenType` mutation. */
export type CreateVerificationTokenTypePayloadVerificationTokenTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokenTypesOrderBy>>;
};

/** All input for the create `WebsocketsStatisticsEntry` mutation. */
export type CreateWebsocketsStatisticsEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `WebsocketsStatisticsEntry` to be created by this mutation. */
  websocketsStatisticsEntry: WebsocketsStatisticsEntryInput;
};

/** The output of our create `WebsocketsStatisticsEntry` mutation. */
export type CreateWebsocketsStatisticsEntryPayload = {
  __typename?: 'CreateWebsocketsStatisticsEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebsocketsStatisticsEntry` that was created by this mutation. */
  websocketsStatisticsEntry?: Maybe<WebsocketsStatisticsEntry>;
  /** An edge for our `WebsocketsStatisticsEntry`. May be used by Relay 1. */
  websocketsStatisticsEntryEdge?: Maybe<WebsocketsStatisticsEntriesEdge>;
};


/** The output of our create `WebsocketsStatisticsEntry` mutation. */
export type CreateWebsocketsStatisticsEntryPayloadWebsocketsStatisticsEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsocketsStatisticsEntriesOrderBy>>;
};

/** All input for the create `WorkType` mutation. */
export type CreateWorkTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `WorkType` to be created by this mutation. */
  workType: WorkTypeInput;
};

/** The output of our create `WorkType` mutation. */
export type CreateWorkTypePayload = {
  __typename?: 'CreateWorkTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `WorkType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WorkType` that was created by this mutation. */
  workType?: Maybe<WorkType>;
  /** An edge for our `WorkType`. May be used by Relay 1. */
  workTypeEdge?: Maybe<WorkTypesEdge>;
};


/** The output of our create `WorkType` mutation. */
export type CreateWorkTypePayloadWorkTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkTypesOrderBy>>;
};

export type Datatype = Node & {
  __typename?: 'Datatype';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Kind`. */
  kindsByPropertyDatatypeIdAndKindId: DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type DatatypeKindsByPropertyDatatypeIdAndKindIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<KindCondition>;
  filter?: InputMaybe<KindFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<KindsOrderBy>>;
};


export type DatatypePropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/**
 * A condition to be used against `Datatype` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DatatypeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Datatype` object types. All fields are combined with a logical ‘and.’ */
export type DatatypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DatatypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DatatypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DatatypeFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Datatype` */
export type DatatypeInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Kind` values, with data from `Property`. */
export type DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyConnection = {
  __typename?: 'DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyConnection';
  /** A list of edges which contains the `Kind`, info from the `Property`, and the cursor to aid in pagination. */
  edges: Array<DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyEdge>;
  /** A list of `Kind` objects. */
  nodes: Array<Kind>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Kind` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Kind` edge in the connection, with data from `Property`. */
export type DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyEdge = {
  __typename?: 'DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Kind` at the end of the edge. */
  node: Kind;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


/** A `Kind` edge in the connection, with data from `Property`. */
export type DatatypeKindsByPropertyDatatypeIdAndKindIdManyToManyEdgePropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** Represents an update to a `Datatype`. Fields that are set will be updated. */
export type DatatypePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Datatype` values. */
export type DatatypesConnection = {
  __typename?: 'DatatypesConnection';
  /** A list of edges which contains the `Datatype` and cursor to aid in pagination. */
  edges: Array<DatatypesEdge>;
  /** A list of `Datatype` objects. */
  nodes: Array<Datatype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Datatype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Datatype` edge in the connection. */
export type DatatypesEdge = {
  __typename?: 'DatatypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Datatype` at the end of the edge. */
  node: Datatype;
};

/** Methods to use when ordering `Datatype`. */
export enum DatatypesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Date']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Date']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Date']['input']>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** All input for the `deleteAbilityByNodeId` mutation. */
export type DeleteAbilityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Ability` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAbility` mutation. */
export type DeleteAbilityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Ability` mutation. */
export type DeleteAbilityPayload = {
  __typename?: 'DeleteAbilityPayload';
  /** The `Ability` that was deleted by this mutation. */
  ability?: Maybe<Ability>;
  /** An edge for our `Ability`. May be used by Relay 1. */
  abilityEdge?: Maybe<AbilitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAbilityNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Ability` mutation. */
export type DeleteAbilityPayloadAbilityEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilitiesOrderBy>>;
};

/** All input for the `deleteAbilityRoleByNodeId` mutation. */
export type DeleteAbilityRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AbilityRole` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAbilityRole` mutation. */
export type DeleteAbilityRoleInput = {
  abilityId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['BigInt']['input'];
};

/** The output of our delete `AbilityRole` mutation. */
export type DeleteAbilityRolePayload = {
  __typename?: 'DeleteAbilityRolePayload';
  /** Reads a single `Ability` that is related to this `AbilityRole`. */
  ability?: Maybe<Ability>;
  /** The `AbilityRole` that was deleted by this mutation. */
  abilityRole?: Maybe<AbilityRole>;
  /** An edge for our `AbilityRole`. May be used by Relay 1. */
  abilityRoleEdge?: Maybe<AbilityRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAbilityRoleNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `AbilityRole`. */
  role?: Maybe<Role>;
};


/** The output of our delete `AbilityRole` mutation. */
export type DeleteAbilityRolePayloadAbilityRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};

/** All input for the `deleteAdminByNodeId` mutation. */
export type DeleteAdminByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Admin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAdmin` mutation. */
export type DeleteAdminInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Admin` mutation. */
export type DeleteAdminPayload = {
  __typename?: 'DeleteAdminPayload';
  /** The `Admin` that was deleted by this mutation. */
  admin?: Maybe<Admin>;
  /** An edge for our `Admin`. May be used by Relay 1. */
  adminEdge?: Maybe<AdminsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAdminNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Admin`. */
  user?: Maybe<User>;
};


/** The output of our delete `Admin` mutation. */
export type DeleteAdminPayloadAdminEdgeArgs = {
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};

/** All input for the `deleteAllowedSettingValueByNodeId` mutation. */
export type DeleteAllowedSettingValueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AllowedSettingValue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAllowedSettingValue` mutation. */
export type DeleteAllowedSettingValueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `AllowedSettingValue` mutation. */
export type DeleteAllowedSettingValuePayload = {
  __typename?: 'DeleteAllowedSettingValuePayload';
  /** The `AllowedSettingValue` that was deleted by this mutation. */
  allowedSettingValue?: Maybe<AllowedSettingValue>;
  /** An edge for our `AllowedSettingValue`. May be used by Relay 1. */
  allowedSettingValueEdge?: Maybe<AllowedSettingValuesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAllowedSettingValueNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `AllowedSettingValue`. */
  setting?: Maybe<Setting>;
};


/** The output of our delete `AllowedSettingValue` mutation. */
export type DeleteAllowedSettingValuePayloadAllowedSettingValueEdgeArgs = {
  orderBy?: InputMaybe<Array<AllowedSettingValuesOrderBy>>;
};

/** All input for the `deleteAttachmentByNodeId` mutation. */
export type DeleteAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAttachment` mutation. */
export type DeleteAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** The `Attachment` that was deleted by this mutation. */
  attachment?: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge?: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAttachmentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tool` that is related to this `Attachment`. */
  tool?: Maybe<Tool>;
};


/** The output of our delete `Attachment` mutation. */
export type DeleteAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `deleteCertificationByNodeId` mutation. */
export type DeleteCertificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Certification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCertification` mutation. */
export type DeleteCertificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Certification` mutation. */
export type DeleteCertificationPayload = {
  __typename?: 'DeleteCertificationPayload';
  /** Reads a single `User` that is related to this `Certification`. */
  admin?: Maybe<User>;
  /** The `Certification` that was deleted by this mutation. */
  certification?: Maybe<Certification>;
  /** An edge for our `Certification`. May be used by Relay 1. */
  certificationEdge?: Maybe<CertificationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCertificationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Certification`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Certification` mutation. */
export type DeleteCertificationPayloadCertificationEdgeArgs = {
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};

/** All input for the `deleteCompanyByNodeId` mutation. */
export type DeleteCompanyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Company` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCompany` mutation. */
export type DeleteCompanyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Company` mutation. */
export type DeleteCompanyPayload = {
  __typename?: 'DeleteCompanyPayload';
  /** Reads a single `Admin` that is related to this `Company`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Company` that was deleted by this mutation. */
  company?: Maybe<Company>;
  /** An edge for our `Company`. May be used by Relay 1. */
  companyEdge?: Maybe<CompaniesEdge>;
  deletedCompanyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Company`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Company` mutation. */
export type DeleteCompanyPayloadCompanyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** All input for the `deleteComponentByDescription` mutation. */
export type DeleteComponentByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteComponentByNodeId` mutation. */
export type DeleteComponentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Component` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteComponentBySlug` mutation. */
export type DeleteComponentBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** All input for the `deleteComponentEventByNodeId` mutation. */
export type DeleteComponentEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ComponentEvent` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteComponentEvent` mutation. */
export type DeleteComponentEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `ComponentEvent` mutation. */
export type DeleteComponentEventPayload = {
  __typename?: 'DeleteComponentEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentEvent`. */
  component?: Maybe<Component>;
  /** The `ComponentEvent` that was deleted by this mutation. */
  componentEvent?: Maybe<ComponentEvent>;
  /** An edge for our `ComponentEvent`. May be used by Relay 1. */
  componentEventEdge?: Maybe<ComponentEventsEdge>;
  deletedComponentEventNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `ComponentEvent`. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ComponentEvent` mutation. */
export type DeleteComponentEventPayloadComponentEventEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};

/** All input for the `deleteComponent` mutation. */
export type DeleteComponentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Component` mutation. */
export type DeleteComponentPayload = {
  __typename?: 'DeleteComponentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Component` that was deleted by this mutation. */
  component?: Maybe<Component>;
  /** An edge for our `Component`. May be used by Relay 1. */
  componentEdge?: Maybe<ComponentsEdge>;
  deletedComponentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Component` that is related to this `Component`. */
  parent?: Maybe<Component>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Component` mutation. */
export type DeleteComponentPayloadComponentEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};

/** All input for the `deleteComponentPropertyByNodeId` mutation. */
export type DeleteComponentPropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ComponentProperty` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteComponentProperty` mutation. */
export type DeleteComponentPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `ComponentProperty` mutation. */
export type DeleteComponentPropertyPayload = {
  __typename?: 'DeleteComponentPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentProperty`. */
  component?: Maybe<Component>;
  /** The `ComponentProperty` that was deleted by this mutation. */
  componentProperty?: Maybe<ComponentProperty>;
  /** An edge for our `ComponentProperty`. May be used by Relay 1. */
  componentPropertyEdge?: Maybe<ComponentPropertiesEdge>;
  deletedComponentPropertyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Property` that is related to this `ComponentProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ComponentProperty` mutation. */
export type DeleteComponentPropertyPayloadComponentPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};

/** All input for the `deleteCourseByNodeId` mutation. */
export type DeleteCourseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Course` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCourse` mutation. */
export type DeleteCourseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Course` mutation. */
export type DeleteCoursePayload = {
  __typename?: 'DeleteCoursePayload';
  /** Reads a single `User` that is related to this `Course`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Course` that was deleted by this mutation. */
  course?: Maybe<Course>;
  /** An edge for our `Course`. May be used by Relay 1. */
  courseEdge?: Maybe<CoursesEdge>;
  deletedCourseNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Course`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Course` mutation. */
export type DeleteCoursePayloadCourseEdgeArgs = {
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};

/** All input for the `deleteDatatypeByDescription` mutation. */
export type DeleteDatatypeByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteDatatypeByNodeId` mutation. */
export type DeleteDatatypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Datatype` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDatatype` mutation. */
export type DeleteDatatypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Datatype` mutation. */
export type DeleteDatatypePayload = {
  __typename?: 'DeleteDatatypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Datatype` that was deleted by this mutation. */
  datatype?: Maybe<Datatype>;
  /** An edge for our `Datatype`. May be used by Relay 1. */
  datatypeEdge?: Maybe<DatatypesEdge>;
  deletedDatatypeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Datatype` mutation. */
export type DeleteDatatypePayloadDatatypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DatatypesOrderBy>>;
};

/** All input for the `deleteEquipmentByName` mutation. */
export type DeleteEquipmentByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteEquipmentByNodeId` mutation. */
export type DeleteEquipmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Equipment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteEquipment` mutation. */
export type DeleteEquipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Equipment` mutation. */
export type DeleteEquipmentPayload = {
  __typename?: 'DeleteEquipmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEquipmentNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Equipment` that was deleted by this mutation. */
  equipment?: Maybe<Equipment>;
  /** An edge for our `Equipment`. May be used by Relay 1. */
  equipmentEdge?: Maybe<EquipmentEdge>;
  /** Reads a single `EquipmentType` that is related to this `Equipment`. */
  equipmentType?: Maybe<EquipmentType>;
  /** Reads a single `Organization` that is related to this `Equipment`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Equipment`. */
  userByPreparedBy?: Maybe<User>;
};


/** The output of our delete `Equipment` mutation. */
export type DeleteEquipmentPayloadEquipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** All input for the `deleteEquipmentTypeByNodeId` mutation. */
export type DeleteEquipmentTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EquipmentType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteEquipmentType` mutation. */
export type DeleteEquipmentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `EquipmentType` mutation. */
export type DeleteEquipmentTypePayload = {
  __typename?: 'DeleteEquipmentTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEquipmentTypeNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `EquipmentType` that was deleted by this mutation. */
  equipmentType?: Maybe<EquipmentType>;
  /** An edge for our `EquipmentType`. May be used by Relay 1. */
  equipmentTypeEdge?: Maybe<EquipmentTypesEdge>;
  /** Reads a single `Organization` that is related to this `EquipmentType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `EquipmentType` mutation. */
export type DeleteEquipmentTypePayloadEquipmentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};

/** All input for the `deleteErrorReportByNodeId` mutation. */
export type DeleteErrorReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ErrorReport` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteErrorReport` mutation. */
export type DeleteErrorReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `ErrorReport` mutation. */
export type DeleteErrorReportPayload = {
  __typename?: 'DeleteErrorReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedErrorReportNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `ErrorReport` that was deleted by this mutation. */
  errorReport?: Maybe<ErrorReport>;
  /** An edge for our `ErrorReport`. May be used by Relay 1. */
  errorReportEdge?: Maybe<ErrorReportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ErrorReport` mutation. */
export type DeleteErrorReportPayloadErrorReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ErrorReportsOrderBy>>;
};

/** All input for the `deleteEventByDescription` mutation. */
export type DeleteEventByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteEventByNodeId` mutation. */
export type DeleteEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Event` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteEventBySlug` mutation. */
export type DeleteEventBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEventNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Event` that was deleted by this mutation. */
  event?: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteFailedJobByNodeId` mutation. */
export type DeleteFailedJobByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FailedJob` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFailedJobByUuid` mutation. */
export type DeleteFailedJobByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['String']['input'];
};

/** All input for the `deleteFailedJob` mutation. */
export type DeleteFailedJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FailedJob` mutation. */
export type DeleteFailedJobPayload = {
  __typename?: 'DeleteFailedJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFailedJobNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `FailedJob` that was deleted by this mutation. */
  failedJob?: Maybe<FailedJob>;
  /** An edge for our `FailedJob`. May be used by Relay 1. */
  failedJobEdge?: Maybe<FailedJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FailedJob` mutation. */
export type DeleteFailedJobPayloadFailedJobEdgeArgs = {
  orderBy?: InputMaybe<Array<FailedJobsOrderBy>>;
};

/** All input for the `deleteFieldActionByNodeId` mutation. */
export type DeleteFieldActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFieldAction` mutation. */
export type DeleteFieldActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FieldAction` mutation. */
export type DeleteFieldActionPayload = {
  __typename?: 'DeleteFieldActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFieldActionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Event` that is related to this `FieldAction`. */
  event?: Maybe<Event>;
  /** Reads a single `Field` that is related to this `FieldAction`. */
  field?: Maybe<Field>;
  /** The `FieldAction` that was deleted by this mutation. */
  fieldAction?: Maybe<FieldAction>;
  /** An edge for our `FieldAction`. May be used by Relay 1. */
  fieldActionEdge?: Maybe<FieldActionsEdge>;
  /** Reads a single `Property` that is related to this `FieldAction`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FieldAction` mutation. */
export type DeleteFieldActionPayloadFieldActionEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** All input for the `deleteFieldByNodeId` mutation. */
export type DeleteFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Field` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteField` mutation. */
export type DeleteFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Field` mutation. */
export type DeleteFieldPayload = {
  __typename?: 'DeleteFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `Field`. */
  component?: Maybe<Component>;
  deletedFieldNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Field` that was deleted by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Form` that is related to this `Field`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Field` mutation. */
export type DeleteFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the `deleteFieldPropertyByNodeId` mutation. */
export type DeleteFieldPropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldProperty` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFieldProperty` mutation. */
export type DeleteFieldPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FieldProperty` mutation. */
export type DeleteFieldPropertyPayload = {
  __typename?: 'DeleteFieldPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFieldPropertyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Field` that is related to this `FieldProperty`. */
  field?: Maybe<Field>;
  /** The `FieldProperty` that was deleted by this mutation. */
  fieldProperty?: Maybe<FieldProperty>;
  /** An edge for our `FieldProperty`. May be used by Relay 1. */
  fieldPropertyEdge?: Maybe<FieldPropertiesEdge>;
  /** Reads a single `Property` that is related to this `FieldProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FieldProperty` mutation. */
export type DeleteFieldPropertyPayloadFieldPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};

/** All input for the `deleteFieldTranslationByNodeId` mutation. */
export type DeleteFieldTranslationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldTranslation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFieldTranslation` mutation. */
export type DeleteFieldTranslationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FieldTranslation` mutation. */
export type DeleteFieldTranslationPayload = {
  __typename?: 'DeleteFieldTranslationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFieldTranslationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Field` that is related to this `FieldTranslation`. */
  field?: Maybe<Field>;
  /** The `FieldTranslation` that was deleted by this mutation. */
  fieldTranslation?: Maybe<FieldTranslation>;
  /** An edge for our `FieldTranslation`. May be used by Relay 1. */
  fieldTranslationEdge?: Maybe<FieldTranslationsEdge>;
  /** Reads a single `Language` that is related to this `FieldTranslation`. */
  language?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FieldTranslation` mutation. */
export type DeleteFieldTranslationPayloadFieldTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};

/** All input for the `deleteFillupFormByNodeId` mutation. */
export type DeleteFillupFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FillupForm` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFillupFormFieldByNodeId` mutation. */
export type DeleteFillupFormFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FillupFormField` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFillupFormField` mutation. */
export type DeleteFillupFormFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FillupFormField` mutation. */
export type DeleteFillupFormFieldPayload = {
  __typename?: 'DeleteFillupFormFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFillupFormFieldNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Field` that is related to this `FillupFormField`. */
  field?: Maybe<Field>;
  /** Reads a single `FillupForm` that is related to this `FillupFormField`. */
  fillupForm?: Maybe<FillupForm>;
  /** The `FillupFormField` that was deleted by this mutation. */
  fillupFormField?: Maybe<FillupFormField>;
  /** An edge for our `FillupFormField`. May be used by Relay 1. */
  fillupFormFieldEdge?: Maybe<FillupFormFieldsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FillupFormField` mutation. */
export type DeleteFillupFormFieldPayloadFillupFormFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};

/** All input for the `deleteFillupForm` mutation. */
export type DeleteFillupFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `FillupForm` mutation. */
export type DeleteFillupFormPayload = {
  __typename?: 'DeleteFillupFormPayload';
  /** Reads a single `Admin` that is related to this `FillupForm`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFillupFormNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `FillupForm` that was deleted by this mutation. */
  fillupForm?: Maybe<FillupForm>;
  /** An edge for our `FillupForm`. May be used by Relay 1. */
  fillupFormEdge?: Maybe<FillupFormsEdge>;
  /** Reads a single `Form` that is related to this `FillupForm`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  user?: Maybe<User>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  userByApprovedBy?: Maybe<User>;
};


/** The output of our delete `FillupForm` mutation. */
export type DeleteFillupFormPayloadFillupFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** All input for the `deleteFormByNodeId` mutation. */
export type DeleteFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Form` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteForm` mutation. */
export type DeleteFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteFormOrganizationByNodeId` mutation. */
export type DeleteFormOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormOrganization` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormOrganization` mutation. */
export type DeleteFormOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormOrganization` mutation. */
export type DeleteFormOrganizationPayload = {
  __typename?: 'DeleteFormOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormOrganizationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Form` that is related to this `FormOrganization`. */
  form?: Maybe<Form>;
  /** The `FormOrganization` that was deleted by this mutation. */
  formOrganization?: Maybe<FormOrganization>;
  /** An edge for our `FormOrganization`. May be used by Relay 1. */
  formOrganizationEdge?: Maybe<FormOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FormOrganization` mutation. */
export type DeleteFormOrganizationPayloadFormOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};

/** The output of our delete `Form` mutation. */
export type DeleteFormPayload = {
  __typename?: 'DeleteFormPayload';
  /** Reads a single `Admin` that is related to this `Form`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `Form`. */
  createdFromTemplate?: Maybe<FormTemplate>;
  deletedFormNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Form` that was deleted by this mutation. */
  form?: Maybe<Form>;
  /** An edge for our `Form`. May be used by Relay 1. */
  formEdge?: Maybe<FormsEdge>;
  /** Reads a single `Group` that is related to this `Form`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Form`. */
  team?: Maybe<Team>;
};


/** The output of our delete `Form` mutation. */
export type DeleteFormPayloadFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** All input for the `deleteFormTemplateByNodeId` mutation. */
export type DeleteFormTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplate` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateGroupByNodeId` mutation. */
export type DeleteFormTemplateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateGroup` mutation. */
export type DeleteFormTemplateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  groupId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormTemplateGroup` mutation. */
export type DeleteFormTemplateGroupPayload = {
  __typename?: 'DeleteFormTemplateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateGroupNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateGroup`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateGroup` that was deleted by this mutation. */
  formTemplateGroup?: Maybe<FormTemplateGroup>;
  /** An edge for our `FormTemplateGroup`. May be used by Relay 1. */
  formTemplateGroupEdge?: Maybe<FormTemplateGroupsEdge>;
  /** Reads a single `Group` that is related to this `FormTemplateGroup`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FormTemplateGroup` mutation. */
export type DeleteFormTemplateGroupPayloadFormTemplateGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};

/** All input for the `deleteFormTemplate` mutation. */
export type DeleteFormTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteFormTemplateOrganizationByNodeId` mutation. */
export type DeleteFormTemplateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateOrganization` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateOrganization` mutation. */
export type DeleteFormTemplateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormTemplateOrganization` mutation. */
export type DeleteFormTemplateOrganizationPayload = {
  __typename?: 'DeleteFormTemplateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateOrganizationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateOrganization`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateOrganization` that was deleted by this mutation. */
  formTemplateOrganization?: Maybe<FormTemplateOrganization>;
  /** An edge for our `FormTemplateOrganization`. May be used by Relay 1. */
  formTemplateOrganizationEdge?: Maybe<FormTemplateOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormTemplateOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FormTemplateOrganization` mutation. */
export type DeleteFormTemplateOrganizationPayloadFormTemplateOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};

/** The output of our delete `FormTemplate` mutation. */
export type DeleteFormTemplatePayload = {
  __typename?: 'DeleteFormTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Form` that is related to this `FormTemplate`. */
  form?: Maybe<Form>;
  /** The `FormTemplate` that was deleted by this mutation. */
  formTemplate?: Maybe<FormTemplate>;
  /** An edge for our `FormTemplate`. May be used by Relay 1. */
  formTemplateEdge?: Maybe<FormTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FormTemplate` mutation. */
export type DeleteFormTemplatePayloadFormTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};

/** All input for the `deleteFormTemplateProjectByNodeId` mutation. */
export type DeleteFormTemplateProjectByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateProject` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateProject` mutation. */
export type DeleteFormTemplateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  projectId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormTemplateProject` mutation. */
export type DeleteFormTemplateProjectPayload = {
  __typename?: 'DeleteFormTemplateProjectPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateProjectNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateProject`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateProject` that was deleted by this mutation. */
  formTemplateProject?: Maybe<FormTemplateProject>;
  /** An edge for our `FormTemplateProject`. May be used by Relay 1. */
  formTemplateProjectEdge?: Maybe<FormTemplateProjectsEdge>;
  /** Reads a single `Project` that is related to this `FormTemplateProject`. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FormTemplateProject` mutation. */
export type DeleteFormTemplateProjectPayloadFormTemplateProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};

/** All input for the `deleteFormTemplateTeamByNodeId` mutation. */
export type DeleteFormTemplateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateTeam` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateTeam` mutation. */
export type DeleteFormTemplateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  teamId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormTemplateTeam` mutation. */
export type DeleteFormTemplateTeamPayload = {
  __typename?: 'DeleteFormTemplateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateTeamNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateTeam`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateTeam` that was deleted by this mutation. */
  formTemplateTeam?: Maybe<FormTemplateTeam>;
  /** An edge for our `FormTemplateTeam`. May be used by Relay 1. */
  formTemplateTeamEdge?: Maybe<FormTemplateTeamsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `FormTemplateTeam`. */
  team?: Maybe<Team>;
};


/** The output of our delete `FormTemplateTeam` mutation. */
export type DeleteFormTemplateTeamPayloadFormTemplateTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};

/** All input for the `deleteFormTemplateUserByNodeId` mutation. */
export type DeleteFormTemplateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormTemplateUser` mutation. */
export type DeleteFormTemplateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormTemplateUser` mutation. */
export type DeleteFormTemplateUserPayload = {
  __typename?: 'DeleteFormTemplateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormTemplateUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateUser`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateUser` that was deleted by this mutation. */
  formTemplateUser?: Maybe<FormTemplateUser>;
  /** An edge for our `FormTemplateUser`. May be used by Relay 1. */
  formTemplateUserEdge?: Maybe<FormTemplateUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormTemplateUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `FormTemplateUser` mutation. */
export type DeleteFormTemplateUserPayloadFormTemplateUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};

/** All input for the `deleteFormUserByNodeId` mutation. */
export type DeleteFormUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFormUser` mutation. */
export type DeleteFormUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** The output of our delete `FormUser` mutation. */
export type DeleteFormUserPayload = {
  __typename?: 'DeleteFormUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFormUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Form` that is related to this `FormUser`. */
  form?: Maybe<Form>;
  /** The `FormUser` that was deleted by this mutation. */
  formUser?: Maybe<FormUser>;
  /** An edge for our `FormUser`. May be used by Relay 1. */
  formUserEdge?: Maybe<FormUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `FormUser` mutation. */
export type DeleteFormUserPayloadFormUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};

/** All input for the `deleteGroupByNodeId` mutation. */
export type DeleteGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /** Reads a single `Admin` that is related to this `Group`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGroupNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Group` that was deleted by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Organization` that is related to this `Group`. */
  organization?: Maybe<Organization>;
  /** Reads a single `Group` that is related to this `Group`. */
  parent?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteIssuanceByEquipmentIdAndSerialNumber` mutation. */
export type DeleteIssuanceByEquipmentIdAndSerialNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  equipmentId: Scalars['BigInt']['input'];
  serialNumber: Scalars['String']['input'];
};

/** All input for the `deleteIssuanceByNodeId` mutation. */
export type DeleteIssuanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Issuance` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteIssuance` mutation. */
export type DeleteIssuanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Issuance` mutation. */
export type DeleteIssuancePayload = {
  __typename?: 'DeleteIssuancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedIssuanceNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Equipment` that is related to this `Issuance`. */
  equipment?: Maybe<Equipment>;
  /** The `Issuance` that was deleted by this mutation. */
  issuance?: Maybe<Issuance>;
  /** An edge for our `Issuance`. May be used by Relay 1. */
  issuanceEdge?: Maybe<IssuancesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Issuance`. */
  user?: Maybe<User>;
};


/** The output of our delete `Issuance` mutation. */
export type DeleteIssuancePayloadIssuanceEdgeArgs = {
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};

/** All input for the `deleteJobByNodeId` mutation. */
export type DeleteJobByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Job` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJob` mutation. */
export type DeleteJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Job` mutation. */
export type DeleteJobPayload = {
  __typename?: 'DeleteJobPayload';
  /** Reads a single `User` that is related to this `Job`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Job` that was deleted by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Reads a single `Organization` that is related to this `Job`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Job` mutation. */
export type DeleteJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the `deleteJobSendingEmailByNodeId` mutation. */
export type DeleteJobSendingEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmail` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobSendingEmailCategoryByNodeId` mutation. */
export type DeleteJobSendingEmailCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmailCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobSendingEmailCategory` mutation. */
export type DeleteJobSendingEmailCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `JobSendingEmailCategory` mutation. */
export type DeleteJobSendingEmailCategoryPayload = {
  __typename?: 'DeleteJobSendingEmailCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobSendingEmailCategoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `JobSendingEmailCategory` that was deleted by this mutation. */
  jobSendingEmailCategory?: Maybe<JobSendingEmailCategory>;
  /** An edge for our `JobSendingEmailCategory`. May be used by Relay 1. */
  jobSendingEmailCategoryEdge?: Maybe<JobSendingEmailCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `JobSendingEmailCategory` mutation. */
export type DeleteJobSendingEmailCategoryPayloadJobSendingEmailCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};

/** All input for the `deleteJobSendingEmail` mutation. */
export type DeleteJobSendingEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteJobSendingEmailLogByNodeId` mutation. */
export type DeleteJobSendingEmailLogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmailLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteJobSendingEmailLog` mutation. */
export type DeleteJobSendingEmailLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `JobSendingEmailLog` mutation. */
export type DeleteJobSendingEmailLogPayload = {
  __typename?: 'DeleteJobSendingEmailLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobSendingEmailLogNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `JobSendingEmail` that is related to this `JobSendingEmailLog`. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** The `JobSendingEmailLog` that was deleted by this mutation. */
  jobSendingEmailLog?: Maybe<JobSendingEmailLog>;
  /** An edge for our `JobSendingEmailLog`. May be used by Relay 1. */
  jobSendingEmailLogEdge?: Maybe<JobSendingEmailLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `JobSendingEmailLog` mutation. */
export type DeleteJobSendingEmailLogPayloadJobSendingEmailLogEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailLogsOrderBy>>;
};

/** The output of our delete `JobSendingEmail` mutation. */
export type DeleteJobSendingEmailPayload = {
  __typename?: 'DeleteJobSendingEmailPayload';
  /** Reads a single `JobSendingEmailCategory` that is related to this `JobSendingEmail`. */
  category?: Maybe<JobSendingEmailCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobSendingEmailNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `JobSendingEmail` that was deleted by this mutation. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** An edge for our `JobSendingEmail`. May be used by Relay 1. */
  jobSendingEmailEdge?: Maybe<JobSendingEmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentFrom?: Maybe<User>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentTo?: Maybe<User>;
};


/** The output of our delete `JobSendingEmail` mutation. */
export type DeleteJobSendingEmailPayloadJobSendingEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** All input for the `deleteKindByDescription` mutation. */
export type DeleteKindByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteKindByNodeId` mutation. */
export type DeleteKindByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Kind` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteKindBySlug` mutation. */
export type DeleteKindBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** All input for the `deleteKind` mutation. */
export type DeleteKindInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Kind` mutation. */
export type DeleteKindPayload = {
  __typename?: 'DeleteKindPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedKindNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Kind` that was deleted by this mutation. */
  kind?: Maybe<Kind>;
  /** An edge for our `Kind`. May be used by Relay 1. */
  kindEdge?: Maybe<KindsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Kind` mutation. */
export type DeleteKindPayloadKindEdgeArgs = {
  orderBy?: InputMaybe<Array<KindsOrderBy>>;
};

/** All input for the `deleteLanguageByNodeId` mutation. */
export type DeleteLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Language` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteLanguage` mutation. */
export type DeleteLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Language` mutation. */
export type DeleteLanguagePayload = {
  __typename?: 'DeleteLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLanguageNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Language` that was deleted by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Language` mutation. */
export type DeleteLanguagePayloadLanguageEdgeArgs = {
  orderBy?: InputMaybe<Array<LanguagesOrderBy>>;
};

/** All input for the `deleteLoginTransactionByNodeId` mutation. */
export type DeleteLoginTransactionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LoginTransaction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteLoginTransaction` mutation. */
export type DeleteLoginTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `LoginTransaction` mutation. */
export type DeleteLoginTransactionPayload = {
  __typename?: 'DeleteLoginTransactionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLoginTransactionNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `LoginTransaction` that was deleted by this mutation. */
  loginTransaction?: Maybe<LoginTransaction>;
  /** An edge for our `LoginTransaction`. May be used by Relay 1. */
  loginTransactionEdge?: Maybe<LoginTransactionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoginTransaction`. */
  user?: Maybe<User>;
};


/** The output of our delete `LoginTransaction` mutation. */
export type DeleteLoginTransactionPayloadLoginTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<LoginTransactionsOrderBy>>;
};

/** All input for the `deleteMetricByNodeId` mutation. */
export type DeleteMetricByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Metric` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMetric` mutation. */
export type DeleteMetricInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Metric` mutation. */
export type DeleteMetricPayload = {
  __typename?: 'DeleteMetricPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMetricNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Metric` that was deleted by this mutation. */
  metric?: Maybe<Metric>;
  /** An edge for our `Metric`. May be used by Relay 1. */
  metricEdge?: Maybe<MetricsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Metric` mutation. */
export type DeleteMetricPayloadMetricEdgeArgs = {
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};

/** All input for the `deleteMigrationByNodeId` mutation. */
export type DeleteMigrationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Migration` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMigration` mutation. */
export type DeleteMigrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Migration` mutation. */
export type DeleteMigrationPayload = {
  __typename?: 'DeleteMigrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMigrationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Migration` that was deleted by this mutation. */
  migration?: Maybe<Migration>;
  /** An edge for our `Migration`. May be used by Relay 1. */
  migrationEdge?: Maybe<MigrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Migration` mutation. */
export type DeleteMigrationPayloadMigrationEdgeArgs = {
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};

/** All input for the `deleteNewsByNodeId` mutation. */
export type DeleteNewsByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `News` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteNews` mutation. */
export type DeleteNewsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `News` mutation. */
export type DeleteNewsPayload = {
  __typename?: 'DeleteNewsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedNewsNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `News` that was deleted by this mutation. */
  news?: Maybe<News>;
  /** An edge for our `News`. May be used by Relay 1. */
  newsEdge?: Maybe<NewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `News` mutation. */
export type DeleteNewsPayloadNewsEdgeArgs = {
  orderBy?: InputMaybe<Array<NewsOrderBy>>;
};

/** All input for the `deleteOrganizationByNodeId` mutation. */
export type DeleteOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganization` mutation. */
export type DeleteOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload';
  /** Reads a single `Admin` that is related to this `Organization`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganizationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Organization` that was deleted by this mutation. */
  organization?: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};

/** All input for the `deleteOrganizationUserByNodeId` mutation. */
export type DeleteOrganizationUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganizationUser` mutation. */
export type DeleteOrganizationUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** The output of our delete `OrganizationUser` mutation. */
export type DeleteOrganizationUserPayload = {
  __typename?: 'DeleteOrganizationUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganizationUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationUser`. */
  organization?: Maybe<Organization>;
  /** The `OrganizationUser` that was deleted by this mutation. */
  organizationUser?: Maybe<OrganizationUser>;
  /** An edge for our `OrganizationUser`. May be used by Relay 1. */
  organizationUserEdge?: Maybe<OrganizationUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `OrganizationUser` mutation. */
export type DeleteOrganizationUserPayloadOrganizationUserEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};

/** All input for the `deletePersonalAccessTokenByNodeId` mutation. */
export type DeletePersonalAccessTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PersonalAccessToken` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePersonalAccessTokenByToken` mutation. */
export type DeletePersonalAccessTokenByTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};

/** All input for the `deletePersonalAccessToken` mutation. */
export type DeletePersonalAccessTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `PersonalAccessToken` mutation. */
export type DeletePersonalAccessTokenPayload = {
  __typename?: 'DeletePersonalAccessTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPersonalAccessTokenNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `PersonalAccessToken` that was deleted by this mutation. */
  personalAccessToken?: Maybe<PersonalAccessToken>;
  /** An edge for our `PersonalAccessToken`. May be used by Relay 1. */
  personalAccessTokenEdge?: Maybe<PersonalAccessTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PersonalAccessToken` mutation. */
export type DeletePersonalAccessTokenPayloadPersonalAccessTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<PersonalAccessTokensOrderBy>>;
};

/** All input for the `deleteProfileByNodeId` mutation. */
export type DeleteProfileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Profile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteProfile` mutation. */
export type DeleteProfileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Profile` mutation. */
export type DeleteProfilePayload = {
  __typename?: 'DeleteProfilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedProfileNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `Profile`. */
  pro_id?: Maybe<User>;
  /** The `Profile` that was deleted by this mutation. */
  profile?: Maybe<Profile>;
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>;
};


/** The output of our delete `Profile` mutation. */
export type DeleteProfilePayloadProfileEdgeArgs = {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>;
};

/** All input for the `deleteProjectByNodeId` mutation. */
export type DeleteProjectByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Project` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteProject` mutation. */
export type DeleteProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Project` mutation. */
export type DeleteProjectPayload = {
  __typename?: 'DeleteProjectPayload';
  /** Reads a single `Admin` that is related to this `Project`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedProjectNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Project`. */
  organization?: Maybe<Organization>;
  /** The `Project` that was deleted by this mutation. */
  project?: Maybe<Project>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Project` mutation. */
export type DeleteProjectPayloadProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `deleteProjectUserByNodeId` mutation. */
export type DeleteProjectUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ProjectUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteProjectUser` mutation. */
export type DeleteProjectUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `ProjectUser` mutation. */
export type DeleteProjectUserPayload = {
  __typename?: 'DeleteProjectUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedProjectUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Project` that is related to this `ProjectUser`. */
  project?: Maybe<Project>;
  /** The `ProjectUser` that was deleted by this mutation. */
  projectUser?: Maybe<ProjectUser>;
  /** An edge for our `ProjectUser`. May be used by Relay 1. */
  projectUserEdge?: Maybe<ProjectUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ProjectUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `ProjectUser` mutation. */
export type DeleteProjectUserPayloadProjectUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};

/** All input for the `deletePropertyByDescription` mutation. */
export type DeletePropertyByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deletePropertyByHint` mutation. */
export type DeletePropertyByHintInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  hint: Scalars['String']['input'];
};

/** All input for the `deletePropertyByNodeId` mutation. */
export type DeletePropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Property` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePropertyBySlug` mutation. */
export type DeletePropertyBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** All input for the `deleteProperty` mutation. */
export type DeletePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Property` mutation. */
export type DeletePropertyPayload = {
  __typename?: 'DeletePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Datatype` that is related to this `Property`. */
  datatype?: Maybe<Datatype>;
  deletedPropertyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Kind` that is related to this `Property`. */
  kind?: Maybe<Kind>;
  /** The `Property` that was deleted by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Property` mutation. */
export type DeletePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the `deleteRoleByName` mutation. */
export type DeleteRoleByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteRoleByNodeId` mutation. */
export type DeleteRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRole` mutation. */
export type DeleteRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Role` mutation. */
export type DeleteRolePayload = {
  __typename?: 'DeleteRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRoleNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Role` that is related to this `Role`. */
  parentRole?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our delete `Role` mutation. */
export type DeleteRolePayloadRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `deleteRoleUserByNodeId` mutation. */
export type DeleteRoleUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoleUser` mutation. */
export type DeleteRoleUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** All input for the `deleteRoleUserOrganizationByNodeId` mutation. */
export type DeleteRoleUserOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleUserOrganization` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteRoleUserOrganization` mutation. */
export type DeleteRoleUserOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `RoleUserOrganization` mutation. */
export type DeleteRoleUserOrganizationPayload = {
  __typename?: 'DeleteRoleUserOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRoleUserOrganizationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `RoleUserOrganization`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUserOrganization`. */
  role?: Maybe<Role>;
  /** The `RoleUserOrganization` that was deleted by this mutation. */
  roleUserOrganization?: Maybe<RoleUserOrganization>;
  /** An edge for our `RoleUserOrganization`. May be used by Relay 1. */
  roleUserOrganizationEdge?: Maybe<RoleUserOrganizationsEdge>;
  /** Reads a single `User` that is related to this `RoleUserOrganization`. */
  user?: Maybe<User>;
};


/** The output of our delete `RoleUserOrganization` mutation. */
export type DeleteRoleUserOrganizationPayloadRoleUserOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** The output of our delete `RoleUser` mutation. */
export type DeleteRoleUserPayload = {
  __typename?: 'DeleteRoleUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRoleUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUser`. */
  role?: Maybe<Role>;
  /** The `RoleUser` that was deleted by this mutation. */
  roleUser?: Maybe<RoleUser>;
  /** An edge for our `RoleUser`. May be used by Relay 1. */
  roleUserEdge?: Maybe<RoleUsersEdge>;
  /** Reads a single `User` that is related to this `RoleUser`. */
  user?: Maybe<User>;
};


/** The output of our delete `RoleUser` mutation. */
export type DeleteRoleUserPayloadRoleUserEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};

/** All input for the `deleteSchedulerByNodeId` mutation. */
export type DeleteSchedulerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSchedulerFieldByNodeId` mutation. */
export type DeleteSchedulerFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SchedulerField` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSchedulerField` mutation. */
export type DeleteSchedulerFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `SchedulerField` mutation. */
export type DeleteSchedulerFieldPayload = {
  __typename?: 'DeleteSchedulerFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSchedulerFieldNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Field` that is related to this `SchedulerField`. */
  field?: Maybe<Field>;
  /** Reads a single `Form` that is related to this `SchedulerField`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `SchedulerField`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SchedulerField` that was deleted by this mutation. */
  schedulerField?: Maybe<SchedulerField>;
  /** An edge for our `SchedulerField`. May be used by Relay 1. */
  schedulerFieldEdge?: Maybe<SchedulerFieldsEdge>;
};


/** The output of our delete `SchedulerField` mutation. */
export type DeleteSchedulerFieldPayloadSchedulerFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** All input for the `deleteScheduler` mutation. */
export type DeleteSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayload = {
  __typename?: 'DeleteSchedulerPayload';
  /** Reads a single `Admin` that is related to this `Scheduler`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSchedulerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `FillupForm` that is related to this `Scheduler`. */
  fillupform?: Maybe<FillupForm>;
  /** Reads a single `Form` that is related to this `Scheduler`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `Scheduler`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Reads a single `Group` that is related to this `Scheduler`. */
  group?: Maybe<Group>;
  /** Reads a single `Organization` that is related to this `Scheduler`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Scheduler` that was deleted by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
  /** Reads a single `SchedulerField` that is related to this `Scheduler`. */
  schedulerFields?: Maybe<SchedulerField>;
  /** Reads a single `Team` that is related to this `Scheduler`. */
  team?: Maybe<Team>;
  /** Reads a single `User` that is related to this `Scheduler`. */
  user?: Maybe<User>;
};


/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayloadSchedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `deleteSentMailByNodeId` mutation. */
export type DeleteSentMailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SentMail` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSentMail` mutation. */
export type DeleteSentMailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `SentMail` mutation. */
export type DeleteSentMailPayload = {
  __typename?: 'DeleteSentMailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSentMailNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SentMail` that was deleted by this mutation. */
  sentMail?: Maybe<SentMail>;
  /** An edge for our `SentMail`. May be used by Relay 1. */
  sentMailEdge?: Maybe<SentMailEdge>;
};


/** The output of our delete `SentMail` mutation. */
export type DeleteSentMailPayloadSentMailEdgeArgs = {
  orderBy?: InputMaybe<Array<SentMailOrderBy>>;
};

/** All input for the `deleteSessionByNodeId` mutation. */
export type DeleteSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Session` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSession` mutation. */
export type DeleteSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** The output of our delete `Session` mutation. */
export type DeleteSessionPayload = {
  __typename?: 'DeleteSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSessionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Session` that was deleted by this mutation. */
  session?: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<SessionsEdge>;
};


/** The output of our delete `Session` mutation. */
export type DeleteSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `deleteSettingByDescription` mutation. */
export type DeleteSettingByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteSettingByNodeId` mutation. */
export type DeleteSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSettingGroupByDescription` mutation. */
export type DeleteSettingGroupByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
};

/** All input for the `deleteSettingGroupByNodeId` mutation. */
export type DeleteSettingGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SettingGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSettingGroup` mutation. */
export type DeleteSettingGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `SettingGroup` mutation. */
export type DeleteSettingGroupPayload = {
  __typename?: 'DeleteSettingGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSettingGroupNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SettingGroup` that was deleted by this mutation. */
  settingGroup?: Maybe<SettingGroup>;
  /** An edge for our `SettingGroup`. May be used by Relay 1. */
  settingGroupEdge?: Maybe<SettingGroupsEdge>;
};


/** The output of our delete `SettingGroup` mutation. */
export type DeleteSettingGroupPayloadSettingGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingGroupsOrderBy>>;
};

/** All input for the `deleteSetting` mutation. */
export type DeleteSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayload = {
  __typename?: 'DeleteSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSettingNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `SettingGroup` that is related to this `Setting`. */
  group?: Maybe<SettingGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<Setting>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayloadSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `deleteSubscriptionByNodeId` mutation. */
export type DeleteSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Subscription` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSubscription` mutation. */
export type DeleteSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteSubscriptionItemByNodeId` mutation. */
export type DeleteSubscriptionItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SubscriptionItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSubscriptionItemBySubscriptionIdAndStripePlan` mutation. */
export type DeleteSubscriptionItemBySubscriptionIdAndStripePlanInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  stripePlan: Scalars['String']['input'];
  subscriptionId: Scalars['BigInt']['input'];
};

/** All input for the `deleteSubscriptionItem` mutation. */
export type DeleteSubscriptionItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `SubscriptionItem` mutation. */
export type DeleteSubscriptionItemPayload = {
  __typename?: 'DeleteSubscriptionItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSubscriptionItemNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SubscriptionItem` that was deleted by this mutation. */
  subscriptionItem?: Maybe<SubscriptionItem>;
  /** An edge for our `SubscriptionItem`. May be used by Relay 1. */
  subscriptionItemEdge?: Maybe<SubscriptionItemsEdge>;
};


/** The output of our delete `SubscriptionItem` mutation. */
export type DeleteSubscriptionItemPayloadSubscriptionItemEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionItemsOrderBy>>;
};

/** The output of our delete `Subscription` mutation. */
export type DeleteSubscriptionPayload = {
  __typename?: 'DeleteSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSubscriptionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Subscription` that was deleted by this mutation. */
  subscription?: Maybe<Subscription>;
  /** An edge for our `Subscription`. May be used by Relay 1. */
  subscriptionEdge?: Maybe<SubscriptionsEdge>;
};


/** The output of our delete `Subscription` mutation. */
export type DeleteSubscriptionPayloadSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};

/** All input for the `deleteSystemEventByNodeId` mutation. */
export type DeleteSystemEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemEvent` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSystemEvent` mutation. */
export type DeleteSystemEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `SystemEvent` mutation. */
export type DeleteSystemEventPayload = {
  __typename?: 'DeleteSystemEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSystemEventNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemEvent` that was deleted by this mutation. */
  systemEvent?: Maybe<SystemEvent>;
  /** An edge for our `SystemEvent`. May be used by Relay 1. */
  systemEventEdge?: Maybe<SystemEventsEdge>;
};


/** The output of our delete `SystemEvent` mutation. */
export type DeleteSystemEventPayloadSystemEventEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemEventsOrderBy>>;
};

/** All input for the `deleteTeamByNodeId` mutation. */
export type DeleteTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Team` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTeam` mutation. */
export type DeleteTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Team` mutation. */
export type DeleteTeamPayload = {
  __typename?: 'DeleteTeamPayload';
  /** Reads a single `Admin` that is related to this `Team`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTeamNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Team`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Team` that was deleted by this mutation. */
  team?: Maybe<Team>;
  /** An edge for our `Team`. May be used by Relay 1. */
  teamEdge?: Maybe<TeamsEdge>;
};


/** The output of our delete `Team` mutation. */
export type DeleteTeamPayloadTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};

/** All input for the `deleteTelescopeEntryByNodeId` mutation. */
export type DeleteTelescopeEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TelescopeEntry` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTelescopeEntryByUuid` mutation. */
export type DeleteTelescopeEntryByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** All input for the `deleteTelescopeEntry` mutation. */
export type DeleteTelescopeEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sequence: Scalars['BigInt']['input'];
};

/** The output of our delete `TelescopeEntry` mutation. */
export type DeleteTelescopeEntryPayload = {
  __typename?: 'DeleteTelescopeEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTelescopeEntryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TelescopeEntry` that was deleted by this mutation. */
  telescopeEntry?: Maybe<TelescopeEntry>;
  /** An edge for our `TelescopeEntry`. May be used by Relay 1. */
  telescopeEntryEdge?: Maybe<TelescopeEntriesEdge>;
};


/** The output of our delete `TelescopeEntry` mutation. */
export type DeleteTelescopeEntryPayloadTelescopeEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<TelescopeEntriesOrderBy>>;
};

/** All input for the `deleteToolByNodeId` mutation. */
export type DeleteToolByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Tool` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTool` mutation. */
export type DeleteToolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Tool` mutation. */
export type DeleteToolPayload = {
  __typename?: 'DeleteToolPayload';
  /** Reads a single `Admin` that is related to this `Tool`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedToolNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Metric` that is related to this `Tool`. */
  metric?: Maybe<Metric>;
  /** Reads a single `Organization` that is related to this `Tool`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tool` that was deleted by this mutation. */
  tool?: Maybe<Tool>;
  /** An edge for our `Tool`. May be used by Relay 1. */
  toolEdge?: Maybe<ToolsEdge>;
  /** Reads a single `Tooltype` that is related to this `Tool`. */
  tooltype?: Maybe<Tooltype>;
};


/** The output of our delete `Tool` mutation. */
export type DeleteToolPayloadToolEdgeArgs = {
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** All input for the `deleteTooltypeByNodeId` mutation. */
export type DeleteTooltypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Tooltype` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTooltype` mutation. */
export type DeleteTooltypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `Tooltype` mutation. */
export type DeleteTooltypePayload = {
  __typename?: 'DeleteTooltypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTooltypeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tooltype` that was deleted by this mutation. */
  tooltype?: Maybe<Tooltype>;
  /** An edge for our `Tooltype`. May be used by Relay 1. */
  tooltypeEdge?: Maybe<TooltypesEdge>;
};


/** The output of our delete `Tooltype` mutation. */
export type DeleteTooltypePayloadTooltypeEdgeArgs = {
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};

/** All input for the `deleteUserByFacebookId` mutation. */
export type DeleteUserByFacebookIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  facebookId: Scalars['String']['input'];
};

/** All input for the `deleteUserByGoogleId` mutation. */
export type DeleteUserByGoogleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  googleId: Scalars['String']['input'];
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** All input for the `deleteUserInviteByNodeId` mutation. */
export type DeleteUserInviteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserInvite` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserInviteByToken` mutation. */
export type DeleteUserInviteByTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};

/** All input for the `deleteUserInvite` mutation. */
export type DeleteUserInviteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `UserInvite` mutation. */
export type DeleteUserInvitePayload = {
  __typename?: 'DeleteUserInvitePayload';
  /** Reads a single `User` that is related to this `UserInvite`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserInviteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `UserInvite`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `UserInvite`. */
  role?: Maybe<Role>;
  /** Reads a single `Team` that is related to this `UserInvite`. */
  team?: Maybe<Team>;
  /** The `UserInvite` that was deleted by this mutation. */
  userInvite?: Maybe<UserInvite>;
  /** An edge for our `UserInvite`. May be used by Relay 1. */
  userInviteEdge?: Maybe<UserInvitesEdge>;
};


/** The output of our delete `UserInvite` mutation. */
export type DeleteUserInvitePayloadUserInviteEdgeArgs = {
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `User`. */
  parent?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUserSettingByNodeId` mutation. */
export type DeleteUserSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserSetting` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserSetting` mutation. */
export type DeleteUserSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `UserSetting` mutation. */
export type DeleteUserSettingPayload = {
  __typename?: 'DeleteUserSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserSettingNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  setting?: Maybe<Setting>;
  /** Reads a single `User` that is related to this `UserSetting`. */
  user?: Maybe<User>;
  /** The `UserSetting` that was deleted by this mutation. */
  userSetting?: Maybe<UserSetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<UserSettingsEdge>;
};


/** The output of our delete `UserSetting` mutation. */
export type DeleteUserSettingPayloadUserSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};

/** All input for the `deleteVerificationTokenByNodeId` mutation. */
export type DeleteVerificationTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VerificationToken` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteVerificationToken` mutation. */
export type DeleteVerificationTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `VerificationToken` mutation. */
export type DeleteVerificationTokenPayload = {
  __typename?: 'DeleteVerificationTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVerificationTokenNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `VerificationToken`. */
  user?: Maybe<User>;
  /** The `VerificationToken` that was deleted by this mutation. */
  verificationToken?: Maybe<VerificationToken>;
  /** An edge for our `VerificationToken`. May be used by Relay 1. */
  verificationTokenEdge?: Maybe<VerificationTokensEdge>;
  /** Reads a single `VerificationTokenType` that is related to this `VerificationToken`. */
  verificationTokenType?: Maybe<VerificationTokenType>;
};


/** The output of our delete `VerificationToken` mutation. */
export type DeleteVerificationTokenPayloadVerificationTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** All input for the `deleteVerificationTokenTypeByNodeId` mutation. */
export type DeleteVerificationTokenTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VerificationTokenType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteVerificationTokenType` mutation. */
export type DeleteVerificationTokenTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `VerificationTokenType` mutation. */
export type DeleteVerificationTokenTypePayload = {
  __typename?: 'DeleteVerificationTokenTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVerificationTokenTypeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VerificationTokenType` that was deleted by this mutation. */
  verificationTokenType?: Maybe<VerificationTokenType>;
  /** An edge for our `VerificationTokenType`. May be used by Relay 1. */
  verificationTokenTypeEdge?: Maybe<VerificationTokenTypesEdge>;
};


/** The output of our delete `VerificationTokenType` mutation. */
export type DeleteVerificationTokenTypePayloadVerificationTokenTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokenTypesOrderBy>>;
};

/** All input for the `deleteWebsocketsStatisticsEntryByNodeId` mutation. */
export type DeleteWebsocketsStatisticsEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WebsocketsStatisticsEntry` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteWebsocketsStatisticsEntry` mutation. */
export type DeleteWebsocketsStatisticsEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `WebsocketsStatisticsEntry` mutation. */
export type DeleteWebsocketsStatisticsEntryPayload = {
  __typename?: 'DeleteWebsocketsStatisticsEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedWebsocketsStatisticsEntryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebsocketsStatisticsEntry` that was deleted by this mutation. */
  websocketsStatisticsEntry?: Maybe<WebsocketsStatisticsEntry>;
  /** An edge for our `WebsocketsStatisticsEntry`. May be used by Relay 1. */
  websocketsStatisticsEntryEdge?: Maybe<WebsocketsStatisticsEntriesEdge>;
};


/** The output of our delete `WebsocketsStatisticsEntry` mutation. */
export type DeleteWebsocketsStatisticsEntryPayloadWebsocketsStatisticsEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsocketsStatisticsEntriesOrderBy>>;
};

/** All input for the `deleteWorkTypeByNodeId` mutation. */
export type DeleteWorkTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WorkType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteWorkType` mutation. */
export type DeleteWorkTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
};

/** The output of our delete `WorkType` mutation. */
export type DeleteWorkTypePayload = {
  __typename?: 'DeleteWorkTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedWorkTypeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `WorkType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WorkType` that was deleted by this mutation. */
  workType?: Maybe<WorkType>;
  /** An edge for our `WorkType`. May be used by Relay 1. */
  workTypeEdge?: Maybe<WorkTypesEdge>;
};


/** The output of our delete `WorkType` mutation. */
export type DeleteWorkTypePayloadWorkTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkTypesOrderBy>>;
};

export type Equipment = Node & {
  __typename?: 'Equipment';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads a single `EquipmentType` that is related to this `Equipment`. */
  equipmentType?: Maybe<EquipmentType>;
  equipmentTypeId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Issuance`. */
  issuances: IssuancesConnection;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Equipment`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  photo?: Maybe<Scalars['String']['output']>;
  preparedBy: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Equipment`. */
  userByPreparedBy?: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  usersByIssuanceEquipmentIdAndUserId: EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyConnection;
};


export type EquipmentIssuancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IssuanceCondition>;
  filter?: InputMaybe<IssuanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};


export type EquipmentUsersByIssuanceEquipmentIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `Equipment` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type EquipmentCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `equipmentTypeId` field. */
  equipmentTypeId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `photo` field. */
  photo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `preparedBy` field. */
  preparedBy?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Equipment` values. */
export type EquipmentConnection = {
  __typename?: 'EquipmentConnection';
  /** A list of edges which contains the `Equipment` and cursor to aid in pagination. */
  edges: Array<EquipmentEdge>;
  /** A list of `Equipment` objects. */
  nodes: Array<Equipment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Equipment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Equipment` edge in the connection. */
export type EquipmentEdge = {
  __typename?: 'EquipmentEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Equipment` at the end of the edge. */
  node: Equipment;
};

/** A filter to be used against `Equipment` object types. All fields are combined with a logical ‘and.’ */
export type EquipmentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EquipmentFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `equipmentTypeId` field. */
  equipmentTypeId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EquipmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EquipmentFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `photo` field. */
  photo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `preparedBy` field. */
  preparedBy?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Equipment` */
export type EquipmentInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  equipmentTypeId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  photo?: InputMaybe<Scalars['String']['input']>;
  preparedBy: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `Equipment`. */
export enum EquipmentOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EquipmentTypeIdAsc = 'EQUIPMENT_TYPE_ID_ASC',
  EquipmentTypeIdDesc = 'EQUIPMENT_TYPE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PhotoAsc = 'PHOTO_ASC',
  PhotoDesc = 'PHOTO_DESC',
  PreparedByAsc = 'PREPARED_BY_ASC',
  PreparedByDesc = 'PREPARED_BY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `Equipment`. Fields that are set will be updated. */
export type EquipmentPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  equipmentTypeId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  photo?: InputMaybe<Scalars['String']['input']>;
  preparedBy?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type EquipmentType = Node & {
  __typename?: 'EquipmentType';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `EquipmentType`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByEquipmentEquipmentTypeIdAndOrganizationId: EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByEquipmentEquipmentTypeIdAndPreparedBy: EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyConnection;
};


export type EquipmentTypeEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};


export type EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `EquipmentType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EquipmentTypeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `EquipmentType` object types. All fields are combined with a logical ‘and.’ */
export type EquipmentTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EquipmentTypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EquipmentTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EquipmentTypeFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `EquipmentType` */
export type EquipmentTypeInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Organization` values, with data from `Equipment`. */
export type EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Equipment`. */
export type EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Equipment`. */
export type EquipmentTypeOrganizationsByEquipmentEquipmentTypeIdAndOrganizationIdManyToManyEdgeEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** Represents an update to a `EquipmentType`. Fields that are set will be updated. */
export type EquipmentTypePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `User` values, with data from `Equipment`. */
export type EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyConnection = {
  __typename?: 'EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Equipment`. */
export type EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyEdge = {
  __typename?: 'EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipmentByPreparedBy: EquipmentConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Equipment`. */
export type EquipmentTypeUsersByEquipmentEquipmentTypeIdAndPreparedByManyToManyEdgeEquipmentByPreparedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** A connection to a list of `EquipmentType` values. */
export type EquipmentTypesConnection = {
  __typename?: 'EquipmentTypesConnection';
  /** A list of edges which contains the `EquipmentType` and cursor to aid in pagination. */
  edges: Array<EquipmentTypesEdge>;
  /** A list of `EquipmentType` objects. */
  nodes: Array<EquipmentType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EquipmentType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EquipmentType` edge in the connection. */
export type EquipmentTypesEdge = {
  __typename?: 'EquipmentTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EquipmentType` at the end of the edge. */
  node: EquipmentType;
};

/** Methods to use when ordering `EquipmentType`. */
export enum EquipmentTypesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `User` values, with data from `Issuance`. */
export type EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyConnection = {
  __typename?: 'EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Issuance`, and the cursor to aid in pagination. */
  edges: Array<EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Issuance`. */
export type EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyEdge = {
  __typename?: 'EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Issuance`. */
  issuances: IssuancesConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Issuance`. */
export type EquipmentUsersByIssuanceEquipmentIdAndUserIdManyToManyEdgeIssuancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IssuanceCondition>;
  filter?: InputMaybe<IssuanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};

export type ErrorReport = Node & {
  __typename?: 'ErrorReport';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  data: Scalars['String']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `ErrorReport` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ErrorReportCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `ErrorReport` object types. All fields are combined with a logical ‘and.’ */
export type ErrorReportFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ErrorReportFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ErrorReportFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ErrorReportFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `ErrorReport` */
export type ErrorReportInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  data: Scalars['String']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `ErrorReport`. Fields that are set will be updated. */
export type ErrorReportPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  data?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `ErrorReport` values. */
export type ErrorReportsConnection = {
  __typename?: 'ErrorReportsConnection';
  /** A list of edges which contains the `ErrorReport` and cursor to aid in pagination. */
  edges: Array<ErrorReportsEdge>;
  /** A list of `ErrorReport` objects. */
  nodes: Array<ErrorReport>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ErrorReport` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ErrorReport` edge in the connection. */
export type ErrorReportsEdge = {
  __typename?: 'ErrorReportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ErrorReport` at the end of the edge. */
  node: ErrorReport;
};

/** Methods to use when ordering `ErrorReport`. */
export enum ErrorReportsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Event = Node & {
  __typename?: 'Event';
  /** Reads and enables pagination through a set of `ComponentEvent`. */
  componentEvents: ComponentEventsConnection;
  /** Reads and enables pagination through a set of `Component`. */
  componentsByComponentEventEventIdAndComponentId: EventComponentsByComponentEventEventIdAndComponentIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsByFieldActionEventIdAndFieldId: EventFieldsByFieldActionEventIdAndFieldIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByFieldActionEventIdAndPropertyId: EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyConnection;
  slug: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type EventComponentEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentEventCondition>;
  filter?: InputMaybe<ComponentEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};


export type EventComponentsByComponentEventEventIdAndComponentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentCondition>;
  filter?: InputMaybe<ComponentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};


export type EventFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};


export type EventFieldsByFieldActionEventIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type EventPropertiesByFieldActionEventIdAndPropertyIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** A connection to a list of `Component` values, with data from `ComponentEvent`. */
export type EventComponentsByComponentEventEventIdAndComponentIdManyToManyConnection = {
  __typename?: 'EventComponentsByComponentEventEventIdAndComponentIdManyToManyConnection';
  /** A list of edges which contains the `Component`, info from the `ComponentEvent`, and the cursor to aid in pagination. */
  edges: Array<EventComponentsByComponentEventEventIdAndComponentIdManyToManyEdge>;
  /** A list of `Component` objects. */
  nodes: Array<Component>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Component` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Component` edge in the connection, with data from `ComponentEvent`. */
export type EventComponentsByComponentEventEventIdAndComponentIdManyToManyEdge = {
  __typename?: 'EventComponentsByComponentEventEventIdAndComponentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ComponentEvent`. */
  componentEvents: ComponentEventsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Component` at the end of the edge. */
  node: Component;
};


/** A `Component` edge in the connection, with data from `ComponentEvent`. */
export type EventComponentsByComponentEventEventIdAndComponentIdManyToManyEdgeComponentEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentEventCondition>;
  filter?: InputMaybe<ComponentEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Field` values, with data from `FieldAction`. */
export type EventFieldsByFieldActionEventIdAndFieldIdManyToManyConnection = {
  __typename?: 'EventFieldsByFieldActionEventIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<EventFieldsByFieldActionEventIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `FieldAction`. */
export type EventFieldsByFieldActionEventIdAndFieldIdManyToManyEdge = {
  __typename?: 'EventFieldsByFieldActionEventIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Field` at the end of the edge. */
  node: Field;
};


/** A `Field` edge in the connection, with data from `FieldAction`. */
export type EventFieldsByFieldActionEventIdAndFieldIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  slug: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Property` values, with data from `FieldAction`. */
export type EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyConnection = {
  __typename?: 'EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyConnection';
  /** A list of edges which contains the `Property`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Property>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection, with data from `FieldAction`. */
export type EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyEdge = {
  __typename?: 'EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Property` at the end of the edge. */
  node: Property;
};


/** A `Property` edge in the connection, with data from `FieldAction`. */
export type EventPropertiesByFieldActionEventIdAndPropertyIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export enum EventsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type FailedJob = Node & {
  __typename?: 'FailedJob';
  connection: Scalars['String']['output'];
  exception: Scalars['String']['output'];
  failedAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  payload: Scalars['String']['output'];
  queue: Scalars['String']['output'];
  uuid: Scalars['String']['output'];
};

/**
 * A condition to be used against `FailedJob` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FailedJobCondition = {
  /** Checks for equality with the object’s `connection` field. */
  connection?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `exception` field. */
  exception?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `failedAt` field. */
  failedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `payload` field. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `queue` field. */
  queue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FailedJob` object types. All fields are combined with a logical ‘and.’ */
export type FailedJobFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FailedJobFilter>>;
  /** Filter by the object’s `connection` field. */
  connection?: InputMaybe<StringFilter>;
  /** Filter by the object’s `exception` field. */
  exception?: InputMaybe<StringFilter>;
  /** Filter by the object’s `failedAt` field. */
  failedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FailedJobFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FailedJobFilter>>;
  /** Filter by the object’s `payload` field. */
  payload?: InputMaybe<StringFilter>;
  /** Filter by the object’s `queue` field. */
  queue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `FailedJob` */
export type FailedJobInput = {
  connection: Scalars['String']['input'];
  exception: Scalars['String']['input'];
  failedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  payload: Scalars['String']['input'];
  queue: Scalars['String']['input'];
  uuid: Scalars['String']['input'];
};

/** Represents an update to a `FailedJob`. Fields that are set will be updated. */
export type FailedJobPatch = {
  connection?: InputMaybe<Scalars['String']['input']>;
  exception?: InputMaybe<Scalars['String']['input']>;
  failedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  payload?: InputMaybe<Scalars['String']['input']>;
  queue?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `FailedJob` values. */
export type FailedJobsConnection = {
  __typename?: 'FailedJobsConnection';
  /** A list of edges which contains the `FailedJob` and cursor to aid in pagination. */
  edges: Array<FailedJobsEdge>;
  /** A list of `FailedJob` objects. */
  nodes: Array<FailedJob>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FailedJob` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FailedJob` edge in the connection. */
export type FailedJobsEdge = {
  __typename?: 'FailedJobsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FailedJob` at the end of the edge. */
  node: FailedJob;
};

/** Methods to use when ordering `FailedJob`. */
export enum FailedJobsOrderBy {
  ConnectionAsc = 'CONNECTION_ASC',
  ConnectionDesc = 'CONNECTION_DESC',
  ExceptionAsc = 'EXCEPTION_ASC',
  ExceptionDesc = 'EXCEPTION_DESC',
  FailedAtAsc = 'FAILED_AT_ASC',
  FailedAtDesc = 'FAILED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PayloadAsc = 'PAYLOAD_ASC',
  PayloadDesc = 'PAYLOAD_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QueueAsc = 'QUEUE_ASC',
  QueueDesc = 'QUEUE_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Field = Node & {
  __typename?: 'Field';
  /** Reads a single `Component` that is related to this `Field`. */
  component?: Maybe<Component>;
  componentId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByFieldActionFieldIdAndEventId: FieldEventsByFieldActionFieldIdAndEventIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** Reads and enables pagination through a set of `FieldProperty`. */
  fieldProperties: FieldPropertiesConnection;
  /** Reads and enables pagination through a set of `FieldTranslation`. */
  fieldTranslations: FieldTranslationsConnection;
  /** Reads and enables pagination through a set of `FillupFormField`. */
  fillupFormFields: FillupFormFieldsConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsByFillupFormFieldFieldIdAndFillupFormId: FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyConnection;
  /** Reads a single `Form` that is related to this `Field`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerFieldFieldIdAndFormTemplateId: FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerFieldFieldIdAndFormId: FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Language`. */
  languagesByFieldTranslationFieldIdAndLanguageId: FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByFieldActionFieldIdAndPropertyId: FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByFieldPropertyFieldIdAndPropertyId: FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
  sortOrder: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
};


export type FieldEventsByFieldActionFieldIdAndEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type FieldFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};


export type FieldFieldPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldPropertyCondition>;
  filter?: InputMaybe<FieldPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};


export type FieldFieldTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldTranslationCondition>;
  filter?: InputMaybe<FieldTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};


export type FieldFillupFormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormFieldCondition>;
  filter?: InputMaybe<FillupFormFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};


export type FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type FieldFormsBySchedulerFieldFieldIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type FieldLanguagesByFieldTranslationFieldIdAndLanguageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LanguageCondition>;
  filter?: InputMaybe<LanguageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanguagesOrderBy>>;
};


export type FieldPropertiesByFieldActionFieldIdAndPropertyIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


export type FieldPropertiesByFieldPropertyFieldIdAndPropertyIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


export type FieldSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

export type FieldAction = Node & {
  __typename?: 'FieldAction';
  affectedFieldUuid: Scalars['String']['output'];
  affectedPropertyUuid: Scalars['String']['output'];
  answer?: Maybe<Scalars['String']['output']>;
  condition?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Event` that is related to this `FieldAction`. */
  event?: Maybe<Event>;
  eventId: Scalars['BigInt']['output'];
  eventName: Scalars['String']['output'];
  /** Reads a single `Field` that is related to this `FieldAction`. */
  field?: Maybe<Field>;
  fieldId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Property` that is related to this `FieldAction`. */
  property?: Maybe<Property>;
  propertyId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `FieldAction` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FieldActionCondition = {
  /** Checks for equality with the object’s `affectedFieldUuid` field. */
  affectedFieldUuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `affectedPropertyUuid` field. */
  affectedPropertyUuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `answer` field. */
  answer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `condition` field. */
  condition?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `eventName` field. */
  eventName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FieldAction` object types. All fields are combined with a logical ‘and.’ */
export type FieldActionFilter = {
  /** Filter by the object’s `affectedFieldUuid` field. */
  affectedFieldUuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `affectedPropertyUuid` field. */
  affectedPropertyUuid?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FieldActionFilter>>;
  /** Filter by the object’s `answer` field. */
  answer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `condition` field. */
  condition?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `eventName` field. */
  eventName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FieldActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FieldActionFilter>>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `FieldAction` */
export type FieldActionInput = {
  affectedFieldUuid: Scalars['String']['input'];
  affectedPropertyUuid: Scalars['String']['input'];
  answer?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  eventId: Scalars['BigInt']['input'];
  eventName: Scalars['String']['input'];
  fieldId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `FieldAction`. Fields that are set will be updated. */
export type FieldActionPatch = {
  affectedFieldUuid?: InputMaybe<Scalars['String']['input']>;
  affectedPropertyUuid?: InputMaybe<Scalars['String']['input']>;
  answer?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  eventId?: InputMaybe<Scalars['BigInt']['input']>;
  eventName?: InputMaybe<Scalars['String']['input']>;
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `FieldAction` values. */
export type FieldActionsConnection = {
  __typename?: 'FieldActionsConnection';
  /** A list of edges which contains the `FieldAction` and cursor to aid in pagination. */
  edges: Array<FieldActionsEdge>;
  /** A list of `FieldAction` objects. */
  nodes: Array<FieldAction>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FieldAction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FieldAction` edge in the connection. */
export type FieldActionsEdge = {
  __typename?: 'FieldActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FieldAction` at the end of the edge. */
  node: FieldAction;
};

/** Methods to use when ordering `FieldAction`. */
export enum FieldActionsOrderBy {
  AffectedFieldUuidAsc = 'AFFECTED_FIELD_UUID_ASC',
  AffectedFieldUuidDesc = 'AFFECTED_FIELD_UUID_DESC',
  AffectedPropertyUuidAsc = 'AFFECTED_PROPERTY_UUID_ASC',
  AffectedPropertyUuidDesc = 'AFFECTED_PROPERTY_UUID_DESC',
  AnswerAsc = 'ANSWER_ASC',
  AnswerDesc = 'ANSWER_DESC',
  ConditionAsc = 'CONDITION_ASC',
  ConditionDesc = 'CONDITION_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  EventIdAsc = 'EVENT_ID_ASC',
  EventIdDesc = 'EVENT_ID_DESC',
  EventNameAsc = 'EVENT_NAME_ASC',
  EventNameDesc = 'EVENT_NAME_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

/** A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FieldCondition = {
  /** Checks for equality with the object’s `componentId` field. */
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Event` values, with data from `FieldAction`. */
export type FieldEventsByFieldActionFieldIdAndEventIdManyToManyConnection = {
  __typename?: 'FieldEventsByFieldActionFieldIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<FieldEventsByFieldActionFieldIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `FieldAction`. */
export type FieldEventsByFieldActionFieldIdAndEventIdManyToManyEdge = {
  __typename?: 'FieldEventsByFieldActionFieldIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `FieldAction`. */
export type FieldEventsByFieldActionFieldIdAndEventIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A connection to a list of `FillupForm` values, with data from `FillupFormField`. */
export type FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyConnection = {
  __typename?: 'FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `FillupFormField`, and the cursor to aid in pagination. */
  edges: Array<FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `FillupFormField`. */
export type FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyEdge = {
  __typename?: 'FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupFormField`. */
  fillupFormFields: FillupFormFieldsConnection;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
};


/** A `FillupForm` edge in the connection, with data from `FillupFormField`. */
export type FieldFillupFormsByFillupFormFieldFieldIdAndFillupFormIdManyToManyEdgeFillupFormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormFieldCondition>;
  filter?: InputMaybe<FillupFormFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};

/** A filter to be used against `Field` object types. All fields are combined with a logical ‘and.’ */
export type FieldFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FieldFilter>>;
  /** Filter by the object’s `componentId` field. */
  componentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FieldFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FieldFilter>>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `SchedulerField`. */
export type FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `SchedulerField`. */
export type FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `FormTemplate` edge in the connection, with data from `SchedulerField`. */
export type FieldFormTemplatesBySchedulerFieldFieldIdAndFormTemplateIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `SchedulerField`. */
export type FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyConnection = {
  __typename?: 'FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `SchedulerField`. */
export type FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyEdge = {
  __typename?: 'FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `Form` edge in the connection, with data from `SchedulerField`. */
export type FieldFormsBySchedulerFieldFieldIdAndFormIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** An input for mutations affecting `Field` */
export type FieldInput = {
  componentId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  sortOrder: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** A connection to a list of `Language` values, with data from `FieldTranslation`. */
export type FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyConnection = {
  __typename?: 'FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyConnection';
  /** A list of edges which contains the `Language`, info from the `FieldTranslation`, and the cursor to aid in pagination. */
  edges: Array<FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Language>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Language` edge in the connection, with data from `FieldTranslation`. */
export type FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyEdge = {
  __typename?: 'FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldTranslation`. */
  fieldTranslations: FieldTranslationsConnection;
  /** The `Language` at the end of the edge. */
  node: Language;
};


/** A `Language` edge in the connection, with data from `FieldTranslation`. */
export type FieldLanguagesByFieldTranslationFieldIdAndLanguageIdManyToManyEdgeFieldTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldTranslationCondition>;
  filter?: InputMaybe<FieldTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};

/** Represents an update to a `Field`. Fields that are set will be updated. */
export type FieldPatch = {
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  sortOrder?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Property` values, with data from `FieldAction`. */
export type FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyConnection = {
  __typename?: 'FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyConnection';
  /** A list of edges which contains the `Property`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Property>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection, with data from `FieldAction`. */
export type FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyEdge = {
  __typename?: 'FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Property` at the end of the edge. */
  node: Property;
};


/** A `Property` edge in the connection, with data from `FieldAction`. */
export type FieldPropertiesByFieldActionFieldIdAndPropertyIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A connection to a list of `Property` values, with data from `FieldProperty`. */
export type FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyConnection = {
  __typename?: 'FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyConnection';
  /** A list of edges which contains the `Property`, info from the `FieldProperty`, and the cursor to aid in pagination. */
  edges: Array<FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Property>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection, with data from `FieldProperty`. */
export type FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyEdge = {
  __typename?: 'FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldProperty`. */
  fieldProperties: FieldPropertiesConnection;
  /** The `Property` at the end of the edge. */
  node: Property;
};


/** A `Property` edge in the connection, with data from `FieldProperty`. */
export type FieldPropertiesByFieldPropertyFieldIdAndPropertyIdManyToManyEdgeFieldPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldPropertyCondition>;
  filter?: InputMaybe<FieldPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};

/** A connection to a list of `FieldProperty` values. */
export type FieldPropertiesConnection = {
  __typename?: 'FieldPropertiesConnection';
  /** A list of edges which contains the `FieldProperty` and cursor to aid in pagination. */
  edges: Array<FieldPropertiesEdge>;
  /** A list of `FieldProperty` objects. */
  nodes: Array<FieldProperty>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FieldProperty` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FieldProperty` edge in the connection. */
export type FieldPropertiesEdge = {
  __typename?: 'FieldPropertiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FieldProperty` at the end of the edge. */
  node: FieldProperty;
};

/** Methods to use when ordering `FieldProperty`. */
export enum FieldPropertiesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type FieldProperty = Node & {
  __typename?: 'FieldProperty';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Field` that is related to this `FieldProperty`. */
  field?: Maybe<Field>;
  fieldId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Property` that is related to this `FieldProperty`. */
  property?: Maybe<Property>;
  propertyId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
  value: Scalars['String']['output'];
};

/**
 * A condition to be used against `FieldProperty` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FieldPropertyCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FieldProperty` object types. All fields are combined with a logical ‘and.’ */
export type FieldPropertyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FieldPropertyFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FieldPropertyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FieldPropertyFilter>>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `FieldProperty` */
export type FieldPropertyInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
  value: Scalars['String']['input'];
};

/** Represents an update to a `FieldProperty`. Fields that are set will be updated. */
export type FieldPropertyPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  propertyId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type FieldTranslation = Node & {
  __typename?: 'FieldTranslation';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Field` that is related to this `FieldTranslation`. */
  field?: Maybe<Field>;
  fieldId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  label: Scalars['String']['output'];
  /** Reads a single `Language` that is related to this `FieldTranslation`. */
  language?: Maybe<Language>;
  languageId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FieldTranslation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FieldTranslationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `languageId` field. */
  languageId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FieldTranslation` object types. All fields are combined with a logical ‘and.’ */
export type FieldTranslationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FieldTranslationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Filter by the object’s `languageId` field. */
  languageId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FieldTranslationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FieldTranslationFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FieldTranslation` */
export type FieldTranslationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label: Scalars['String']['input'];
  languageId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FieldTranslation`. Fields that are set will be updated. */
export type FieldTranslationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  languageId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `FieldTranslation` values. */
export type FieldTranslationsConnection = {
  __typename?: 'FieldTranslationsConnection';
  /** A list of edges which contains the `FieldTranslation` and cursor to aid in pagination. */
  edges: Array<FieldTranslationsEdge>;
  /** A list of `FieldTranslation` objects. */
  nodes: Array<FieldTranslation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FieldTranslation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FieldTranslation` edge in the connection. */
export type FieldTranslationsEdge = {
  __typename?: 'FieldTranslationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FieldTranslation` at the end of the edge. */
  node: FieldTranslation;
};

/** Methods to use when ordering `FieldTranslation`. */
export enum FieldTranslationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  LanguageIdAsc = 'LANGUAGE_ID_ASC',
  LanguageIdDesc = 'LANGUAGE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `Field` values. */
export type FieldsConnection = {
  __typename?: 'FieldsConnection';
  /** A list of edges which contains the `Field` and cursor to aid in pagination. */
  edges: Array<FieldsEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection. */
export type FieldsEdge = {
  __typename?: 'FieldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Field` at the end of the edge. */
  node: Field;
};

/** Methods to use when ordering `Field`. */
export enum FieldsOrderBy {
  ComponentIdAsc = 'COMPONENT_ID_ASC',
  ComponentIdDesc = 'COMPONENT_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type FillupForm = Node & {
  __typename?: 'FillupForm';
  /** Reads a single `Admin` that is related to this `FillupForm`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerFillupformIdAndAdminId: FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyConnection;
  approvedAt?: Maybe<Scalars['Datetime']['output']>;
  approvedBy?: Maybe<Scalars['BigInt']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  customFieldValue?: Maybe<Scalars['String']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsByFillupFormFieldFillupFormIdAndFieldId: FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FillupFormField`. */
  fillupFormFields: FillupFormFieldsConnection;
  /** Reads a single `Form` that is related to this `FillupForm`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerFillupformIdAndFormTemplateId: FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerFillupformIdAndFormId: FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyConnection;
  geo: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerFillupformIdAndGroupId: FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  isApproved: Scalars['Int']['output'];
  isDraft?: Maybe<Scalars['Int']['output']>;
  isReadonly: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerFillupformIdAndOrgId: FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsId: FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
  status: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerFillupformIdAndTeamId: FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  user?: Maybe<User>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  userByApprovedBy?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerFillupformIdAndUserId: FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyConnection;
};


export type FillupFormAdminsBySchedulerFillupformIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type FillupFormFillupFormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormFieldCondition>;
  filter?: InputMaybe<FillupFormFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};


export type FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type FillupFormFormsBySchedulerFillupformIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type FillupFormGroupsBySchedulerFillupformIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type FillupFormSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type FillupFormTeamsBySchedulerFillupformIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type FillupFormUsersBySchedulerFillupformIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyConnection = {
  __typename?: 'FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyEdge = {
  __typename?: 'FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FillupFormAdminsBySchedulerFillupformIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/**
 * A condition to be used against `FillupForm` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FillupFormCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `approvedAt` field. */
  approvedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `approvedBy` field. */
  approvedBy?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customFieldValue` field. */
  customFieldValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `geo` field. */
  geo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isApproved` field. */
  isApproved?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isDraft` field. */
  isDraft?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isReadonly` field. */
  isReadonly?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type FillupFormField = Node & {
  __typename?: 'FillupFormField';
  answer: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Field` that is related to this `FillupFormField`. */
  field?: Maybe<Field>;
  fieldId: Scalars['BigInt']['output'];
  /** Reads a single `FillupForm` that is related to this `FillupFormField`. */
  fillupForm?: Maybe<FillupForm>;
  fillupFormId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FillupFormField` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FillupFormFieldCondition = {
  /** Checks for equality with the object’s `answer` field. */
  answer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `fillupFormId` field. */
  fillupFormId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FillupFormField` object types. All fields are combined with a logical ‘and.’ */
export type FillupFormFieldFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FillupFormFieldFilter>>;
  /** Filter by the object’s `answer` field. */
  answer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `fillupFormId` field. */
  fillupFormId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FillupFormFieldFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FillupFormFieldFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FillupFormField` */
export type FillupFormFieldInput = {
  answer: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId: Scalars['BigInt']['input'];
  fillupFormId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FillupFormField`. Fields that are set will be updated. */
export type FillupFormFieldPatch = {
  answer?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  fillupFormId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Field` values, with data from `FillupFormField`. */
export type FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyConnection = {
  __typename?: 'FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `FillupFormField`, and the cursor to aid in pagination. */
  edges: Array<FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `FillupFormField`. */
export type FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyEdge = {
  __typename?: 'FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupFormField`. */
  fillupFormFields: FillupFormFieldsConnection;
  /** The `Field` at the end of the edge. */
  node: Field;
};


/** A `Field` edge in the connection, with data from `FillupFormField`. */
export type FillupFormFieldsByFillupFormFieldFillupFormIdAndFieldIdManyToManyEdgeFillupFormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormFieldCondition>;
  filter?: InputMaybe<FillupFormFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};

/** A connection to a list of `FillupFormField` values. */
export type FillupFormFieldsConnection = {
  __typename?: 'FillupFormFieldsConnection';
  /** A list of edges which contains the `FillupFormField` and cursor to aid in pagination. */
  edges: Array<FillupFormFieldsEdge>;
  /** A list of `FillupFormField` objects. */
  nodes: Array<FillupFormField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupFormField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupFormField` edge in the connection. */
export type FillupFormFieldsEdge = {
  __typename?: 'FillupFormFieldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupFormField` at the end of the edge. */
  node: FillupFormField;
};

/** Methods to use when ordering `FillupFormField`. */
export enum FillupFormFieldsOrderBy {
  AnswerAsc = 'ANSWER_ASC',
  AnswerDesc = 'ANSWER_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  FillupFormIdAsc = 'FILLUP_FORM_ID_ASC',
  FillupFormIdDesc = 'FILLUP_FORM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A filter to be used against `FillupForm` object types. All fields are combined with a logical ‘and.’ */
export type FillupFormFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FillupFormFilter>>;
  /** Filter by the object’s `approvedAt` field. */
  approvedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `approvedBy` field. */
  approvedBy?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customFieldValue` field. */
  customFieldValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `geo` field. */
  geo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isApproved` field. */
  isApproved?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isDraft` field. */
  isDraft?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isReadonly` field. */
  isReadonly?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FillupFormFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FillupFormFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type FillupFormFormTemplatesBySchedulerFillupformIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyConnection = {
  __typename?: 'FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyEdge = {
  __typename?: 'FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type FillupFormFormsBySchedulerFillupformIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyConnection = {
  __typename?: 'FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyEdge = {
  __typename?: 'FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FillupFormGroupsBySchedulerFillupformIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `FillupForm` */
export type FillupFormInput = {
  adminId: Scalars['BigInt']['input'];
  approvedAt?: InputMaybe<Scalars['Datetime']['input']>;
  approvedBy?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  customFieldValue?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId: Scalars['BigInt']['input'];
  geo: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isApproved: Scalars['Int']['input'];
  isDraft?: InputMaybe<Scalars['Int']['input']>;
  isReadonly: Scalars['Int']['input'];
  status: Scalars['Int']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyConnection = {
  __typename?: 'FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyEdge = {
  __typename?: 'FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FillupFormOrganizationsBySchedulerFillupformIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** Represents an update to a `FillupForm`. Fields that are set will be updated. */
export type FillupFormPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  approvedAt?: InputMaybe<Scalars['Datetime']['input']>;
  approvedBy?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  customFieldValue?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  geo?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isApproved?: InputMaybe<Scalars['Int']['input']>;
  isDraft?: InputMaybe<Scalars['Int']['input']>;
  isReadonly?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FillupFormSchedulerFieldsBySchedulerFillupformIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyConnection = {
  __typename?: 'FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyEdge = {
  __typename?: 'FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FillupFormTeamsBySchedulerFillupformIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyConnection = {
  __typename?: 'FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyEdge = {
  __typename?: 'FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type FillupFormUsersBySchedulerFillupformIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FillupForm` values. */
export type FillupFormsConnection = {
  __typename?: 'FillupFormsConnection';
  /** A list of edges which contains the `FillupForm` and cursor to aid in pagination. */
  edges: Array<FillupFormsEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection. */
export type FillupFormsEdge = {
  __typename?: 'FillupFormsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
};

/** Methods to use when ordering `FillupForm`. */
export enum FillupFormsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  ApprovedAtAsc = 'APPROVED_AT_ASC',
  ApprovedAtDesc = 'APPROVED_AT_DESC',
  ApprovedByAsc = 'APPROVED_BY_ASC',
  ApprovedByDesc = 'APPROVED_BY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CustomFieldValueAsc = 'CUSTOM_FIELD_VALUE_ASC',
  CustomFieldValueDesc = 'CUSTOM_FIELD_VALUE_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  GeoAsc = 'GEO_ASC',
  GeoDesc = 'GEO_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsApprovedAsc = 'IS_APPROVED_ASC',
  IsApprovedDesc = 'IS_APPROVED_DESC',
  IsDraftAsc = 'IS_DRAFT_ASC',
  IsDraftDesc = 'IS_DRAFT_DESC',
  IsReadonlyAsc = 'IS_READONLY_ASC',
  IsReadonlyDesc = 'IS_READONLY_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Form = Node & {
  __typename?: 'Form';
  /** Reads a single `Admin` that is related to this `Form`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFillupFormFormIdAndAdminId: FormAdminsByFillupFormFormIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerFormIdAndAdminId: FormAdminsBySchedulerFormIdAndAdminIdManyToManyConnection;
  category?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Component`. */
  componentsByFieldFormIdAndComponentId: FormComponentsByFieldFormIdAndComponentIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `Form`. */
  createdFromTemplate?: Maybe<FormTemplate>;
  createdFromTemplateId?: Maybe<Scalars['BigInt']['output']>;
  customField?: Maybe<Scalars['String']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  emailBody?: Maybe<Scalars['String']['output']>;
  emailSubject?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Field`. */
  fields: FieldsConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsBySchedulerFieldFormIdAndFieldId: FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerFormIdAndFillupformId: FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormOrganization`. */
  formOrganizations: FormOrganizationsConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplates: FormTemplatesConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerFieldFormIdAndFormTemplateId: FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerFormIdAndFormTemplateId: FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormUser`. */
  formUsers: FormUsersConnection;
  gpsCoordinates?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `Form`. */
  group?: Maybe<Group>;
  groupId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerFormIdAndGroupId: FormGroupsBySchedulerFormIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  isDraft: Scalars['Boolean']['output'];
  isLocked: Scalars['Boolean']['output'];
  isSendToOwner: Scalars['Boolean']['output'];
  isShareableToTemplateLibrary: Scalars['Boolean']['output'];
  isSpecial?: Maybe<Scalars['Int']['output']>;
  logo?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByFormOrganizationFormIdAndOrganizationId: FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerFormIdAndOrgId: FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyConnection;
  recipients?: Maybe<Scalars['String']['output']>;
  refno?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerFormIdAndSchedulerFieldsId: FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  sharableLink?: Maybe<Scalars['UUID']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Team` that is related to this `Form`. */
  team?: Maybe<Team>;
  teamId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerFormIdAndTeamId: FormTeamsBySchedulerFormIdAndTeamIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormFormIdAndApprovedBy: FormUsersByFillupFormFormIdAndApprovedByManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormFormIdAndUserId: FormUsersByFillupFormFormIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByFormUserFormIdAndUserId: FormUsersByFormUserFormIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerFormIdAndUserId: FormUsersBySchedulerFormIdAndUserIdManyToManyConnection;
  uuid: Scalars['String']['output'];
};


export type FormAdminsByFillupFormFormIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type FormAdminsBySchedulerFormIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type FormComponentsByFieldFormIdAndComponentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentCondition>;
  filter?: InputMaybe<ComponentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};


export type FormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type FormFieldsBySchedulerFieldFormIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type FormFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type FormFillupFormsBySchedulerFormIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type FormFormOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormOrganizationCondition>;
  filter?: InputMaybe<FormOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};


export type FormFormTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type FormFormTemplatesBySchedulerFormIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type FormFormUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormUserCondition>;
  filter?: InputMaybe<FormUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};


export type FormGroupsBySchedulerFormIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type FormOrganizationsByFormOrganizationFormIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type FormOrganizationsBySchedulerFormIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type FormSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type FormSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type FormTeamsBySchedulerFormIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type FormUsersByFillupFormFormIdAndApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type FormUsersByFillupFormFormIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type FormUsersByFormUserFormIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type FormUsersBySchedulerFormIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `FillupForm`. */
export type FormAdminsByFillupFormFormIdAndAdminIdManyToManyConnection = {
  __typename?: 'FormAdminsByFillupFormFormIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<FormAdminsByFillupFormFormIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type FormAdminsByFillupFormFormIdAndAdminIdManyToManyEdge = {
  __typename?: 'FormAdminsByFillupFormFormIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type FormAdminsByFillupFormFormIdAndAdminIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type FormAdminsBySchedulerFormIdAndAdminIdManyToManyConnection = {
  __typename?: 'FormAdminsBySchedulerFormIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormAdminsBySchedulerFormIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FormAdminsBySchedulerFormIdAndAdminIdManyToManyEdge = {
  __typename?: 'FormAdminsBySchedulerFormIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FormAdminsBySchedulerFormIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Component` values, with data from `Field`. */
export type FormComponentsByFieldFormIdAndComponentIdManyToManyConnection = {
  __typename?: 'FormComponentsByFieldFormIdAndComponentIdManyToManyConnection';
  /** A list of edges which contains the `Component`, info from the `Field`, and the cursor to aid in pagination. */
  edges: Array<FormComponentsByFieldFormIdAndComponentIdManyToManyEdge>;
  /** A list of `Component` objects. */
  nodes: Array<Component>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Component` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Component` edge in the connection, with data from `Field`. */
export type FormComponentsByFieldFormIdAndComponentIdManyToManyEdge = {
  __typename?: 'FormComponentsByFieldFormIdAndComponentIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Field`. */
  fields: FieldsConnection;
  /** The `Component` at the end of the edge. */
  node: Component;
};


/** A `Component` edge in the connection, with data from `Field`. */
export type FormComponentsByFieldFormIdAndComponentIdManyToManyEdgeFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** A condition to be used against `Form` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FormCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `createdFromTemplateId` field. */
  createdFromTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `customField` field. */
  customField?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailBody` field. */
  emailBody?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailSubject` field. */
  emailSubject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gpsCoordinates` field. */
  gpsCoordinates?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isDraft` field. */
  isDraft?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLocked` field. */
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSendToOwner` field. */
  isSendToOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isShareableToTemplateLibrary` field. */
  isShareableToTemplateLibrary?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSpecial` field. */
  isSpecial?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `logo` field. */
  logo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `recipients` field. */
  recipients?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `refno` field. */
  refno?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sharableLink` field. */
  sharableLink?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Field` values, with data from `SchedulerField`. */
export type FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyConnection = {
  __typename?: 'FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `SchedulerField`. */
export type FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyEdge = {
  __typename?: 'FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Field` at the end of the edge. */
  node: Field;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `Field` edge in the connection, with data from `SchedulerField`. */
export type FormFieldsBySchedulerFieldFormIdAndFieldIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyConnection = {
  __typename?: 'FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyEdge = {
  __typename?: 'FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type FormFillupFormsBySchedulerFormIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `Form` object types. All fields are combined with a logical ‘and.’ */
export type FormFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormFilter>>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `createdFromTemplateId` field. */
  createdFromTemplateId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `customField` field. */
  customField?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailBody` field. */
  emailBody?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailSubject` field. */
  emailSubject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gpsCoordinates` field. */
  gpsCoordinates?: InputMaybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isDraft` field. */
  isDraft?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLocked` field. */
  isLocked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSendToOwner` field. */
  isSendToOwner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isShareableToTemplateLibrary` field. */
  isShareableToTemplateLibrary?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSpecial` field. */
  isSpecial?: InputMaybe<IntFilter>;
  /** Filter by the object’s `logo` field. */
  logo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormFilter>>;
  /** Filter by the object’s `recipients` field. */
  recipients?: InputMaybe<StringFilter>;
  /** Filter by the object’s `refno` field. */
  refno?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sharableLink` field. */
  sharableLink?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<StringFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `SchedulerField`. */
export type FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `SchedulerField`. */
export type FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `FormTemplate` edge in the connection, with data from `SchedulerField`. */
export type FormFormTemplatesBySchedulerFieldFormIdAndFormTemplateIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type FormFormTemplatesBySchedulerFormIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type FormGroupsBySchedulerFormIdAndGroupIdManyToManyConnection = {
  __typename?: 'FormGroupsBySchedulerFormIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormGroupsBySchedulerFormIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FormGroupsBySchedulerFormIdAndGroupIdManyToManyEdge = {
  __typename?: 'FormGroupsBySchedulerFormIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FormGroupsBySchedulerFormIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `Form` */
export type FormInput = {
  adminId: Scalars['BigInt']['input'];
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  createdFromTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  customField?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  emailBody?: InputMaybe<Scalars['String']['input']>;
  emailSubject?: InputMaybe<Scalars['String']['input']>;
  gpsCoordinates?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isDraft?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isSendToOwner?: InputMaybe<Scalars['Boolean']['input']>;
  isShareableToTemplateLibrary?: InputMaybe<Scalars['Boolean']['input']>;
  isSpecial?: InputMaybe<Scalars['Int']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  recipients?: InputMaybe<Scalars['String']['input']>;
  refno?: InputMaybe<Scalars['String']['input']>;
  sharableLink?: InputMaybe<Scalars['UUID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['String']['input'];
};

export type FormOrganization = Node & {
  __typename?: 'FormOrganization';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Form` that is related to this `FormOrganization`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `FormOrganization`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FormOrganization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormOrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FormOrganization` object types. All fields are combined with a logical ‘and.’ */
export type FormOrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormOrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormOrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormOrganizationFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FormOrganization` */
export type FormOrganizationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FormOrganization`. Fields that are set will be updated. */
export type FormOrganizationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Organization` values, with data from `FormOrganization`. */
export type FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `FormOrganization`, and the cursor to aid in pagination. */
  edges: Array<FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `FormOrganization`. */
export type FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'FormOrganizationsByFormOrganizationFormIdAndOrganizationIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyConnection = {
  __typename?: 'FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyEdge = {
  __typename?: 'FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FormOrganizationsBySchedulerFormIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormOrganization` values. */
export type FormOrganizationsConnection = {
  __typename?: 'FormOrganizationsConnection';
  /** A list of edges which contains the `FormOrganization` and cursor to aid in pagination. */
  edges: Array<FormOrganizationsEdge>;
  /** A list of `FormOrganization` objects. */
  nodes: Array<FormOrganization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormOrganization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormOrganization` edge in the connection. */
export type FormOrganizationsEdge = {
  __typename?: 'FormOrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormOrganization` at the end of the edge. */
  node: FormOrganization;
};

/** Methods to use when ordering `FormOrganization`. */
export enum FormOrganizationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `Form`. Fields that are set will be updated. */
export type FormPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  createdFromTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  customField?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emailBody?: InputMaybe<Scalars['String']['input']>;
  emailSubject?: InputMaybe<Scalars['String']['input']>;
  gpsCoordinates?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isDraft?: InputMaybe<Scalars['Boolean']['input']>;
  isLocked?: InputMaybe<Scalars['Boolean']['input']>;
  isSendToOwner?: InputMaybe<Scalars['Boolean']['input']>;
  isShareableToTemplateLibrary?: InputMaybe<Scalars['Boolean']['input']>;
  isSpecial?: InputMaybe<Scalars['Int']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  refno?: InputMaybe<Scalars['String']['input']>;
  sharableLink?: InputMaybe<Scalars['UUID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FormSchedulerFieldsBySchedulerFormIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type FormTeamsBySchedulerFormIdAndTeamIdManyToManyConnection = {
  __typename?: 'FormTeamsBySchedulerFormIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTeamsBySchedulerFormIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FormTeamsBySchedulerFormIdAndTeamIdManyToManyEdge = {
  __typename?: 'FormTeamsBySchedulerFormIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FormTeamsBySchedulerFormIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type FormTemplate = Node & {
  __typename?: 'FormTemplate';
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFormCreatedFromTemplateIdAndAdminId: FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerFormTemplateIdAndAdminId: FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsBySchedulerFieldFormTemplateIdAndFieldId: FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerFormTemplateIdAndFillupformId: FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyConnection;
  /** Reads a single `Form` that is related to this `FormTemplate`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `FormTemplateGroup`. */
  formTemplateGroups: FormTemplateGroupsConnection;
  /** Reads and enables pagination through a set of `FormTemplateOrganization`. */
  formTemplateOrganizations: FormTemplateOrganizationsConnection;
  /** Reads and enables pagination through a set of `FormTemplateProject`. */
  formTemplateProjects: FormTemplateProjectsConnection;
  /** Reads and enables pagination through a set of `FormTemplateTeam`. */
  formTemplateTeams: FormTemplateTeamsConnection;
  /** Reads and enables pagination through a set of `FormTemplateUser`. */
  formTemplateUsers: FormTemplateUsersConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByCreatedFromTemplateId: FormsConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerFieldFormTemplateIdAndFormId: FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerFormTemplateIdAndFormId: FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByFormCreatedFromTemplateIdAndGroupId: FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByFormTemplateGroupFormTemplateIdAndGroupId: FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerFormTemplateIdAndGroupId: FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyConnection;
  hint: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationId: FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerFormTemplateIdAndOrgId: FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Project`. */
  projectsByFormTemplateProjectFormTemplateIdAndProjectId: FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsId: FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByFormCreatedFromTemplateIdAndTeamId: FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByFormTemplateTeamFormTemplateIdAndTeamId: FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerFormTemplateIdAndTeamId: FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyConnection;
  thumbnail?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByFormTemplateUserFormTemplateIdAndUserId: FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerFormTemplateIdAndUserId: FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyConnection;
};


export type FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type FormTemplateFormTemplateGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateGroupCondition>;
  filter?: InputMaybe<FormTemplateGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};


export type FormTemplateFormTemplateOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateOrganizationCondition>;
  filter?: InputMaybe<FormTemplateOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};


export type FormTemplateFormTemplateProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateProjectCondition>;
  filter?: InputMaybe<FormTemplateProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};


export type FormTemplateFormTemplateTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateTeamCondition>;
  filter?: InputMaybe<FormTemplateTeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};


export type FormTemplateFormTemplateUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateUserCondition>;
  filter?: InputMaybe<FormTemplateUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};


export type FormTemplateFormsByCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type FormTemplateFormsBySchedulerFormTemplateIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};


export type FormTemplateSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type FormTemplateSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type FormTemplateUsersBySchedulerFormTemplateIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Form`. */
export type FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyConnection = {
  __typename?: 'FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Form`. */
export type FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyEdge = {
  __typename?: 'FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Form`. */
export type FormTemplateAdminsByFormCreatedFromTemplateIdAndAdminIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyConnection = {
  __typename?: 'FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyEdge = {
  __typename?: 'FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type FormTemplateAdminsBySchedulerFormTemplateIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/**
 * A condition to be used against `FormTemplate` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `hint` field. */
  hint?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Field` values, with data from `SchedulerField`. */
export type FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyConnection = {
  __typename?: 'FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `SchedulerField`. */
export type FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyEdge = {
  __typename?: 'FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Field` at the end of the edge. */
  node: Field;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `Field` edge in the connection, with data from `SchedulerField`. */
export type FormTemplateFieldsBySchedulerFieldFormTemplateIdAndFieldIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyConnection = {
  __typename?: 'FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyEdge = {
  __typename?: 'FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type FormTemplateFillupFormsBySchedulerFormTemplateIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `FormTemplate` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `hint` field. */
  hint?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateFilter>>;
  /** Filter by the object’s `thumbnail` field. */
  thumbnail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `Form` values, with data from `SchedulerField`. */
export type FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyConnection = {
  __typename?: 'FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `SchedulerField`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `SchedulerField`. */
export type FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyEdge = {
  __typename?: 'FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields: SchedulerFieldsConnection;
};


/** A `Form` edge in the connection, with data from `SchedulerField`. */
export type FormTemplateFormsBySchedulerFieldFormTemplateIdAndFormIdManyToManyEdgeSchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyConnection = {
  __typename?: 'FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyEdge = {
  __typename?: 'FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type FormTemplateFormsBySchedulerFormTemplateIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type FormTemplateGroup = Node & {
  __typename?: 'FormTemplateGroup';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateGroup`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId: Scalars['BigInt']['output'];
  /** Reads a single `Group` that is related to this `FormTemplateGroup`. */
  group?: Maybe<Group>;
  groupId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FormTemplateGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateGroupCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FormTemplateGroup` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateGroupFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateGroupFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FormTemplateGroup` */
export type FormTemplateGroupInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  groupId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FormTemplateGroup`. Fields that are set will be updated. */
export type FormTemplateGroupPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Group` values, with data from `Form`. */
export type FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyConnection = {
  __typename?: 'FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Form`. */
export type FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyEdge = {
  __typename?: 'FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `Form`. */
export type FormTemplateGroupsByFormCreatedFromTemplateIdAndGroupIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `FormTemplateGroup`. */
export type FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyConnection = {
  __typename?: 'FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `FormTemplateGroup`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `FormTemplateGroup`. */
export type FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyEdge = {
  __typename?: 'FormTemplateGroupsByFormTemplateGroupFormTemplateIdAndGroupIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyConnection = {
  __typename?: 'FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyEdge = {
  __typename?: 'FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type FormTemplateGroupsBySchedulerFormTemplateIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormTemplateGroup` values. */
export type FormTemplateGroupsConnection = {
  __typename?: 'FormTemplateGroupsConnection';
  /** A list of edges which contains the `FormTemplateGroup` and cursor to aid in pagination. */
  edges: Array<FormTemplateGroupsEdge>;
  /** A list of `FormTemplateGroup` objects. */
  nodes: Array<FormTemplateGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplateGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplateGroup` edge in the connection. */
export type FormTemplateGroupsEdge = {
  __typename?: 'FormTemplateGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplateGroup` at the end of the edge. */
  node: FormTemplateGroup;
};

/** Methods to use when ordering `FormTemplateGroup`. */
export enum FormTemplateGroupsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** An input for mutations affecting `FormTemplate` */
export type FormTemplateInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId: Scalars['BigInt']['input'];
  hint: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  thumbnail?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type FormTemplateOrganization = Node & {
  __typename?: 'FormTemplateOrganization';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateOrganization`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `FormTemplateOrganization`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FormTemplateOrganization` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateOrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FormTemplateOrganization` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateOrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateOrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateOrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateOrganizationFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FormTemplateOrganization` */
export type FormTemplateOrganizationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FormTemplateOrganization`. Fields that are set will be updated. */
export type FormTemplateOrganizationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Organization` values, with data from `FormTemplateOrganization`. */
export type FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `FormTemplateOrganization`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `FormTemplateOrganization`. */
export type FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'FormTemplateOrganizationsByFormTemplateOrganizationFormTemplateIdAndOrganizationIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyConnection = {
  __typename?: 'FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyEdge = {
  __typename?: 'FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type FormTemplateOrganizationsBySchedulerFormTemplateIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormTemplateOrganization` values. */
export type FormTemplateOrganizationsConnection = {
  __typename?: 'FormTemplateOrganizationsConnection';
  /** A list of edges which contains the `FormTemplateOrganization` and cursor to aid in pagination. */
  edges: Array<FormTemplateOrganizationsEdge>;
  /** A list of `FormTemplateOrganization` objects. */
  nodes: Array<FormTemplateOrganization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplateOrganization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplateOrganization` edge in the connection. */
export type FormTemplateOrganizationsEdge = {
  __typename?: 'FormTemplateOrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplateOrganization` at the end of the edge. */
  node: FormTemplateOrganization;
};

/** Methods to use when ordering `FormTemplateOrganization`. */
export enum FormTemplateOrganizationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `FormTemplate`. Fields that are set will be updated. */
export type FormTemplatePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  thumbnail?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type FormTemplateProject = Node & {
  __typename?: 'FormTemplateProject';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateProject`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Project` that is related to this `FormTemplateProject`. */
  project?: Maybe<Project>;
  projectId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FormTemplateProject` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateProjectCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `projectId` field. */
  projectId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FormTemplateProject` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateProjectFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateProjectFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateProjectFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateProjectFilter>>;
  /** Filter by the object’s `projectId` field. */
  projectId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FormTemplateProject` */
export type FormTemplateProjectInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  projectId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FormTemplateProject`. Fields that are set will be updated. */
export type FormTemplateProjectPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  projectId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Project` values, with data from `FormTemplateProject`. */
export type FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyConnection = {
  __typename?: 'FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyConnection';
  /** A list of edges which contains the `Project`, info from the `FormTemplateProject`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyEdge>;
  /** A list of `Project` objects. */
  nodes: Array<Project>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Project` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Project` edge in the connection, with data from `FormTemplateProject`. */
export type FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyEdge = {
  __typename?: 'FormTemplateProjectsByFormTemplateProjectFormTemplateIdAndProjectIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Project` at the end of the edge. */
  node: Project;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `FormTemplateProject` values. */
export type FormTemplateProjectsConnection = {
  __typename?: 'FormTemplateProjectsConnection';
  /** A list of edges which contains the `FormTemplateProject` and cursor to aid in pagination. */
  edges: Array<FormTemplateProjectsEdge>;
  /** A list of `FormTemplateProject` objects. */
  nodes: Array<FormTemplateProject>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplateProject` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplateProject` edge in the connection. */
export type FormTemplateProjectsEdge = {
  __typename?: 'FormTemplateProjectsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplateProject` at the end of the edge. */
  node: FormTemplateProject;
};

/** Methods to use when ordering `FormTemplateProject`. */
export enum FormTemplateProjectsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjectIdAsc = 'PROJECT_ID_ASC',
  ProjectIdDesc = 'PROJECT_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type FormTemplateSchedulerFieldsBySchedulerFormTemplateIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type FormTemplateTeam = Node & {
  __typename?: 'FormTemplateTeam';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateTeam`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Team` that is related to this `FormTemplateTeam`. */
  team?: Maybe<Team>;
  teamId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `FormTemplateTeam` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateTeamCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `FormTemplateTeam` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateTeamFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateTeamFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateTeamFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateTeamFilter>>;
  /** Filter by the object’s `teamId` field. */
  teamId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `FormTemplateTeam` */
export type FormTemplateTeamInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  teamId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `FormTemplateTeam`. Fields that are set will be updated. */
export type FormTemplateTeamPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Team` values, with data from `Form`. */
export type FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyConnection = {
  __typename?: 'FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Form`. */
export type FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyEdge = {
  __typename?: 'FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Team` at the end of the edge. */
  node: Team;
};


/** A `Team` edge in the connection, with data from `Form`. */
export type FormTemplateTeamsByFormCreatedFromTemplateIdAndTeamIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `FormTemplateTeam`. */
export type FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyConnection = {
  __typename?: 'FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `FormTemplateTeam`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `FormTemplateTeam`. */
export type FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyEdge = {
  __typename?: 'FormTemplateTeamsByFormTemplateTeamFormTemplateIdAndTeamIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyConnection = {
  __typename?: 'FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyEdge = {
  __typename?: 'FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type FormTemplateTeamsBySchedulerFormTemplateIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormTemplateTeam` values. */
export type FormTemplateTeamsConnection = {
  __typename?: 'FormTemplateTeamsConnection';
  /** A list of edges which contains the `FormTemplateTeam` and cursor to aid in pagination. */
  edges: Array<FormTemplateTeamsEdge>;
  /** A list of `FormTemplateTeam` objects. */
  nodes: Array<FormTemplateTeam>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplateTeam` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplateTeam` edge in the connection. */
export type FormTemplateTeamsEdge = {
  __typename?: 'FormTemplateTeamsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplateTeam` at the end of the edge. */
  node: FormTemplateTeam;
};

/** Methods to use when ordering `FormTemplateTeam`. */
export enum FormTemplateTeamsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TeamIdAsc = 'TEAM_ID_ASC',
  TeamIdDesc = 'TEAM_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type FormTemplateUser = Node & {
  __typename?: 'FormTemplateUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateUser`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `FormTemplateUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `FormTemplateUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FormTemplateUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `FormTemplateUser` object types. All fields are combined with a logical ‘and.’ */
export type FormTemplateUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormTemplateUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormTemplateUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormTemplateUserFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `FormTemplateUser` */
export type FormTemplateUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `FormTemplateUser`. Fields that are set will be updated. */
export type FormTemplateUserPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values, with data from `FormTemplateUser`. */
export type FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyConnection = {
  __typename?: 'FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FormTemplateUser`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FormTemplateUser`. */
export type FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyEdge = {
  __typename?: 'FormTemplateUsersByFormTemplateUserFormTemplateIdAndUserIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyConnection = {
  __typename?: 'FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyEdge = {
  __typename?: 'FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type FormTemplateUsersBySchedulerFormTemplateIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormTemplateUser` values. */
export type FormTemplateUsersConnection = {
  __typename?: 'FormTemplateUsersConnection';
  /** A list of edges which contains the `FormTemplateUser` and cursor to aid in pagination. */
  edges: Array<FormTemplateUsersEdge>;
  /** A list of `FormTemplateUser` objects. */
  nodes: Array<FormTemplateUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplateUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplateUser` edge in the connection. */
export type FormTemplateUsersEdge = {
  __typename?: 'FormTemplateUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplateUser` at the end of the edge. */
  node: FormTemplateUser;
};

/** Methods to use when ordering `FormTemplateUser`. */
export enum FormTemplateUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `FormTemplate` values. */
export type FormTemplatesConnection = {
  __typename?: 'FormTemplatesConnection';
  /** A list of edges which contains the `FormTemplate` and cursor to aid in pagination. */
  edges: Array<FormTemplatesEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection. */
export type FormTemplatesEdge = {
  __typename?: 'FormTemplatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
};

/** Methods to use when ordering `FormTemplate`. */
export enum FormTemplatesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  HintAsc = 'HINT_ASC',
  HintDesc = 'HINT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ThumbnailAsc = 'THUMBNAIL_ASC',
  ThumbnailDesc = 'THUMBNAIL_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type FormUser = Node & {
  __typename?: 'FormUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Form` that is related to this `FormUser`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `FormUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `FormUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FormUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `FormUser` object types. All fields are combined with a logical ‘and.’ */
export type FormUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FormUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FormUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FormUserFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `FormUser` */
export type FormUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `FormUser`. Fields that are set will be updated. */
export type FormUserPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndApprovedByManyToManyConnection = {
  __typename?: 'FormUsersByFillupFormFormIdAndApprovedByManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<FormUsersByFillupFormFormIdAndApprovedByManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndApprovedByManyToManyEdge = {
  __typename?: 'FormUsersByFillupFormFormIdAndApprovedByManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsByApprovedBy: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndApprovedByManyToManyEdgeFillupFormsByApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndUserIdManyToManyConnection = {
  __typename?: 'FormUsersByFillupFormFormIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<FormUsersByFillupFormFormIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndUserIdManyToManyEdge = {
  __typename?: 'FormUsersByFillupFormFormIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type FormUsersByFillupFormFormIdAndUserIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FormUser`. */
export type FormUsersByFormUserFormIdAndUserIdManyToManyConnection = {
  __typename?: 'FormUsersByFormUserFormIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FormUser`, and the cursor to aid in pagination. */
  edges: Array<FormUsersByFormUserFormIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FormUser`. */
export type FormUsersByFormUserFormIdAndUserIdManyToManyEdge = {
  __typename?: 'FormUsersByFormUserFormIdAndUserIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type FormUsersBySchedulerFormIdAndUserIdManyToManyConnection = {
  __typename?: 'FormUsersBySchedulerFormIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<FormUsersBySchedulerFormIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type FormUsersBySchedulerFormIdAndUserIdManyToManyEdge = {
  __typename?: 'FormUsersBySchedulerFormIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type FormUsersBySchedulerFormIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `FormUser` values. */
export type FormUsersConnection = {
  __typename?: 'FormUsersConnection';
  /** A list of edges which contains the `FormUser` and cursor to aid in pagination. */
  edges: Array<FormUsersEdge>;
  /** A list of `FormUser` objects. */
  nodes: Array<FormUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormUser` edge in the connection. */
export type FormUsersEdge = {
  __typename?: 'FormUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormUser` at the end of the edge. */
  node: FormUser;
};

/** Methods to use when ordering `FormUser`. */
export enum FormUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Form` values. */
export type FormsConnection = {
  __typename?: 'FormsConnection';
  /** A list of edges which contains the `Form` and cursor to aid in pagination. */
  edges: Array<FormsEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection. */
export type FormsEdge = {
  __typename?: 'FormsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
};

/** Methods to use when ordering `Form`. */
export enum FormsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CreatedFromTemplateIdAsc = 'CREATED_FROM_TEMPLATE_ID_ASC',
  CreatedFromTemplateIdDesc = 'CREATED_FROM_TEMPLATE_ID_DESC',
  CustomFieldAsc = 'CUSTOM_FIELD_ASC',
  CustomFieldDesc = 'CUSTOM_FIELD_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EmailBodyAsc = 'EMAIL_BODY_ASC',
  EmailBodyDesc = 'EMAIL_BODY_DESC',
  EmailSubjectAsc = 'EMAIL_SUBJECT_ASC',
  EmailSubjectDesc = 'EMAIL_SUBJECT_DESC',
  GpsCoordinatesAsc = 'GPS_COORDINATES_ASC',
  GpsCoordinatesDesc = 'GPS_COORDINATES_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsDraftAsc = 'IS_DRAFT_ASC',
  IsDraftDesc = 'IS_DRAFT_DESC',
  IsLockedAsc = 'IS_LOCKED_ASC',
  IsLockedDesc = 'IS_LOCKED_DESC',
  IsSendToOwnerAsc = 'IS_SEND_TO_OWNER_ASC',
  IsSendToOwnerDesc = 'IS_SEND_TO_OWNER_DESC',
  IsShareableToTemplateLibraryAsc = 'IS_SHAREABLE_TO_TEMPLATE_LIBRARY_ASC',
  IsShareableToTemplateLibraryDesc = 'IS_SHAREABLE_TO_TEMPLATE_LIBRARY_DESC',
  IsSpecialAsc = 'IS_SPECIAL_ASC',
  IsSpecialDesc = 'IS_SPECIAL_DESC',
  LogoAsc = 'LOGO_ASC',
  LogoDesc = 'LOGO_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecipientsAsc = 'RECIPIENTS_ASC',
  RecipientsDesc = 'RECIPIENTS_DESC',
  RefnoAsc = 'REFNO_ASC',
  RefnoDesc = 'REFNO_DESC',
  SharableLinkAsc = 'SHARABLE_LINK_ASC',
  SharableLinkDesc = 'SHARABLE_LINK_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  TeamIdAsc = 'TEAM_ID_ASC',
  TeamIdDesc = 'TEAM_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Group = Node & {
  __typename?: 'Group';
  /** Reads a single `Admin` that is related to this `Group`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFormGroupIdAndAdminId: GroupAdminsByFormGroupIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByGroupParentIdAndAdminId: GroupAdminsByGroupParentIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerGroupIdAndAdminId: GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  childGroups: GroupsConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerGroupIdAndFillupformId: GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplateGroup`. */
  formTemplateGroups: FormTemplateGroupsConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormGroupIdAndCreatedFromTemplateId: GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTemplateGroupGroupIdAndFormTemplateId: GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerGroupIdAndFormTemplateId: GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerGroupIdAndFormId: GroupFormsBySchedulerGroupIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Group`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByGroupParentIdAndOrganizationId: GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerGroupIdAndOrgId: GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyConnection;
  /** Reads a single `Group` that is related to this `Group`. */
  parent?: Maybe<Group>;
  parentId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerGroupIdAndSchedulerFieldsId: GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByFormGroupIdAndTeamId: GroupTeamsByFormGroupIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerGroupIdAndTeamId: GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByGroupUserGroupIdAndUserId: GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerGroupIdAndUserId: GroupUsersBySchedulerGroupIdAndUserIdManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
};


export type GroupAdminsByFormGroupIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type GroupAdminsByGroupParentIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type GroupAdminsBySchedulerGroupIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type GroupChildGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type GroupFillupFormsBySchedulerGroupIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type GroupFormTemplateGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateGroupCondition>;
  filter?: InputMaybe<FormTemplateGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};


export type GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type GroupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type GroupFormsBySchedulerGroupIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type GroupGroupUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupUserCondition>;
  filter?: InputMaybe<GroupUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};


export type GroupOrganizationsByGroupParentIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type GroupOrganizationsBySchedulerGroupIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type GroupSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type GroupTeamsByFormGroupIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type GroupTeamsBySchedulerGroupIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type GroupUsersByGroupUserGroupIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type GroupUsersBySchedulerGroupIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Form`. */
export type GroupAdminsByFormGroupIdAndAdminIdManyToManyConnection = {
  __typename?: 'GroupAdminsByFormGroupIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<GroupAdminsByFormGroupIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Form`. */
export type GroupAdminsByFormGroupIdAndAdminIdManyToManyEdge = {
  __typename?: 'GroupAdminsByFormGroupIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Form`. */
export type GroupAdminsByFormGroupIdAndAdminIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Group`. */
export type GroupAdminsByGroupParentIdAndAdminIdManyToManyConnection = {
  __typename?: 'GroupAdminsByGroupParentIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<GroupAdminsByGroupParentIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Group`. */
export type GroupAdminsByGroupParentIdAndAdminIdManyToManyEdge = {
  __typename?: 'GroupAdminsByGroupParentIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Group`. */
export type GroupAdminsByGroupParentIdAndAdminIdManyToManyEdgeGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyConnection = {
  __typename?: 'GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyEdge = {
  __typename?: 'GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type GroupAdminsBySchedulerGroupIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyConnection = {
  __typename?: 'GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyEdge = {
  __typename?: 'GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type GroupFillupFormsBySchedulerGroupIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GroupFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GroupFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `Form`. */
export type GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyConnection = {
  __typename?: 'GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyEdge = {
  __typename?: 'GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  formsByCreatedFromTemplateId: FormsConnection;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
};


/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type GroupFormTemplatesByFormGroupIdAndCreatedFromTemplateIdManyToManyEdgeFormsByCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `FormTemplate` values, with data from `FormTemplateGroup`. */
export type GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `FormTemplateGroup`, and the cursor to aid in pagination. */
  edges: Array<GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `FormTemplateGroup`. */
export type GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'GroupFormTemplatesByFormTemplateGroupGroupIdAndFormTemplateIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type GroupFormTemplatesBySchedulerGroupIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type GroupFormsBySchedulerGroupIdAndFormIdManyToManyConnection = {
  __typename?: 'GroupFormsBySchedulerGroupIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupFormsBySchedulerGroupIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type GroupFormsBySchedulerGroupIdAndFormIdManyToManyEdge = {
  __typename?: 'GroupFormsBySchedulerGroupIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type GroupFormsBySchedulerGroupIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Organization` values, with data from `Group`. */
export type GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Group`. */
export type GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Group`. */
export type GroupOrganizationsByGroupParentIdAndOrganizationIdManyToManyEdgeGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyConnection = {
  __typename?: 'GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyEdge = {
  __typename?: 'GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type GroupOrganizationsBySchedulerGroupIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type GroupSchedulerFieldsBySchedulerGroupIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Form`. */
export type GroupTeamsByFormGroupIdAndTeamIdManyToManyConnection = {
  __typename?: 'GroupTeamsByFormGroupIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<GroupTeamsByFormGroupIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Form`. */
export type GroupTeamsByFormGroupIdAndTeamIdManyToManyEdge = {
  __typename?: 'GroupTeamsByFormGroupIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Team` at the end of the edge. */
  node: Team;
};


/** A `Team` edge in the connection, with data from `Form`. */
export type GroupTeamsByFormGroupIdAndTeamIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyConnection = {
  __typename?: 'GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyEdge = {
  __typename?: 'GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type GroupTeamsBySchedulerGroupIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type GroupUser = {
  __typename?: 'GroupUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Group` that is related to this `GroupUser`. */
  group?: Maybe<Group>;
  groupId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `GroupUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `GroupUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GroupUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `GroupUser` object types. All fields are combined with a logical ‘and.’ */
export type GroupUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GroupUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GroupUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GroupUserFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `GroupUser` */
export type GroupUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  groupId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** A connection to a list of `User` values, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection = {
  __typename?: 'GroupUsersByGroupUserGroupIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `GroupUser`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge = {
  __typename?: 'GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `GroupUser`. */
export type GroupUsersByGroupUserGroupIdAndUserIdManyToManyEdgeGroupUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupUserCondition>;
  filter?: InputMaybe<GroupUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type GroupUsersBySchedulerGroupIdAndUserIdManyToManyConnection = {
  __typename?: 'GroupUsersBySchedulerGroupIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<GroupUsersBySchedulerGroupIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type GroupUsersBySchedulerGroupIdAndUserIdManyToManyEdge = {
  __typename?: 'GroupUsersBySchedulerGroupIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type GroupUsersBySchedulerGroupIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `GroupUser` values. */
export type GroupUsersConnection = {
  __typename?: 'GroupUsersConnection';
  /** A list of edges which contains the `GroupUser` and cursor to aid in pagination. */
  edges: Array<GroupUsersEdge>;
  /** A list of `GroupUser` objects. */
  nodes: Array<GroupUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GroupUser` edge in the connection. */
export type GroupUsersEdge = {
  __typename?: 'GroupUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GroupUser` at the end of the edge. */
  node: GroupUser;
};

/** Methods to use when ordering `GroupUser`. */
export enum GroupUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  Natural = 'NATURAL',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against InternetAddress fields. All fields are combined with a logical ‘and.’ */
export type InternetAddressFilter = {
  /** Contained by the specified internet address. */
  containedBy?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Contained by or equal to the specified internet address. */
  containedByOrEqualTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Contains the specified internet address. */
  contains?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Contains or contained by the specified internet address. */
  containsOrContainedBy?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Contains or equal to the specified internet address. */
  containsOrEqualTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['InternetAddress']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['InternetAddress']['input']>>;
};

export type Issuance = Node & {
  __typename?: 'Issuance';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Equipment` that is related to this `Issuance`. */
  equipment?: Maybe<Equipment>;
  equipmentId: Scalars['BigInt']['output'];
  expiryDate: Scalars['Date']['output'];
  id: Scalars['BigInt']['output'];
  issuanceNumber?: Maybe<Scalars['String']['output']>;
  issuedAt: Scalars['Date']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  photo?: Maybe<Scalars['String']['output']>;
  remarks: Scalars['String']['output'];
  serialNumber: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Issuance`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `Issuance` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type IssuanceCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `equipmentId` field. */
  equipmentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `issuanceNumber` field. */
  issuanceNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `issuedAt` field. */
  issuedAt?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `photo` field. */
  photo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `Issuance` object types. All fields are combined with a logical ‘and.’ */
export type IssuanceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<IssuanceFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `equipmentId` field. */
  equipmentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `issuanceNumber` field. */
  issuanceNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `issuedAt` field. */
  issuedAt?: InputMaybe<DateFilter>;
  /** Negates the expression. */
  not?: InputMaybe<IssuanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<IssuanceFilter>>;
  /** Filter by the object’s `photo` field. */
  photo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Issuance` */
export type IssuanceInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  equipmentId: Scalars['BigInt']['input'];
  expiryDate: Scalars['Date']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  issuanceNumber?: InputMaybe<Scalars['String']['input']>;
  issuedAt: Scalars['Date']['input'];
  photo?: InputMaybe<Scalars['String']['input']>;
  remarks: Scalars['String']['input'];
  serialNumber: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `Issuance`. Fields that are set will be updated. */
export type IssuancePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  equipmentId?: InputMaybe<Scalars['BigInt']['input']>;
  expiryDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  issuanceNumber?: InputMaybe<Scalars['String']['input']>;
  issuedAt?: InputMaybe<Scalars['Date']['input']>;
  photo?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Issuance` values. */
export type IssuancesConnection = {
  __typename?: 'IssuancesConnection';
  /** A list of edges which contains the `Issuance` and cursor to aid in pagination. */
  edges: Array<IssuancesEdge>;
  /** A list of `Issuance` objects. */
  nodes: Array<Issuance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Issuance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Issuance` edge in the connection. */
export type IssuancesEdge = {
  __typename?: 'IssuancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Issuance` at the end of the edge. */
  node: Issuance;
};

/** Methods to use when ordering `Issuance`. */
export enum IssuancesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  EquipmentIdAsc = 'EQUIPMENT_ID_ASC',
  EquipmentIdDesc = 'EQUIPMENT_ID_DESC',
  ExpiryDateAsc = 'EXPIRY_DATE_ASC',
  ExpiryDateDesc = 'EXPIRY_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IssuanceNumberAsc = 'ISSUANCE_NUMBER_ASC',
  IssuanceNumberDesc = 'ISSUANCE_NUMBER_DESC',
  IssuedAtAsc = 'ISSUED_AT_ASC',
  IssuedAtDesc = 'ISSUED_AT_DESC',
  Natural = 'NATURAL',
  PhotoAsc = 'PHOTO_ASC',
  PhotoDesc = 'PHOTO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Job = Node & {
  __typename?: 'Job';
  /** Reads a single `User` that is related to this `Job`. */
  admin?: Maybe<User>;
  adminId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Job`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `Job` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Job` object types. All fields are combined with a logical ‘and.’ */
export type JobFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Job` */
export type JobInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Job`. Fields that are set will be updated. */
export type JobPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type JobSendingEmail = Node & {
  __typename?: 'JobSendingEmail';
  /** Reads a single `JobSendingEmailCategory` that is related to this `JobSendingEmail`. */
  category?: Maybe<JobSendingEmailCategory>;
  categoryId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  isDone: Scalars['Int']['output'];
  isProcessing: Scalars['Int']['output'];
  isSent: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `JobSendingEmailLog`. */
  jobSendingEmailLogs: JobSendingEmailLogsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  payload: Scalars['String']['output'];
  sentFrom: Scalars['BigInt']['output'];
  sentTo: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentFrom?: Maybe<User>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentTo?: Maybe<User>;
};


export type JobSendingEmailJobSendingEmailLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailLogCondition>;
  filter?: InputMaybe<JobSendingEmailLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailLogsOrderBy>>;
};

/** A connection to a list of `JobSendingEmailCategory` values. */
export type JobSendingEmailCategoriesConnection = {
  __typename?: 'JobSendingEmailCategoriesConnection';
  /** A list of edges which contains the `JobSendingEmailCategory` and cursor to aid in pagination. */
  edges: Array<JobSendingEmailCategoriesEdge>;
  /** A list of `JobSendingEmailCategory` objects. */
  nodes: Array<JobSendingEmailCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSendingEmailCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSendingEmailCategory` edge in the connection. */
export type JobSendingEmailCategoriesEdge = {
  __typename?: 'JobSendingEmailCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobSendingEmailCategory` at the end of the edge. */
  node: JobSendingEmailCategory;
};

/** Methods to use when ordering `JobSendingEmailCategory`. */
export enum JobSendingEmailCategoriesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type JobSendingEmailCategory = Node & {
  __typename?: 'JobSendingEmailCategory';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsByCategoryId: JobSendingEmailsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByJobSendingEmailCategoryIdAndSentFrom: JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByJobSendingEmailCategoryIdAndSentTo: JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyConnection;
};


export type JobSendingEmailCategoryJobSendingEmailsByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};


export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/**
 * A condition to be used against `JobSendingEmailCategory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type JobSendingEmailCategoryCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `JobSendingEmailCategory` object types. All fields are combined with a logical ‘and.’ */
export type JobSendingEmailCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobSendingEmailCategoryFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobSendingEmailCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobSendingEmailCategoryFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `JobSendingEmailCategory` */
export type JobSendingEmailCategoryInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `JobSendingEmailCategory`. Fields that are set will be updated. */
export type JobSendingEmailCategoryPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `User` values, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyConnection = {
  __typename?: 'JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyEdge = {
  __typename?: 'JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentFrom: JobSendingEmailsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentFromManyToManyEdgeJobSendingEmailsBySentFromArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyConnection = {
  __typename?: 'JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyEdge = {
  __typename?: 'JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentTo: JobSendingEmailsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type JobSendingEmailCategoryUsersByJobSendingEmailCategoryIdAndSentToManyToManyEdgeJobSendingEmailsBySentToArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/**
 * A condition to be used against `JobSendingEmail` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type JobSendingEmailCondition = {
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isDone` field. */
  isDone?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isProcessing` field. */
  isProcessing?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isSent` field. */
  isSent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `payload` field. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sentFrom` field. */
  sentFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sentTo` field. */
  sentTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `JobSendingEmail` object types. All fields are combined with a logical ‘and.’ */
export type JobSendingEmailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobSendingEmailFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isDone` field. */
  isDone?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isProcessing` field. */
  isProcessing?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isSent` field. */
  isSent?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobSendingEmailFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobSendingEmailFilter>>;
  /** Filter by the object’s `payload` field. */
  payload?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sentFrom` field. */
  sentFrom?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sentTo` field. */
  sentTo?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `JobSendingEmail` */
export type JobSendingEmailInput = {
  categoryId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isDone?: InputMaybe<Scalars['Int']['input']>;
  isProcessing?: InputMaybe<Scalars['Int']['input']>;
  isSent?: InputMaybe<Scalars['Int']['input']>;
  payload: Scalars['String']['input'];
  sentFrom: Scalars['BigInt']['input'];
  sentTo: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type JobSendingEmailLog = Node & {
  __typename?: 'JobSendingEmailLog';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** Reads a single `JobSendingEmail` that is related to this `JobSendingEmailLog`. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  jobSendingEmailId: Scalars['BigInt']['output'];
  message: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `JobSendingEmailLog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type JobSendingEmailLogCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `jobSendingEmailId` field. */
  jobSendingEmailId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `JobSendingEmailLog` object types. All fields are combined with a logical ‘and.’ */
export type JobSendingEmailLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobSendingEmailLogFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `jobSendingEmailId` field. */
  jobSendingEmailId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobSendingEmailLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobSendingEmailLogFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `JobSendingEmailLog` */
export type JobSendingEmailLogInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  jobSendingEmailId: Scalars['BigInt']['input'];
  message: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `JobSendingEmailLog`. Fields that are set will be updated. */
export type JobSendingEmailLogPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  jobSendingEmailId?: InputMaybe<Scalars['BigInt']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `JobSendingEmailLog` values. */
export type JobSendingEmailLogsConnection = {
  __typename?: 'JobSendingEmailLogsConnection';
  /** A list of edges which contains the `JobSendingEmailLog` and cursor to aid in pagination. */
  edges: Array<JobSendingEmailLogsEdge>;
  /** A list of `JobSendingEmailLog` objects. */
  nodes: Array<JobSendingEmailLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSendingEmailLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSendingEmailLog` edge in the connection. */
export type JobSendingEmailLogsEdge = {
  __typename?: 'JobSendingEmailLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobSendingEmailLog` at the end of the edge. */
  node: JobSendingEmailLog;
};

/** Methods to use when ordering `JobSendingEmailLog`. */
export enum JobSendingEmailLogsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  JobSendingEmailIdAsc = 'JOB_SENDING_EMAIL_ID_ASC',
  JobSendingEmailIdDesc = 'JOB_SENDING_EMAIL_ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `JobSendingEmail`. Fields that are set will be updated. */
export type JobSendingEmailPatch = {
  categoryId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isDone?: InputMaybe<Scalars['Int']['input']>;
  isProcessing?: InputMaybe<Scalars['Int']['input']>;
  isSent?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['String']['input']>;
  sentFrom?: InputMaybe<Scalars['BigInt']['input']>;
  sentTo?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `JobSendingEmail` values. */
export type JobSendingEmailsConnection = {
  __typename?: 'JobSendingEmailsConnection';
  /** A list of edges which contains the `JobSendingEmail` and cursor to aid in pagination. */
  edges: Array<JobSendingEmailsEdge>;
  /** A list of `JobSendingEmail` objects. */
  nodes: Array<JobSendingEmail>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSendingEmail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSendingEmail` edge in the connection. */
export type JobSendingEmailsEdge = {
  __typename?: 'JobSendingEmailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JobSendingEmail` at the end of the edge. */
  node: JobSendingEmail;
};

/** Methods to use when ordering `JobSendingEmail`. */
export enum JobSendingEmailsOrderBy {
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsDoneAsc = 'IS_DONE_ASC',
  IsDoneDesc = 'IS_DONE_DESC',
  IsProcessingAsc = 'IS_PROCESSING_ASC',
  IsProcessingDesc = 'IS_PROCESSING_DESC',
  IsSentAsc = 'IS_SENT_ASC',
  IsSentDesc = 'IS_SENT_DESC',
  Natural = 'NATURAL',
  PayloadAsc = 'PAYLOAD_ASC',
  PayloadDesc = 'PAYLOAD_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SentFromAsc = 'SENT_FROM_ASC',
  SentFromDesc = 'SENT_FROM_DESC',
  SentToAsc = 'SENT_TO_ASC',
  SentToDesc = 'SENT_TO_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `Job` values. */
export type JobsConnection = {
  __typename?: 'JobsConnection';
  /** A list of edges which contains the `Job` and cursor to aid in pagination. */
  edges: Array<JobsEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection. */
export type JobsEdge = {
  __typename?: 'JobsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** Methods to use when ordering `Job`. */
export enum JobsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Kind = Node & {
  __typename?: 'Kind';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Datatype`. */
  datatypesByPropertyKindIdAndDatatypeId: KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyConnection;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
  slug: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type KindDatatypesByPropertyKindIdAndDatatypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DatatypeCondition>;
  filter?: InputMaybe<DatatypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DatatypesOrderBy>>;
};


export type KindPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** A condition to be used against `Kind` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type KindCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Datatype` values, with data from `Property`. */
export type KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyConnection = {
  __typename?: 'KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyConnection';
  /** A list of edges which contains the `Datatype`, info from the `Property`, and the cursor to aid in pagination. */
  edges: Array<KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyEdge>;
  /** A list of `Datatype` objects. */
  nodes: Array<Datatype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Datatype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Datatype` edge in the connection, with data from `Property`. */
export type KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyEdge = {
  __typename?: 'KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Datatype` at the end of the edge. */
  node: Datatype;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


/** A `Datatype` edge in the connection, with data from `Property`. */
export type KindDatatypesByPropertyKindIdAndDatatypeIdManyToManyEdgePropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** A filter to be used against `Kind` object types. All fields are combined with a logical ‘and.’ */
export type KindFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<KindFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<KindFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<KindFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Kind` */
export type KindInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  slug: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Kind`. Fields that are set will be updated. */
export type KindPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Kind` values. */
export type KindsConnection = {
  __typename?: 'KindsConnection';
  /** A list of edges which contains the `Kind` and cursor to aid in pagination. */
  edges: Array<KindsEdge>;
  /** A list of `Kind` objects. */
  nodes: Array<Kind>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Kind` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Kind` edge in the connection. */
export type KindsEdge = {
  __typename?: 'KindsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Kind` at the end of the edge. */
  node: Kind;
};

/** Methods to use when ordering `Kind`. */
export enum KindsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Language = Node & {
  __typename?: 'Language';
  code: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `FieldTranslation`. */
  fieldTranslations: FieldTranslationsConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsByFieldTranslationLanguageIdAndFieldId: LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type LanguageFieldTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldTranslationCondition>;
  filter?: InputMaybe<FieldTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};


export type LanguageFieldsByFieldTranslationLanguageIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/**
 * A condition to be used against `Language` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LanguageCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Field` values, with data from `FieldTranslation`. */
export type LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyConnection = {
  __typename?: 'LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `FieldTranslation`, and the cursor to aid in pagination. */
  edges: Array<LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `FieldTranslation`. */
export type LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyEdge = {
  __typename?: 'LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldTranslation`. */
  fieldTranslations: FieldTranslationsConnection;
  /** The `Field` at the end of the edge. */
  node: Field;
};


/** A `Field` edge in the connection, with data from `FieldTranslation`. */
export type LanguageFieldsByFieldTranslationLanguageIdAndFieldIdManyToManyEdgeFieldTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldTranslationCondition>;
  filter?: InputMaybe<FieldTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};

/** A filter to be used against `Language` object types. All fields are combined with a logical ‘and.’ */
export type LanguageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LanguageFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LanguageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LanguageFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Language` */
export type LanguageInput = {
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Language`. Fields that are set will be updated. */
export type LanguagePatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Language` values. */
export type LanguagesConnection = {
  __typename?: 'LanguagesConnection';
  /** A list of edges which contains the `Language` and cursor to aid in pagination. */
  edges: Array<LanguagesEdge>;
  /** A list of `Language` objects. */
  nodes: Array<Language>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Language` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Language` edge in the connection. */
export type LanguagesEdge = {
  __typename?: 'LanguagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Language` at the end of the edge. */
  node: Language;
};

/** Methods to use when ordering `Language`. */
export enum LanguagesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type LoginTransaction = Node & {
  __typename?: 'LoginTransaction';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  ipAddress: Scalars['InternetAddress']['output'];
  lastLoginDate: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `LoginTransaction`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `LoginTransaction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LoginTransactionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['InternetAddress']['input']>;
  /** Checks for equality with the object’s `lastLoginDate` field. */
  lastLoginDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `LoginTransaction` object types. All fields are combined with a logical ‘and.’ */
export type LoginTransactionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LoginTransactionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<InternetAddressFilter>;
  /** Filter by the object’s `lastLoginDate` field. */
  lastLoginDate?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LoginTransactionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LoginTransactionFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `LoginTransaction` */
export type LoginTransactionInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  ipAddress: Scalars['InternetAddress']['input'];
  lastLoginDate: Scalars['Datetime']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `LoginTransaction`. Fields that are set will be updated. */
export type LoginTransactionPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  ipAddress?: InputMaybe<Scalars['InternetAddress']['input']>;
  lastLoginDate?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `LoginTransaction` values. */
export type LoginTransactionsConnection = {
  __typename?: 'LoginTransactionsConnection';
  /** A list of edges which contains the `LoginTransaction` and cursor to aid in pagination. */
  edges: Array<LoginTransactionsEdge>;
  /** A list of `LoginTransaction` objects. */
  nodes: Array<LoginTransaction>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LoginTransaction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LoginTransaction` edge in the connection. */
export type LoginTransactionsEdge = {
  __typename?: 'LoginTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LoginTransaction` at the end of the edge. */
  node: LoginTransaction;
};

/** Methods to use when ordering `LoginTransaction`. */
export enum LoginTransactionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  LastLoginDateAsc = 'LAST_LOGIN_DATE_ASC',
  LastLoginDateDesc = 'LAST_LOGIN_DATE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Metric = Node & {
  __typename?: 'Metric';
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByToolMetricIdAndAdminId: MetricAdminsByToolMetricIdAndAdminIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['BigInt']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByToolMetricIdAndOrganizationId: MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
  /** Reads and enables pagination through a set of `Tooltype`. */
  tooltypesByToolMetricIdAndTooltypeId: MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
};


export type MetricAdminsByToolMetricIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type MetricOrganizationsByToolMetricIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type MetricToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};


export type MetricTooltypesByToolMetricIdAndTooltypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TooltypeCondition>;
  filter?: InputMaybe<TooltypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Tool`. */
export type MetricAdminsByToolMetricIdAndAdminIdManyToManyConnection = {
  __typename?: 'MetricAdminsByToolMetricIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<MetricAdminsByToolMetricIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Tool`. */
export type MetricAdminsByToolMetricIdAndAdminIdManyToManyEdge = {
  __typename?: 'MetricAdminsByToolMetricIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Admin` edge in the connection, with data from `Tool`. */
export type MetricAdminsByToolMetricIdAndAdminIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A condition to be used against `Metric` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MetricCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Metric` object types. All fields are combined with a logical ‘and.’ */
export type MetricFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MetricFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MetricFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MetricFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Metric` */
export type MetricInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** A connection to a list of `Organization` values, with data from `Tool`. */
export type MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Tool`. */
export type MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Organization` edge in the connection, with data from `Tool`. */
export type MetricOrganizationsByToolMetricIdAndOrganizationIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** Represents an update to a `Metric`. Fields that are set will be updated. */
export type MetricPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Tooltype` values, with data from `Tool`. */
export type MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyConnection = {
  __typename?: 'MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyConnection';
  /** A list of edges which contains the `Tooltype`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyEdge>;
  /** A list of `Tooltype` objects. */
  nodes: Array<Tooltype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tooltype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyEdge = {
  __typename?: 'MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tooltype` at the end of the edge. */
  node: Tooltype;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type MetricTooltypesByToolMetricIdAndTooltypeIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A connection to a list of `Metric` values. */
export type MetricsConnection = {
  __typename?: 'MetricsConnection';
  /** A list of edges which contains the `Metric` and cursor to aid in pagination. */
  edges: Array<MetricsEdge>;
  /** A list of `Metric` objects. */
  nodes: Array<Metric>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Metric` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Metric` edge in the connection. */
export type MetricsEdge = {
  __typename?: 'MetricsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Metric` at the end of the edge. */
  node: Metric;
};

/** Methods to use when ordering `Metric`. */
export enum MetricsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Migration = Node & {
  __typename?: 'Migration';
  batch: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  migration: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `Migration` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MigrationCondition = {
  /** Checks for equality with the object’s `batch` field. */
  batch?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `migration` field. */
  migration?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Migration` object types. All fields are combined with a logical ‘and.’ */
export type MigrationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MigrationFilter>>;
  /** Filter by the object’s `batch` field. */
  batch?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `migration` field. */
  migration?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MigrationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MigrationFilter>>;
};

/** An input for mutations affecting `Migration` */
export type MigrationInput = {
  batch: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  migration: Scalars['String']['input'];
};

/** Represents an update to a `Migration`. Fields that are set will be updated. */
export type MigrationPatch = {
  batch?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  migration?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Migration` values. */
export type MigrationsConnection = {
  __typename?: 'MigrationsConnection';
  /** A list of edges which contains the `Migration` and cursor to aid in pagination. */
  edges: Array<MigrationsEdge>;
  /** A list of `Migration` objects. */
  nodes: Array<Migration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Migration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Migration` edge in the connection. */
export type MigrationsEdge = {
  __typename?: 'MigrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Migration` at the end of the edge. */
  node: Migration;
};

/** Methods to use when ordering `Migration`. */
export enum MigrationsOrderBy {
  BatchAsc = 'BATCH_ASC',
  BatchDesc = 'BATCH_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MigrationAsc = 'MIGRATION_ASC',
  MigrationDesc = 'MIGRATION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `Ability`. */
  createAbility?: Maybe<CreateAbilityPayload>;
  /** Creates a single `AbilityRole`. */
  createAbilityRole?: Maybe<CreateAbilityRolePayload>;
  /** Creates a single `Admin`. */
  createAdmin?: Maybe<CreateAdminPayload>;
  /** Creates a single `AllowedSettingValue`. */
  createAllowedSettingValue?: Maybe<CreateAllowedSettingValuePayload>;
  /** Creates a single `Attachment`. */
  createAttachment?: Maybe<CreateAttachmentPayload>;
  /** Creates a single `Certification`. */
  createCertification?: Maybe<CreateCertificationPayload>;
  /** Creates a single `Company`. */
  createCompany?: Maybe<CreateCompanyPayload>;
  /** Creates a single `CompanyUser`. */
  createCompanyUser?: Maybe<CreateCompanyUserPayload>;
  /** Creates a single `Component`. */
  createComponent?: Maybe<CreateComponentPayload>;
  /** Creates a single `ComponentEvent`. */
  createComponentEvent?: Maybe<CreateComponentEventPayload>;
  /** Creates a single `ComponentProperty`. */
  createComponentProperty?: Maybe<CreateComponentPropertyPayload>;
  /** Creates a single `Course`. */
  createCourse?: Maybe<CreateCoursePayload>;
  /** Creates a single `Datatype`. */
  createDatatype?: Maybe<CreateDatatypePayload>;
  /** Creates a single `Equipment`. */
  createEquipment?: Maybe<CreateEquipmentPayload>;
  /** Creates a single `EquipmentType`. */
  createEquipmentType?: Maybe<CreateEquipmentTypePayload>;
  /** Creates a single `ErrorReport`. */
  createErrorReport?: Maybe<CreateErrorReportPayload>;
  /** Creates a single `Event`. */
  createEvent?: Maybe<CreateEventPayload>;
  /** Creates a single `FailedJob`. */
  createFailedJob?: Maybe<CreateFailedJobPayload>;
  /** Creates a single `Field`. */
  createField?: Maybe<CreateFieldPayload>;
  /** Creates a single `FieldAction`. */
  createFieldAction?: Maybe<CreateFieldActionPayload>;
  /** Creates a single `FieldProperty`. */
  createFieldProperty?: Maybe<CreateFieldPropertyPayload>;
  /** Creates a single `FieldTranslation`. */
  createFieldTranslation?: Maybe<CreateFieldTranslationPayload>;
  /** Creates a single `FillupForm`. */
  createFillupForm?: Maybe<CreateFillupFormPayload>;
  /** Creates a single `FillupFormField`. */
  createFillupFormField?: Maybe<CreateFillupFormFieldPayload>;
  /** Creates a single `Form`. */
  createForm?: Maybe<CreateFormPayload>;
  /** Creates a single `FormOrganization`. */
  createFormOrganization?: Maybe<CreateFormOrganizationPayload>;
  /** Creates a single `FormTemplate`. */
  createFormTemplate?: Maybe<CreateFormTemplatePayload>;
  /** Creates a single `FormTemplateGroup`. */
  createFormTemplateGroup?: Maybe<CreateFormTemplateGroupPayload>;
  /** Creates a single `FormTemplateOrganization`. */
  createFormTemplateOrganization?: Maybe<CreateFormTemplateOrganizationPayload>;
  /** Creates a single `FormTemplateProject`. */
  createFormTemplateProject?: Maybe<CreateFormTemplateProjectPayload>;
  /** Creates a single `FormTemplateTeam`. */
  createFormTemplateTeam?: Maybe<CreateFormTemplateTeamPayload>;
  /** Creates a single `FormTemplateUser`. */
  createFormTemplateUser?: Maybe<CreateFormTemplateUserPayload>;
  /** Creates a single `FormUser`. */
  createFormUser?: Maybe<CreateFormUserPayload>;
  /** Creates a single `Group`. */
  createGroup?: Maybe<CreateGroupPayload>;
  /** Creates a single `GroupUser`. */
  createGroupUser?: Maybe<CreateGroupUserPayload>;
  /** Creates a single `Issuance`. */
  createIssuance?: Maybe<CreateIssuancePayload>;
  /** Creates a single `Job`. */
  createJob?: Maybe<CreateJobPayload>;
  /** Creates a single `JobSendingEmail`. */
  createJobSendingEmail?: Maybe<CreateJobSendingEmailPayload>;
  /** Creates a single `JobSendingEmailCategory`. */
  createJobSendingEmailCategory?: Maybe<CreateJobSendingEmailCategoryPayload>;
  /** Creates a single `JobSendingEmailLog`. */
  createJobSendingEmailLog?: Maybe<CreateJobSendingEmailLogPayload>;
  /** Creates a single `Kind`. */
  createKind?: Maybe<CreateKindPayload>;
  /** Creates a single `Language`. */
  createLanguage?: Maybe<CreateLanguagePayload>;
  /** Creates a single `LoginTransaction`. */
  createLoginTransaction?: Maybe<CreateLoginTransactionPayload>;
  /** Creates a single `Metric`. */
  createMetric?: Maybe<CreateMetricPayload>;
  /** Creates a single `Migration`. */
  createMigration?: Maybe<CreateMigrationPayload>;
  /** Creates a single `News`. */
  createNews?: Maybe<CreateNewsPayload>;
  /** Creates a single `Organization`. */
  createOrganization?: Maybe<CreateOrganizationPayload>;
  /** Creates a single `OrganizationUser`. */
  createOrganizationUser?: Maybe<CreateOrganizationUserPayload>;
  /** Creates a single `PasswordReset`. */
  createPasswordReset?: Maybe<CreatePasswordResetPayload>;
  /** Creates a single `PersonalAccessToken`. */
  createPersonalAccessToken?: Maybe<CreatePersonalAccessTokenPayload>;
  /** Creates a single `Profile`. */
  createProfile?: Maybe<CreateProfilePayload>;
  /** Creates a single `Project`. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Creates a single `ProjectUser`. */
  createProjectUser?: Maybe<CreateProjectUserPayload>;
  /** Creates a single `Property`. */
  createProperty?: Maybe<CreatePropertyPayload>;
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>;
  /** Creates a single `RoleUser`. */
  createRoleUser?: Maybe<CreateRoleUserPayload>;
  /** Creates a single `RoleUserOrganization`. */
  createRoleUserOrganization?: Maybe<CreateRoleUserOrganizationPayload>;
  /** Creates a single `Scheduler`. */
  createScheduler?: Maybe<CreateSchedulerPayload>;
  /** Creates a single `SchedulerField`. */
  createSchedulerField?: Maybe<CreateSchedulerFieldPayload>;
  /** Creates a single `SentMail`. */
  createSentMail?: Maybe<CreateSentMailPayload>;
  /** Creates a single `Session`. */
  createSession?: Maybe<CreateSessionPayload>;
  /** Creates a single `Setting`. */
  createSetting?: Maybe<CreateSettingPayload>;
  /** Creates a single `SettingGroup`. */
  createSettingGroup?: Maybe<CreateSettingGroupPayload>;
  /** Creates a single `Subscription`. */
  createSubscription?: Maybe<CreateSubscriptionPayload>;
  /** Creates a single `SubscriptionItem`. */
  createSubscriptionItem?: Maybe<CreateSubscriptionItemPayload>;
  /** Creates a single `SystemEvent`. */
  createSystemEvent?: Maybe<CreateSystemEventPayload>;
  /** Creates a single `Team`. */
  createTeam?: Maybe<CreateTeamPayload>;
  /** Creates a single `TeamUser`. */
  createTeamUser?: Maybe<CreateTeamUserPayload>;
  /** Creates a single `TelescopeEntriesTag`. */
  createTelescopeEntriesTag?: Maybe<CreateTelescopeEntriesTagPayload>;
  /** Creates a single `TelescopeEntry`. */
  createTelescopeEntry?: Maybe<CreateTelescopeEntryPayload>;
  /** Creates a single `TelescopeMonitoring`. */
  createTelescopeMonitoring?: Maybe<CreateTelescopeMonitoringPayload>;
  /** Creates a single `Tool`. */
  createTool?: Maybe<CreateToolPayload>;
  /** Creates a single `ToolUser`. */
  createToolUser?: Maybe<CreateToolUserPayload>;
  /** Creates a single `Tooltype`. */
  createTooltype?: Maybe<CreateTooltypePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserInvite`. */
  createUserInvite?: Maybe<CreateUserInvitePayload>;
  /** Creates a single `UserSetting`. */
  createUserSetting?: Maybe<CreateUserSettingPayload>;
  /** Creates a single `VerificationToken`. */
  createVerificationToken?: Maybe<CreateVerificationTokenPayload>;
  /** Creates a single `VerificationTokenType`. */
  createVerificationTokenType?: Maybe<CreateVerificationTokenTypePayload>;
  /** Creates a single `WebsocketsStatisticsEntry`. */
  createWebsocketsStatisticsEntry?: Maybe<CreateWebsocketsStatisticsEntryPayload>;
  /** Creates a single `WorkType`. */
  createWorkType?: Maybe<CreateWorkTypePayload>;
  /** Deletes a single `Ability` using a unique key. */
  deleteAbility?: Maybe<DeleteAbilityPayload>;
  /** Deletes a single `Ability` using its globally unique id. */
  deleteAbilityByNodeId?: Maybe<DeleteAbilityPayload>;
  /** Deletes a single `AbilityRole` using a unique key. */
  deleteAbilityRole?: Maybe<DeleteAbilityRolePayload>;
  /** Deletes a single `AbilityRole` using its globally unique id. */
  deleteAbilityRoleByNodeId?: Maybe<DeleteAbilityRolePayload>;
  /** Deletes a single `Admin` using a unique key. */
  deleteAdmin?: Maybe<DeleteAdminPayload>;
  /** Deletes a single `Admin` using its globally unique id. */
  deleteAdminByNodeId?: Maybe<DeleteAdminPayload>;
  /** Deletes a single `AllowedSettingValue` using a unique key. */
  deleteAllowedSettingValue?: Maybe<DeleteAllowedSettingValuePayload>;
  /** Deletes a single `AllowedSettingValue` using its globally unique id. */
  deleteAllowedSettingValueByNodeId?: Maybe<DeleteAllowedSettingValuePayload>;
  /** Deletes a single `Attachment` using a unique key. */
  deleteAttachment?: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `Attachment` using its globally unique id. */
  deleteAttachmentByNodeId?: Maybe<DeleteAttachmentPayload>;
  /** Deletes a single `Certification` using a unique key. */
  deleteCertification?: Maybe<DeleteCertificationPayload>;
  /** Deletes a single `Certification` using its globally unique id. */
  deleteCertificationByNodeId?: Maybe<DeleteCertificationPayload>;
  /** Deletes a single `Company` using a unique key. */
  deleteCompany?: Maybe<DeleteCompanyPayload>;
  /** Deletes a single `Company` using its globally unique id. */
  deleteCompanyByNodeId?: Maybe<DeleteCompanyPayload>;
  /** Deletes a single `Component` using a unique key. */
  deleteComponent?: Maybe<DeleteComponentPayload>;
  /** Deletes a single `Component` using a unique key. */
  deleteComponentByDescription?: Maybe<DeleteComponentPayload>;
  /** Deletes a single `Component` using its globally unique id. */
  deleteComponentByNodeId?: Maybe<DeleteComponentPayload>;
  /** Deletes a single `Component` using a unique key. */
  deleteComponentBySlug?: Maybe<DeleteComponentPayload>;
  /** Deletes a single `ComponentEvent` using a unique key. */
  deleteComponentEvent?: Maybe<DeleteComponentEventPayload>;
  /** Deletes a single `ComponentEvent` using its globally unique id. */
  deleteComponentEventByNodeId?: Maybe<DeleteComponentEventPayload>;
  /** Deletes a single `ComponentProperty` using a unique key. */
  deleteComponentProperty?: Maybe<DeleteComponentPropertyPayload>;
  /** Deletes a single `ComponentProperty` using its globally unique id. */
  deleteComponentPropertyByNodeId?: Maybe<DeleteComponentPropertyPayload>;
  /** Deletes a single `Course` using a unique key. */
  deleteCourse?: Maybe<DeleteCoursePayload>;
  /** Deletes a single `Course` using its globally unique id. */
  deleteCourseByNodeId?: Maybe<DeleteCoursePayload>;
  /** Deletes a single `Datatype` using a unique key. */
  deleteDatatype?: Maybe<DeleteDatatypePayload>;
  /** Deletes a single `Datatype` using a unique key. */
  deleteDatatypeByDescription?: Maybe<DeleteDatatypePayload>;
  /** Deletes a single `Datatype` using its globally unique id. */
  deleteDatatypeByNodeId?: Maybe<DeleteDatatypePayload>;
  /** Deletes a single `Equipment` using a unique key. */
  deleteEquipment?: Maybe<DeleteEquipmentPayload>;
  /** Deletes a single `Equipment` using a unique key. */
  deleteEquipmentByName?: Maybe<DeleteEquipmentPayload>;
  /** Deletes a single `Equipment` using its globally unique id. */
  deleteEquipmentByNodeId?: Maybe<DeleteEquipmentPayload>;
  /** Deletes a single `EquipmentType` using a unique key. */
  deleteEquipmentType?: Maybe<DeleteEquipmentTypePayload>;
  /** Deletes a single `EquipmentType` using its globally unique id. */
  deleteEquipmentTypeByNodeId?: Maybe<DeleteEquipmentTypePayload>;
  /** Deletes a single `ErrorReport` using a unique key. */
  deleteErrorReport?: Maybe<DeleteErrorReportPayload>;
  /** Deletes a single `ErrorReport` using its globally unique id. */
  deleteErrorReportByNodeId?: Maybe<DeleteErrorReportPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEvent?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEventByDescription?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using its globally unique id. */
  deleteEventByNodeId?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEventBySlug?: Maybe<DeleteEventPayload>;
  /** Deletes a single `FailedJob` using a unique key. */
  deleteFailedJob?: Maybe<DeleteFailedJobPayload>;
  /** Deletes a single `FailedJob` using its globally unique id. */
  deleteFailedJobByNodeId?: Maybe<DeleteFailedJobPayload>;
  /** Deletes a single `FailedJob` using a unique key. */
  deleteFailedJobByUuid?: Maybe<DeleteFailedJobPayload>;
  /** Deletes a single `Field` using a unique key. */
  deleteField?: Maybe<DeleteFieldPayload>;
  /** Deletes a single `FieldAction` using a unique key. */
  deleteFieldAction?: Maybe<DeleteFieldActionPayload>;
  /** Deletes a single `FieldAction` using its globally unique id. */
  deleteFieldActionByNodeId?: Maybe<DeleteFieldActionPayload>;
  /** Deletes a single `Field` using its globally unique id. */
  deleteFieldByNodeId?: Maybe<DeleteFieldPayload>;
  /** Deletes a single `FieldProperty` using a unique key. */
  deleteFieldProperty?: Maybe<DeleteFieldPropertyPayload>;
  /** Deletes a single `FieldProperty` using its globally unique id. */
  deleteFieldPropertyByNodeId?: Maybe<DeleteFieldPropertyPayload>;
  /** Deletes a single `FieldTranslation` using a unique key. */
  deleteFieldTranslation?: Maybe<DeleteFieldTranslationPayload>;
  /** Deletes a single `FieldTranslation` using its globally unique id. */
  deleteFieldTranslationByNodeId?: Maybe<DeleteFieldTranslationPayload>;
  /** Deletes a single `FillupForm` using a unique key. */
  deleteFillupForm?: Maybe<DeleteFillupFormPayload>;
  /** Deletes a single `FillupForm` using its globally unique id. */
  deleteFillupFormByNodeId?: Maybe<DeleteFillupFormPayload>;
  /** Deletes a single `FillupFormField` using a unique key. */
  deleteFillupFormField?: Maybe<DeleteFillupFormFieldPayload>;
  /** Deletes a single `FillupFormField` using its globally unique id. */
  deleteFillupFormFieldByNodeId?: Maybe<DeleteFillupFormFieldPayload>;
  /** Deletes a single `Form` using a unique key. */
  deleteForm?: Maybe<DeleteFormPayload>;
  /** Deletes a single `Form` using its globally unique id. */
  deleteFormByNodeId?: Maybe<DeleteFormPayload>;
  /** Deletes a single `FormOrganization` using a unique key. */
  deleteFormOrganization?: Maybe<DeleteFormOrganizationPayload>;
  /** Deletes a single `FormOrganization` using its globally unique id. */
  deleteFormOrganizationByNodeId?: Maybe<DeleteFormOrganizationPayload>;
  /** Deletes a single `FormTemplate` using a unique key. */
  deleteFormTemplate?: Maybe<DeleteFormTemplatePayload>;
  /** Deletes a single `FormTemplate` using its globally unique id. */
  deleteFormTemplateByNodeId?: Maybe<DeleteFormTemplatePayload>;
  /** Deletes a single `FormTemplateGroup` using a unique key. */
  deleteFormTemplateGroup?: Maybe<DeleteFormTemplateGroupPayload>;
  /** Deletes a single `FormTemplateGroup` using its globally unique id. */
  deleteFormTemplateGroupByNodeId?: Maybe<DeleteFormTemplateGroupPayload>;
  /** Deletes a single `FormTemplateOrganization` using a unique key. */
  deleteFormTemplateOrganization?: Maybe<DeleteFormTemplateOrganizationPayload>;
  /** Deletes a single `FormTemplateOrganization` using its globally unique id. */
  deleteFormTemplateOrganizationByNodeId?: Maybe<DeleteFormTemplateOrganizationPayload>;
  /** Deletes a single `FormTemplateProject` using a unique key. */
  deleteFormTemplateProject?: Maybe<DeleteFormTemplateProjectPayload>;
  /** Deletes a single `FormTemplateProject` using its globally unique id. */
  deleteFormTemplateProjectByNodeId?: Maybe<DeleteFormTemplateProjectPayload>;
  /** Deletes a single `FormTemplateTeam` using a unique key. */
  deleteFormTemplateTeam?: Maybe<DeleteFormTemplateTeamPayload>;
  /** Deletes a single `FormTemplateTeam` using its globally unique id. */
  deleteFormTemplateTeamByNodeId?: Maybe<DeleteFormTemplateTeamPayload>;
  /** Deletes a single `FormTemplateUser` using a unique key. */
  deleteFormTemplateUser?: Maybe<DeleteFormTemplateUserPayload>;
  /** Deletes a single `FormTemplateUser` using its globally unique id. */
  deleteFormTemplateUserByNodeId?: Maybe<DeleteFormTemplateUserPayload>;
  /** Deletes a single `FormUser` using a unique key. */
  deleteFormUser?: Maybe<DeleteFormUserPayload>;
  /** Deletes a single `FormUser` using its globally unique id. */
  deleteFormUserByNodeId?: Maybe<DeleteFormUserPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroupByNodeId?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Issuance` using a unique key. */
  deleteIssuance?: Maybe<DeleteIssuancePayload>;
  /** Deletes a single `Issuance` using a unique key. */
  deleteIssuanceByEquipmentIdAndSerialNumber?: Maybe<DeleteIssuancePayload>;
  /** Deletes a single `Issuance` using its globally unique id. */
  deleteIssuanceByNodeId?: Maybe<DeleteIssuancePayload>;
  /** Deletes a single `Job` using a unique key. */
  deleteJob?: Maybe<DeleteJobPayload>;
  /** Deletes a single `Job` using its globally unique id. */
  deleteJobByNodeId?: Maybe<DeleteJobPayload>;
  /** Deletes a single `JobSendingEmail` using a unique key. */
  deleteJobSendingEmail?: Maybe<DeleteJobSendingEmailPayload>;
  /** Deletes a single `JobSendingEmail` using its globally unique id. */
  deleteJobSendingEmailByNodeId?: Maybe<DeleteJobSendingEmailPayload>;
  /** Deletes a single `JobSendingEmailCategory` using a unique key. */
  deleteJobSendingEmailCategory?: Maybe<DeleteJobSendingEmailCategoryPayload>;
  /** Deletes a single `JobSendingEmailCategory` using its globally unique id. */
  deleteJobSendingEmailCategoryByNodeId?: Maybe<DeleteJobSendingEmailCategoryPayload>;
  /** Deletes a single `JobSendingEmailLog` using a unique key. */
  deleteJobSendingEmailLog?: Maybe<DeleteJobSendingEmailLogPayload>;
  /** Deletes a single `JobSendingEmailLog` using its globally unique id. */
  deleteJobSendingEmailLogByNodeId?: Maybe<DeleteJobSendingEmailLogPayload>;
  /** Deletes a single `Kind` using a unique key. */
  deleteKind?: Maybe<DeleteKindPayload>;
  /** Deletes a single `Kind` using a unique key. */
  deleteKindByDescription?: Maybe<DeleteKindPayload>;
  /** Deletes a single `Kind` using its globally unique id. */
  deleteKindByNodeId?: Maybe<DeleteKindPayload>;
  /** Deletes a single `Kind` using a unique key. */
  deleteKindBySlug?: Maybe<DeleteKindPayload>;
  /** Deletes a single `Language` using a unique key. */
  deleteLanguage?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `Language` using its globally unique id. */
  deleteLanguageByNodeId?: Maybe<DeleteLanguagePayload>;
  /** Deletes a single `LoginTransaction` using a unique key. */
  deleteLoginTransaction?: Maybe<DeleteLoginTransactionPayload>;
  /** Deletes a single `LoginTransaction` using its globally unique id. */
  deleteLoginTransactionByNodeId?: Maybe<DeleteLoginTransactionPayload>;
  /** Deletes a single `Metric` using a unique key. */
  deleteMetric?: Maybe<DeleteMetricPayload>;
  /** Deletes a single `Metric` using its globally unique id. */
  deleteMetricByNodeId?: Maybe<DeleteMetricPayload>;
  /** Deletes a single `Migration` using a unique key. */
  deleteMigration?: Maybe<DeleteMigrationPayload>;
  /** Deletes a single `Migration` using its globally unique id. */
  deleteMigrationByNodeId?: Maybe<DeleteMigrationPayload>;
  /** Deletes a single `News` using a unique key. */
  deleteNews?: Maybe<DeleteNewsPayload>;
  /** Deletes a single `News` using its globally unique id. */
  deleteNewsByNodeId?: Maybe<DeleteNewsPayload>;
  /** Deletes a single `Organization` using a unique key. */
  deleteOrganization?: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `Organization` using its globally unique id. */
  deleteOrganizationByNodeId?: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `OrganizationUser` using a unique key. */
  deleteOrganizationUser?: Maybe<DeleteOrganizationUserPayload>;
  /** Deletes a single `OrganizationUser` using its globally unique id. */
  deleteOrganizationUserByNodeId?: Maybe<DeleteOrganizationUserPayload>;
  /** Deletes a single `PersonalAccessToken` using a unique key. */
  deletePersonalAccessToken?: Maybe<DeletePersonalAccessTokenPayload>;
  /** Deletes a single `PersonalAccessToken` using its globally unique id. */
  deletePersonalAccessTokenByNodeId?: Maybe<DeletePersonalAccessTokenPayload>;
  /** Deletes a single `PersonalAccessToken` using a unique key. */
  deletePersonalAccessTokenByToken?: Maybe<DeletePersonalAccessTokenPayload>;
  /** Deletes a single `Profile` using a unique key. */
  deleteProfile?: Maybe<DeleteProfilePayload>;
  /** Deletes a single `Profile` using its globally unique id. */
  deleteProfileByNodeId?: Maybe<DeleteProfilePayload>;
  /** Deletes a single `Project` using a unique key. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `Project` using its globally unique id. */
  deleteProjectByNodeId?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `ProjectUser` using a unique key. */
  deleteProjectUser?: Maybe<DeleteProjectUserPayload>;
  /** Deletes a single `ProjectUser` using its globally unique id. */
  deleteProjectUserByNodeId?: Maybe<DeleteProjectUserPayload>;
  /** Deletes a single `Property` using a unique key. */
  deleteProperty?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Property` using a unique key. */
  deletePropertyByDescription?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Property` using a unique key. */
  deletePropertyByHint?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Property` using its globally unique id. */
  deletePropertyByNodeId?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Property` using a unique key. */
  deletePropertyBySlug?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Role` using a unique key. */
  deleteRole?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Role` using a unique key. */
  deleteRoleByName?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Role` using its globally unique id. */
  deleteRoleByNodeId?: Maybe<DeleteRolePayload>;
  /** Deletes a single `RoleUser` using a unique key. */
  deleteRoleUser?: Maybe<DeleteRoleUserPayload>;
  /** Deletes a single `RoleUser` using its globally unique id. */
  deleteRoleUserByNodeId?: Maybe<DeleteRoleUserPayload>;
  /** Deletes a single `RoleUserOrganization` using a unique key. */
  deleteRoleUserOrganization?: Maybe<DeleteRoleUserOrganizationPayload>;
  /** Deletes a single `RoleUserOrganization` using its globally unique id. */
  deleteRoleUserOrganizationByNodeId?: Maybe<DeleteRoleUserOrganizationPayload>;
  /** Deletes a single `Scheduler` using a unique key. */
  deleteScheduler?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `Scheduler` using its globally unique id. */
  deleteSchedulerByNodeId?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `SchedulerField` using a unique key. */
  deleteSchedulerField?: Maybe<DeleteSchedulerFieldPayload>;
  /** Deletes a single `SchedulerField` using its globally unique id. */
  deleteSchedulerFieldByNodeId?: Maybe<DeleteSchedulerFieldPayload>;
  /** Deletes a single `SentMail` using a unique key. */
  deleteSentMail?: Maybe<DeleteSentMailPayload>;
  /** Deletes a single `SentMail` using its globally unique id. */
  deleteSentMailByNodeId?: Maybe<DeleteSentMailPayload>;
  /** Deletes a single `Session` using a unique key. */
  deleteSession?: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Session` using its globally unique id. */
  deleteSessionByNodeId?: Maybe<DeleteSessionPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSetting?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSettingByDescription?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSettingByNodeId?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `SettingGroup` using a unique key. */
  deleteSettingGroup?: Maybe<DeleteSettingGroupPayload>;
  /** Deletes a single `SettingGroup` using a unique key. */
  deleteSettingGroupByDescription?: Maybe<DeleteSettingGroupPayload>;
  /** Deletes a single `SettingGroup` using its globally unique id. */
  deleteSettingGroupByNodeId?: Maybe<DeleteSettingGroupPayload>;
  /** Deletes a single `Subscription` using a unique key. */
  deleteSubscription?: Maybe<DeleteSubscriptionPayload>;
  /** Deletes a single `Subscription` using its globally unique id. */
  deleteSubscriptionByNodeId?: Maybe<DeleteSubscriptionPayload>;
  /** Deletes a single `SubscriptionItem` using a unique key. */
  deleteSubscriptionItem?: Maybe<DeleteSubscriptionItemPayload>;
  /** Deletes a single `SubscriptionItem` using its globally unique id. */
  deleteSubscriptionItemByNodeId?: Maybe<DeleteSubscriptionItemPayload>;
  /** Deletes a single `SubscriptionItem` using a unique key. */
  deleteSubscriptionItemBySubscriptionIdAndStripePlan?: Maybe<DeleteSubscriptionItemPayload>;
  /** Deletes a single `SystemEvent` using a unique key. */
  deleteSystemEvent?: Maybe<DeleteSystemEventPayload>;
  /** Deletes a single `SystemEvent` using its globally unique id. */
  deleteSystemEventByNodeId?: Maybe<DeleteSystemEventPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeam?: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using its globally unique id. */
  deleteTeamByNodeId?: Maybe<DeleteTeamPayload>;
  /** Deletes a single `TelescopeEntry` using a unique key. */
  deleteTelescopeEntry?: Maybe<DeleteTelescopeEntryPayload>;
  /** Deletes a single `TelescopeEntry` using its globally unique id. */
  deleteTelescopeEntryByNodeId?: Maybe<DeleteTelescopeEntryPayload>;
  /** Deletes a single `TelescopeEntry` using a unique key. */
  deleteTelescopeEntryByUuid?: Maybe<DeleteTelescopeEntryPayload>;
  /** Deletes a single `Tool` using a unique key. */
  deleteTool?: Maybe<DeleteToolPayload>;
  /** Deletes a single `Tool` using its globally unique id. */
  deleteToolByNodeId?: Maybe<DeleteToolPayload>;
  /** Deletes a single `Tooltype` using a unique key. */
  deleteTooltype?: Maybe<DeleteTooltypePayload>;
  /** Deletes a single `Tooltype` using its globally unique id. */
  deleteTooltypeByNodeId?: Maybe<DeleteTooltypePayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByFacebookId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByGoogleId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserInvite` using a unique key. */
  deleteUserInvite?: Maybe<DeleteUserInvitePayload>;
  /** Deletes a single `UserInvite` using its globally unique id. */
  deleteUserInviteByNodeId?: Maybe<DeleteUserInvitePayload>;
  /** Deletes a single `UserInvite` using a unique key. */
  deleteUserInviteByToken?: Maybe<DeleteUserInvitePayload>;
  /** Deletes a single `UserSetting` using a unique key. */
  deleteUserSetting?: Maybe<DeleteUserSettingPayload>;
  /** Deletes a single `UserSetting` using its globally unique id. */
  deleteUserSettingByNodeId?: Maybe<DeleteUserSettingPayload>;
  /** Deletes a single `VerificationToken` using a unique key. */
  deleteVerificationToken?: Maybe<DeleteVerificationTokenPayload>;
  /** Deletes a single `VerificationToken` using its globally unique id. */
  deleteVerificationTokenByNodeId?: Maybe<DeleteVerificationTokenPayload>;
  /** Deletes a single `VerificationTokenType` using a unique key. */
  deleteVerificationTokenType?: Maybe<DeleteVerificationTokenTypePayload>;
  /** Deletes a single `VerificationTokenType` using its globally unique id. */
  deleteVerificationTokenTypeByNodeId?: Maybe<DeleteVerificationTokenTypePayload>;
  /** Deletes a single `WebsocketsStatisticsEntry` using a unique key. */
  deleteWebsocketsStatisticsEntry?: Maybe<DeleteWebsocketsStatisticsEntryPayload>;
  /** Deletes a single `WebsocketsStatisticsEntry` using its globally unique id. */
  deleteWebsocketsStatisticsEntryByNodeId?: Maybe<DeleteWebsocketsStatisticsEntryPayload>;
  /** Deletes a single `WorkType` using a unique key. */
  deleteWorkType?: Maybe<DeleteWorkTypePayload>;
  /** Deletes a single `WorkType` using its globally unique id. */
  deleteWorkTypeByNodeId?: Maybe<DeleteWorkTypePayload>;
  /** Updates a single `Ability` using a unique key and a patch. */
  updateAbility?: Maybe<UpdateAbilityPayload>;
  /** Updates a single `Ability` using its globally unique id and a patch. */
  updateAbilityByNodeId?: Maybe<UpdateAbilityPayload>;
  /** Updates a single `AbilityRole` using a unique key and a patch. */
  updateAbilityRole?: Maybe<UpdateAbilityRolePayload>;
  /** Updates a single `AbilityRole` using its globally unique id and a patch. */
  updateAbilityRoleByNodeId?: Maybe<UpdateAbilityRolePayload>;
  /** Updates a single `Admin` using a unique key and a patch. */
  updateAdmin?: Maybe<UpdateAdminPayload>;
  /** Updates a single `Admin` using its globally unique id and a patch. */
  updateAdminByNodeId?: Maybe<UpdateAdminPayload>;
  /** Updates a single `AllowedSettingValue` using a unique key and a patch. */
  updateAllowedSettingValue?: Maybe<UpdateAllowedSettingValuePayload>;
  /** Updates a single `AllowedSettingValue` using its globally unique id and a patch. */
  updateAllowedSettingValueByNodeId?: Maybe<UpdateAllowedSettingValuePayload>;
  /** Updates a single `Attachment` using a unique key and a patch. */
  updateAttachment?: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `Attachment` using its globally unique id and a patch. */
  updateAttachmentByNodeId?: Maybe<UpdateAttachmentPayload>;
  /** Updates a single `Certification` using a unique key and a patch. */
  updateCertification?: Maybe<UpdateCertificationPayload>;
  /** Updates a single `Certification` using its globally unique id and a patch. */
  updateCertificationByNodeId?: Maybe<UpdateCertificationPayload>;
  /** Updates a single `Company` using a unique key and a patch. */
  updateCompany?: Maybe<UpdateCompanyPayload>;
  /** Updates a single `Company` using its globally unique id and a patch. */
  updateCompanyByNodeId?: Maybe<UpdateCompanyPayload>;
  /** Updates a single `Component` using a unique key and a patch. */
  updateComponent?: Maybe<UpdateComponentPayload>;
  /** Updates a single `Component` using a unique key and a patch. */
  updateComponentByDescription?: Maybe<UpdateComponentPayload>;
  /** Updates a single `Component` using its globally unique id and a patch. */
  updateComponentByNodeId?: Maybe<UpdateComponentPayload>;
  /** Updates a single `Component` using a unique key and a patch. */
  updateComponentBySlug?: Maybe<UpdateComponentPayload>;
  /** Updates a single `ComponentEvent` using a unique key and a patch. */
  updateComponentEvent?: Maybe<UpdateComponentEventPayload>;
  /** Updates a single `ComponentEvent` using its globally unique id and a patch. */
  updateComponentEventByNodeId?: Maybe<UpdateComponentEventPayload>;
  /** Updates a single `ComponentProperty` using a unique key and a patch. */
  updateComponentProperty?: Maybe<UpdateComponentPropertyPayload>;
  /** Updates a single `ComponentProperty` using its globally unique id and a patch. */
  updateComponentPropertyByNodeId?: Maybe<UpdateComponentPropertyPayload>;
  /** Updates a single `Course` using a unique key and a patch. */
  updateCourse?: Maybe<UpdateCoursePayload>;
  /** Updates a single `Course` using its globally unique id and a patch. */
  updateCourseByNodeId?: Maybe<UpdateCoursePayload>;
  /** Updates a single `Datatype` using a unique key and a patch. */
  updateDatatype?: Maybe<UpdateDatatypePayload>;
  /** Updates a single `Datatype` using a unique key and a patch. */
  updateDatatypeByDescription?: Maybe<UpdateDatatypePayload>;
  /** Updates a single `Datatype` using its globally unique id and a patch. */
  updateDatatypeByNodeId?: Maybe<UpdateDatatypePayload>;
  /** Updates a single `Equipment` using a unique key and a patch. */
  updateEquipment?: Maybe<UpdateEquipmentPayload>;
  /** Updates a single `Equipment` using a unique key and a patch. */
  updateEquipmentByName?: Maybe<UpdateEquipmentPayload>;
  /** Updates a single `Equipment` using its globally unique id and a patch. */
  updateEquipmentByNodeId?: Maybe<UpdateEquipmentPayload>;
  /** Updates a single `EquipmentType` using a unique key and a patch. */
  updateEquipmentType?: Maybe<UpdateEquipmentTypePayload>;
  /** Updates a single `EquipmentType` using its globally unique id and a patch. */
  updateEquipmentTypeByNodeId?: Maybe<UpdateEquipmentTypePayload>;
  /** Updates a single `ErrorReport` using a unique key and a patch. */
  updateErrorReport?: Maybe<UpdateErrorReportPayload>;
  /** Updates a single `ErrorReport` using its globally unique id and a patch. */
  updateErrorReportByNodeId?: Maybe<UpdateErrorReportPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEvent?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEventByDescription?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEventByNodeId?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEventBySlug?: Maybe<UpdateEventPayload>;
  /** Updates a single `FailedJob` using a unique key and a patch. */
  updateFailedJob?: Maybe<UpdateFailedJobPayload>;
  /** Updates a single `FailedJob` using its globally unique id and a patch. */
  updateFailedJobByNodeId?: Maybe<UpdateFailedJobPayload>;
  /** Updates a single `FailedJob` using a unique key and a patch. */
  updateFailedJobByUuid?: Maybe<UpdateFailedJobPayload>;
  /** Updates a single `Field` using a unique key and a patch. */
  updateField?: Maybe<UpdateFieldPayload>;
  /** Updates a single `FieldAction` using a unique key and a patch. */
  updateFieldAction?: Maybe<UpdateFieldActionPayload>;
  /** Updates a single `FieldAction` using its globally unique id and a patch. */
  updateFieldActionByNodeId?: Maybe<UpdateFieldActionPayload>;
  /** Updates a single `Field` using its globally unique id and a patch. */
  updateFieldByNodeId?: Maybe<UpdateFieldPayload>;
  /** Updates a single `FieldProperty` using a unique key and a patch. */
  updateFieldProperty?: Maybe<UpdateFieldPropertyPayload>;
  /** Updates a single `FieldProperty` using its globally unique id and a patch. */
  updateFieldPropertyByNodeId?: Maybe<UpdateFieldPropertyPayload>;
  /** Updates a single `FieldTranslation` using a unique key and a patch. */
  updateFieldTranslation?: Maybe<UpdateFieldTranslationPayload>;
  /** Updates a single `FieldTranslation` using its globally unique id and a patch. */
  updateFieldTranslationByNodeId?: Maybe<UpdateFieldTranslationPayload>;
  /** Updates a single `FillupForm` using a unique key and a patch. */
  updateFillupForm?: Maybe<UpdateFillupFormPayload>;
  /** Updates a single `FillupForm` using its globally unique id and a patch. */
  updateFillupFormByNodeId?: Maybe<UpdateFillupFormPayload>;
  /** Updates a single `FillupFormField` using a unique key and a patch. */
  updateFillupFormField?: Maybe<UpdateFillupFormFieldPayload>;
  /** Updates a single `FillupFormField` using its globally unique id and a patch. */
  updateFillupFormFieldByNodeId?: Maybe<UpdateFillupFormFieldPayload>;
  /** Updates a single `Form` using a unique key and a patch. */
  updateForm?: Maybe<UpdateFormPayload>;
  /** Updates a single `Form` using its globally unique id and a patch. */
  updateFormByNodeId?: Maybe<UpdateFormPayload>;
  /** Updates a single `FormOrganization` using a unique key and a patch. */
  updateFormOrganization?: Maybe<UpdateFormOrganizationPayload>;
  /** Updates a single `FormOrganization` using its globally unique id and a patch. */
  updateFormOrganizationByNodeId?: Maybe<UpdateFormOrganizationPayload>;
  /** Updates a single `FormTemplate` using a unique key and a patch. */
  updateFormTemplate?: Maybe<UpdateFormTemplatePayload>;
  /** Updates a single `FormTemplate` using its globally unique id and a patch. */
  updateFormTemplateByNodeId?: Maybe<UpdateFormTemplatePayload>;
  /** Updates a single `FormTemplateGroup` using a unique key and a patch. */
  updateFormTemplateGroup?: Maybe<UpdateFormTemplateGroupPayload>;
  /** Updates a single `FormTemplateGroup` using its globally unique id and a patch. */
  updateFormTemplateGroupByNodeId?: Maybe<UpdateFormTemplateGroupPayload>;
  /** Updates a single `FormTemplateOrganization` using a unique key and a patch. */
  updateFormTemplateOrganization?: Maybe<UpdateFormTemplateOrganizationPayload>;
  /** Updates a single `FormTemplateOrganization` using its globally unique id and a patch. */
  updateFormTemplateOrganizationByNodeId?: Maybe<UpdateFormTemplateOrganizationPayload>;
  /** Updates a single `FormTemplateProject` using a unique key and a patch. */
  updateFormTemplateProject?: Maybe<UpdateFormTemplateProjectPayload>;
  /** Updates a single `FormTemplateProject` using its globally unique id and a patch. */
  updateFormTemplateProjectByNodeId?: Maybe<UpdateFormTemplateProjectPayload>;
  /** Updates a single `FormTemplateTeam` using a unique key and a patch. */
  updateFormTemplateTeam?: Maybe<UpdateFormTemplateTeamPayload>;
  /** Updates a single `FormTemplateTeam` using its globally unique id and a patch. */
  updateFormTemplateTeamByNodeId?: Maybe<UpdateFormTemplateTeamPayload>;
  /** Updates a single `FormTemplateUser` using a unique key and a patch. */
  updateFormTemplateUser?: Maybe<UpdateFormTemplateUserPayload>;
  /** Updates a single `FormTemplateUser` using its globally unique id and a patch. */
  updateFormTemplateUserByNodeId?: Maybe<UpdateFormTemplateUserPayload>;
  /** Updates a single `FormUser` using a unique key and a patch. */
  updateFormUser?: Maybe<UpdateFormUserPayload>;
  /** Updates a single `FormUser` using its globally unique id and a patch. */
  updateFormUserByNodeId?: Maybe<UpdateFormUserPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup?: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroupByNodeId?: Maybe<UpdateGroupPayload>;
  /** Updates a single `Issuance` using a unique key and a patch. */
  updateIssuance?: Maybe<UpdateIssuancePayload>;
  /** Updates a single `Issuance` using a unique key and a patch. */
  updateIssuanceByEquipmentIdAndSerialNumber?: Maybe<UpdateIssuancePayload>;
  /** Updates a single `Issuance` using its globally unique id and a patch. */
  updateIssuanceByNodeId?: Maybe<UpdateIssuancePayload>;
  /** Updates a single `Job` using a unique key and a patch. */
  updateJob?: Maybe<UpdateJobPayload>;
  /** Updates a single `Job` using its globally unique id and a patch. */
  updateJobByNodeId?: Maybe<UpdateJobPayload>;
  /** Updates a single `JobSendingEmail` using a unique key and a patch. */
  updateJobSendingEmail?: Maybe<UpdateJobSendingEmailPayload>;
  /** Updates a single `JobSendingEmail` using its globally unique id and a patch. */
  updateJobSendingEmailByNodeId?: Maybe<UpdateJobSendingEmailPayload>;
  /** Updates a single `JobSendingEmailCategory` using a unique key and a patch. */
  updateJobSendingEmailCategory?: Maybe<UpdateJobSendingEmailCategoryPayload>;
  /** Updates a single `JobSendingEmailCategory` using its globally unique id and a patch. */
  updateJobSendingEmailCategoryByNodeId?: Maybe<UpdateJobSendingEmailCategoryPayload>;
  /** Updates a single `JobSendingEmailLog` using a unique key and a patch. */
  updateJobSendingEmailLog?: Maybe<UpdateJobSendingEmailLogPayload>;
  /** Updates a single `JobSendingEmailLog` using its globally unique id and a patch. */
  updateJobSendingEmailLogByNodeId?: Maybe<UpdateJobSendingEmailLogPayload>;
  /** Updates a single `Kind` using a unique key and a patch. */
  updateKind?: Maybe<UpdateKindPayload>;
  /** Updates a single `Kind` using a unique key and a patch. */
  updateKindByDescription?: Maybe<UpdateKindPayload>;
  /** Updates a single `Kind` using its globally unique id and a patch. */
  updateKindByNodeId?: Maybe<UpdateKindPayload>;
  /** Updates a single `Kind` using a unique key and a patch. */
  updateKindBySlug?: Maybe<UpdateKindPayload>;
  /** Updates a single `Language` using a unique key and a patch. */
  updateLanguage?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `Language` using its globally unique id and a patch. */
  updateLanguageByNodeId?: Maybe<UpdateLanguagePayload>;
  /** Updates a single `LoginTransaction` using a unique key and a patch. */
  updateLoginTransaction?: Maybe<UpdateLoginTransactionPayload>;
  /** Updates a single `LoginTransaction` using its globally unique id and a patch. */
  updateLoginTransactionByNodeId?: Maybe<UpdateLoginTransactionPayload>;
  /** Updates a single `Metric` using a unique key and a patch. */
  updateMetric?: Maybe<UpdateMetricPayload>;
  /** Updates a single `Metric` using its globally unique id and a patch. */
  updateMetricByNodeId?: Maybe<UpdateMetricPayload>;
  /** Updates a single `Migration` using a unique key and a patch. */
  updateMigration?: Maybe<UpdateMigrationPayload>;
  /** Updates a single `Migration` using its globally unique id and a patch. */
  updateMigrationByNodeId?: Maybe<UpdateMigrationPayload>;
  /** Updates a single `News` using a unique key and a patch. */
  updateNews?: Maybe<UpdateNewsPayload>;
  /** Updates a single `News` using its globally unique id and a patch. */
  updateNewsByNodeId?: Maybe<UpdateNewsPayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganization?: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using its globally unique id and a patch. */
  updateOrganizationByNodeId?: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `OrganizationUser` using a unique key and a patch. */
  updateOrganizationUser?: Maybe<UpdateOrganizationUserPayload>;
  /** Updates a single `OrganizationUser` using its globally unique id and a patch. */
  updateOrganizationUserByNodeId?: Maybe<UpdateOrganizationUserPayload>;
  /** Updates a single `PersonalAccessToken` using a unique key and a patch. */
  updatePersonalAccessToken?: Maybe<UpdatePersonalAccessTokenPayload>;
  /** Updates a single `PersonalAccessToken` using its globally unique id and a patch. */
  updatePersonalAccessTokenByNodeId?: Maybe<UpdatePersonalAccessTokenPayload>;
  /** Updates a single `PersonalAccessToken` using a unique key and a patch. */
  updatePersonalAccessTokenByToken?: Maybe<UpdatePersonalAccessTokenPayload>;
  /** Updates a single `Profile` using a unique key and a patch. */
  updateProfile?: Maybe<UpdateProfilePayload>;
  /** Updates a single `Profile` using its globally unique id and a patch. */
  updateProfileByNodeId?: Maybe<UpdateProfilePayload>;
  /** Updates a single `Project` using a unique key and a patch. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates a single `Project` using its globally unique id and a patch. */
  updateProjectByNodeId?: Maybe<UpdateProjectPayload>;
  /** Updates a single `ProjectUser` using a unique key and a patch. */
  updateProjectUser?: Maybe<UpdateProjectUserPayload>;
  /** Updates a single `ProjectUser` using its globally unique id and a patch. */
  updateProjectUserByNodeId?: Maybe<UpdateProjectUserPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updateProperty?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updatePropertyByDescription?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updatePropertyByHint?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Property` using its globally unique id and a patch. */
  updatePropertyByNodeId?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updatePropertyBySlug?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Role` using a unique key and a patch. */
  updateRole?: Maybe<UpdateRolePayload>;
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleByName?: Maybe<UpdateRolePayload>;
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRoleByNodeId?: Maybe<UpdateRolePayload>;
  /** Updates a single `RoleUser` using a unique key and a patch. */
  updateRoleUser?: Maybe<UpdateRoleUserPayload>;
  /** Updates a single `RoleUser` using its globally unique id and a patch. */
  updateRoleUserByNodeId?: Maybe<UpdateRoleUserPayload>;
  /** Updates a single `RoleUserOrganization` using a unique key and a patch. */
  updateRoleUserOrganization?: Maybe<UpdateRoleUserOrganizationPayload>;
  /** Updates a single `RoleUserOrganization` using its globally unique id and a patch. */
  updateRoleUserOrganizationByNodeId?: Maybe<UpdateRoleUserOrganizationPayload>;
  /** Updates a single `Scheduler` using a unique key and a patch. */
  updateScheduler?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `Scheduler` using its globally unique id and a patch. */
  updateSchedulerByNodeId?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `SchedulerField` using a unique key and a patch. */
  updateSchedulerField?: Maybe<UpdateSchedulerFieldPayload>;
  /** Updates a single `SchedulerField` using its globally unique id and a patch. */
  updateSchedulerFieldByNodeId?: Maybe<UpdateSchedulerFieldPayload>;
  /** Updates a single `SentMail` using a unique key and a patch. */
  updateSentMail?: Maybe<UpdateSentMailPayload>;
  /** Updates a single `SentMail` using its globally unique id and a patch. */
  updateSentMailByNodeId?: Maybe<UpdateSentMailPayload>;
  /** Updates a single `Session` using a unique key and a patch. */
  updateSession?: Maybe<UpdateSessionPayload>;
  /** Updates a single `Session` using its globally unique id and a patch. */
  updateSessionByNodeId?: Maybe<UpdateSessionPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSetting?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSettingByDescription?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSettingByNodeId?: Maybe<UpdateSettingPayload>;
  /** Updates a single `SettingGroup` using a unique key and a patch. */
  updateSettingGroup?: Maybe<UpdateSettingGroupPayload>;
  /** Updates a single `SettingGroup` using a unique key and a patch. */
  updateSettingGroupByDescription?: Maybe<UpdateSettingGroupPayload>;
  /** Updates a single `SettingGroup` using its globally unique id and a patch. */
  updateSettingGroupByNodeId?: Maybe<UpdateSettingGroupPayload>;
  /** Updates a single `Subscription` using a unique key and a patch. */
  updateSubscription?: Maybe<UpdateSubscriptionPayload>;
  /** Updates a single `Subscription` using its globally unique id and a patch. */
  updateSubscriptionByNodeId?: Maybe<UpdateSubscriptionPayload>;
  /** Updates a single `SubscriptionItem` using a unique key and a patch. */
  updateSubscriptionItem?: Maybe<UpdateSubscriptionItemPayload>;
  /** Updates a single `SubscriptionItem` using its globally unique id and a patch. */
  updateSubscriptionItemByNodeId?: Maybe<UpdateSubscriptionItemPayload>;
  /** Updates a single `SubscriptionItem` using a unique key and a patch. */
  updateSubscriptionItemBySubscriptionIdAndStripePlan?: Maybe<UpdateSubscriptionItemPayload>;
  /** Updates a single `SystemEvent` using a unique key and a patch. */
  updateSystemEvent?: Maybe<UpdateSystemEventPayload>;
  /** Updates a single `SystemEvent` using its globally unique id and a patch. */
  updateSystemEventByNodeId?: Maybe<UpdateSystemEventPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeam?: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using its globally unique id and a patch. */
  updateTeamByNodeId?: Maybe<UpdateTeamPayload>;
  /** Updates a single `TelescopeEntry` using a unique key and a patch. */
  updateTelescopeEntry?: Maybe<UpdateTelescopeEntryPayload>;
  /** Updates a single `TelescopeEntry` using its globally unique id and a patch. */
  updateTelescopeEntryByNodeId?: Maybe<UpdateTelescopeEntryPayload>;
  /** Updates a single `TelescopeEntry` using a unique key and a patch. */
  updateTelescopeEntryByUuid?: Maybe<UpdateTelescopeEntryPayload>;
  /** Updates a single `Tool` using a unique key and a patch. */
  updateTool?: Maybe<UpdateToolPayload>;
  /** Updates a single `Tool` using its globally unique id and a patch. */
  updateToolByNodeId?: Maybe<UpdateToolPayload>;
  /** Updates a single `Tooltype` using a unique key and a patch. */
  updateTooltype?: Maybe<UpdateTooltypePayload>;
  /** Updates a single `Tooltype` using its globally unique id and a patch. */
  updateTooltypeByNodeId?: Maybe<UpdateTooltypePayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByFacebookId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByGoogleId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserInvite` using a unique key and a patch. */
  updateUserInvite?: Maybe<UpdateUserInvitePayload>;
  /** Updates a single `UserInvite` using its globally unique id and a patch. */
  updateUserInviteByNodeId?: Maybe<UpdateUserInvitePayload>;
  /** Updates a single `UserInvite` using a unique key and a patch. */
  updateUserInviteByToken?: Maybe<UpdateUserInvitePayload>;
  /** Updates a single `UserSetting` using a unique key and a patch. */
  updateUserSetting?: Maybe<UpdateUserSettingPayload>;
  /** Updates a single `UserSetting` using its globally unique id and a patch. */
  updateUserSettingByNodeId?: Maybe<UpdateUserSettingPayload>;
  /** Updates a single `VerificationToken` using a unique key and a patch. */
  updateVerificationToken?: Maybe<UpdateVerificationTokenPayload>;
  /** Updates a single `VerificationToken` using its globally unique id and a patch. */
  updateVerificationTokenByNodeId?: Maybe<UpdateVerificationTokenPayload>;
  /** Updates a single `VerificationTokenType` using a unique key and a patch. */
  updateVerificationTokenType?: Maybe<UpdateVerificationTokenTypePayload>;
  /** Updates a single `VerificationTokenType` using its globally unique id and a patch. */
  updateVerificationTokenTypeByNodeId?: Maybe<UpdateVerificationTokenTypePayload>;
  /** Updates a single `WebsocketsStatisticsEntry` using a unique key and a patch. */
  updateWebsocketsStatisticsEntry?: Maybe<UpdateWebsocketsStatisticsEntryPayload>;
  /** Updates a single `WebsocketsStatisticsEntry` using its globally unique id and a patch. */
  updateWebsocketsStatisticsEntryByNodeId?: Maybe<UpdateWebsocketsStatisticsEntryPayload>;
  /** Updates a single `WorkType` using a unique key and a patch. */
  updateWorkType?: Maybe<UpdateWorkTypePayload>;
  /** Updates a single `WorkType` using its globally unique id and a patch. */
  updateWorkTypeByNodeId?: Maybe<UpdateWorkTypePayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAbilityArgs = {
  input: CreateAbilityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAbilityRoleArgs = {
  input: CreateAbilityRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAdminArgs = {
  input: CreateAdminInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAllowedSettingValueArgs = {
  input: CreateAllowedSettingValueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAttachmentArgs = {
  input: CreateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCertificationArgs = {
  input: CreateCertificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyArgs = {
  input: CreateCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCompanyUserArgs = {
  input: CreateCompanyUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateComponentArgs = {
  input: CreateComponentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateComponentEventArgs = {
  input: CreateComponentEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateComponentPropertyArgs = {
  input: CreateComponentPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCourseArgs = {
  input: CreateCourseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDatatypeArgs = {
  input: CreateDatatypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEquipmentArgs = {
  input: CreateEquipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEquipmentTypeArgs = {
  input: CreateEquipmentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateErrorReportArgs = {
  input: CreateErrorReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFailedJobArgs = {
  input: CreateFailedJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldArgs = {
  input: CreateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldActionArgs = {
  input: CreateFieldActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldPropertyArgs = {
  input: CreateFieldPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldTranslationArgs = {
  input: CreateFieldTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFillupFormArgs = {
  input: CreateFillupFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFillupFormFieldArgs = {
  input: CreateFillupFormFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormArgs = {
  input: CreateFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormOrganizationArgs = {
  input: CreateFormOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateArgs = {
  input: CreateFormTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateGroupArgs = {
  input: CreateFormTemplateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateOrganizationArgs = {
  input: CreateFormTemplateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateProjectArgs = {
  input: CreateFormTemplateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateTeamArgs = {
  input: CreateFormTemplateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormTemplateUserArgs = {
  input: CreateFormTemplateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFormUserArgs = {
  input: CreateFormUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupUserArgs = {
  input: CreateGroupUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateIssuanceArgs = {
  input: CreateIssuanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobArgs = {
  input: CreateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobSendingEmailArgs = {
  input: CreateJobSendingEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobSendingEmailCategoryArgs = {
  input: CreateJobSendingEmailCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobSendingEmailLogArgs = {
  input: CreateJobSendingEmailLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateKindArgs = {
  input: CreateKindInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLanguageArgs = {
  input: CreateLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLoginTransactionArgs = {
  input: CreateLoginTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMetricArgs = {
  input: CreateMetricInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMigrationArgs = {
  input: CreateMigrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNewsArgs = {
  input: CreateNewsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationUserArgs = {
  input: CreateOrganizationUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePasswordResetArgs = {
  input: CreatePasswordResetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonalAccessTokenArgs = {
  input: CreatePersonalAccessTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProfileArgs = {
  input: CreateProfileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProjectUserArgs = {
  input: CreateProjectUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePropertyArgs = {
  input: CreatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleArgs = {
  input: CreateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleUserArgs = {
  input: CreateRoleUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleUserOrganizationArgs = {
  input: CreateRoleUserOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSchedulerArgs = {
  input: CreateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSchedulerFieldArgs = {
  input: CreateSchedulerFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSentMailArgs = {
  input: CreateSentMailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSessionArgs = {
  input: CreateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSettingArgs = {
  input: CreateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSettingGroupArgs = {
  input: CreateSettingGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSubscriptionArgs = {
  input: CreateSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSubscriptionItemArgs = {
  input: CreateSubscriptionItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSystemEventArgs = {
  input: CreateSystemEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTeamArgs = {
  input: CreateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTeamUserArgs = {
  input: CreateTeamUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTelescopeEntriesTagArgs = {
  input: CreateTelescopeEntriesTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTelescopeEntryArgs = {
  input: CreateTelescopeEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTelescopeMonitoringArgs = {
  input: CreateTelescopeMonitoringInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateToolArgs = {
  input: CreateToolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateToolUserArgs = {
  input: CreateToolUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTooltypeArgs = {
  input: CreateTooltypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserInviteArgs = {
  input: CreateUserInviteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserSettingArgs = {
  input: CreateUserSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVerificationTokenArgs = {
  input: CreateVerificationTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVerificationTokenTypeArgs = {
  input: CreateVerificationTokenTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWebsocketsStatisticsEntryArgs = {
  input: CreateWebsocketsStatisticsEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWorkTypeArgs = {
  input: CreateWorkTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAbilityArgs = {
  input: DeleteAbilityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAbilityByNodeIdArgs = {
  input: DeleteAbilityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAbilityRoleArgs = {
  input: DeleteAbilityRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAbilityRoleByNodeIdArgs = {
  input: DeleteAbilityRoleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAdminArgs = {
  input: DeleteAdminInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAdminByNodeIdArgs = {
  input: DeleteAdminByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAllowedSettingValueArgs = {
  input: DeleteAllowedSettingValueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAllowedSettingValueByNodeIdArgs = {
  input: DeleteAllowedSettingValueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAttachmentByNodeIdArgs = {
  input: DeleteAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCertificationArgs = {
  input: DeleteCertificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCertificationByNodeIdArgs = {
  input: DeleteCertificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCompanyArgs = {
  input: DeleteCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCompanyByNodeIdArgs = {
  input: DeleteCompanyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentArgs = {
  input: DeleteComponentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentByDescriptionArgs = {
  input: DeleteComponentByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentByNodeIdArgs = {
  input: DeleteComponentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentBySlugArgs = {
  input: DeleteComponentBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentEventArgs = {
  input: DeleteComponentEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentEventByNodeIdArgs = {
  input: DeleteComponentEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentPropertyArgs = {
  input: DeleteComponentPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteComponentPropertyByNodeIdArgs = {
  input: DeleteComponentPropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCourseArgs = {
  input: DeleteCourseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCourseByNodeIdArgs = {
  input: DeleteCourseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDatatypeArgs = {
  input: DeleteDatatypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDatatypeByDescriptionArgs = {
  input: DeleteDatatypeByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDatatypeByNodeIdArgs = {
  input: DeleteDatatypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEquipmentArgs = {
  input: DeleteEquipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEquipmentByNameArgs = {
  input: DeleteEquipmentByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEquipmentByNodeIdArgs = {
  input: DeleteEquipmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEquipmentTypeArgs = {
  input: DeleteEquipmentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEquipmentTypeByNodeIdArgs = {
  input: DeleteEquipmentTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteErrorReportArgs = {
  input: DeleteErrorReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteErrorReportByNodeIdArgs = {
  input: DeleteErrorReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventByDescriptionArgs = {
  input: DeleteEventByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventByNodeIdArgs = {
  input: DeleteEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEventBySlugArgs = {
  input: DeleteEventBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFailedJobArgs = {
  input: DeleteFailedJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFailedJobByNodeIdArgs = {
  input: DeleteFailedJobByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFailedJobByUuidArgs = {
  input: DeleteFailedJobByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldArgs = {
  input: DeleteFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldActionArgs = {
  input: DeleteFieldActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldActionByNodeIdArgs = {
  input: DeleteFieldActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldByNodeIdArgs = {
  input: DeleteFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldPropertyArgs = {
  input: DeleteFieldPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldPropertyByNodeIdArgs = {
  input: DeleteFieldPropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldTranslationArgs = {
  input: DeleteFieldTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldTranslationByNodeIdArgs = {
  input: DeleteFieldTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFillupFormArgs = {
  input: DeleteFillupFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFillupFormByNodeIdArgs = {
  input: DeleteFillupFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFillupFormFieldArgs = {
  input: DeleteFillupFormFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFillupFormFieldByNodeIdArgs = {
  input: DeleteFillupFormFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormArgs = {
  input: DeleteFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormByNodeIdArgs = {
  input: DeleteFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormOrganizationArgs = {
  input: DeleteFormOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormOrganizationByNodeIdArgs = {
  input: DeleteFormOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateArgs = {
  input: DeleteFormTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateByNodeIdArgs = {
  input: DeleteFormTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateGroupArgs = {
  input: DeleteFormTemplateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateGroupByNodeIdArgs = {
  input: DeleteFormTemplateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateOrganizationArgs = {
  input: DeleteFormTemplateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateOrganizationByNodeIdArgs = {
  input: DeleteFormTemplateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateProjectArgs = {
  input: DeleteFormTemplateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateProjectByNodeIdArgs = {
  input: DeleteFormTemplateProjectByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateTeamArgs = {
  input: DeleteFormTemplateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateTeamByNodeIdArgs = {
  input: DeleteFormTemplateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateUserArgs = {
  input: DeleteFormTemplateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormTemplateUserByNodeIdArgs = {
  input: DeleteFormTemplateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormUserArgs = {
  input: DeleteFormUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFormUserByNodeIdArgs = {
  input: DeleteFormUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNodeIdArgs = {
  input: DeleteGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteIssuanceArgs = {
  input: DeleteIssuanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteIssuanceByEquipmentIdAndSerialNumberArgs = {
  input: DeleteIssuanceByEquipmentIdAndSerialNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteIssuanceByNodeIdArgs = {
  input: DeleteIssuanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobArgs = {
  input: DeleteJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobByNodeIdArgs = {
  input: DeleteJobByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailArgs = {
  input: DeleteJobSendingEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailByNodeIdArgs = {
  input: DeleteJobSendingEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailCategoryArgs = {
  input: DeleteJobSendingEmailCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailCategoryByNodeIdArgs = {
  input: DeleteJobSendingEmailCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailLogArgs = {
  input: DeleteJobSendingEmailLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobSendingEmailLogByNodeIdArgs = {
  input: DeleteJobSendingEmailLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKindArgs = {
  input: DeleteKindInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKindByDescriptionArgs = {
  input: DeleteKindByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKindByNodeIdArgs = {
  input: DeleteKindByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteKindBySlugArgs = {
  input: DeleteKindBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageArgs = {
  input: DeleteLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLanguageByNodeIdArgs = {
  input: DeleteLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLoginTransactionArgs = {
  input: DeleteLoginTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLoginTransactionByNodeIdArgs = {
  input: DeleteLoginTransactionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMetricArgs = {
  input: DeleteMetricInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMetricByNodeIdArgs = {
  input: DeleteMetricByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMigrationArgs = {
  input: DeleteMigrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMigrationByNodeIdArgs = {
  input: DeleteMigrationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNewsArgs = {
  input: DeleteNewsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNewsByNodeIdArgs = {
  input: DeleteNewsByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationArgs = {
  input: DeleteOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationByNodeIdArgs = {
  input: DeleteOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationUserArgs = {
  input: DeleteOrganizationUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationUserByNodeIdArgs = {
  input: DeleteOrganizationUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonalAccessTokenArgs = {
  input: DeletePersonalAccessTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonalAccessTokenByNodeIdArgs = {
  input: DeletePersonalAccessTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonalAccessTokenByTokenArgs = {
  input: DeletePersonalAccessTokenByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProfileArgs = {
  input: DeleteProfileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProfileByNodeIdArgs = {
  input: DeleteProfileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProjectByNodeIdArgs = {
  input: DeleteProjectByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProjectUserArgs = {
  input: DeleteProjectUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProjectUserByNodeIdArgs = {
  input: DeleteProjectUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyArgs = {
  input: DeletePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyByDescriptionArgs = {
  input: DeletePropertyByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyByHintArgs = {
  input: DeletePropertyByHintInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyByNodeIdArgs = {
  input: DeletePropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyBySlugArgs = {
  input: DeletePropertyBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleArgs = {
  input: DeleteRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleByNameArgs = {
  input: DeleteRoleByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleByNodeIdArgs = {
  input: DeleteRoleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleUserArgs = {
  input: DeleteRoleUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleUserByNodeIdArgs = {
  input: DeleteRoleUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleUserOrganizationArgs = {
  input: DeleteRoleUserOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleUserOrganizationByNodeIdArgs = {
  input: DeleteRoleUserOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSchedulerArgs = {
  input: DeleteSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSchedulerByNodeIdArgs = {
  input: DeleteSchedulerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSchedulerFieldArgs = {
  input: DeleteSchedulerFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSchedulerFieldByNodeIdArgs = {
  input: DeleteSchedulerFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSentMailArgs = {
  input: DeleteSentMailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSentMailByNodeIdArgs = {
  input: DeleteSentMailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionArgs = {
  input: DeleteSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSessionByNodeIdArgs = {
  input: DeleteSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingArgs = {
  input: DeleteSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingByDescriptionArgs = {
  input: DeleteSettingByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingByNodeIdArgs = {
  input: DeleteSettingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingGroupArgs = {
  input: DeleteSettingGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingGroupByDescriptionArgs = {
  input: DeleteSettingGroupByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSettingGroupByNodeIdArgs = {
  input: DeleteSettingGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSubscriptionArgs = {
  input: DeleteSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSubscriptionByNodeIdArgs = {
  input: DeleteSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSubscriptionItemArgs = {
  input: DeleteSubscriptionItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSubscriptionItemByNodeIdArgs = {
  input: DeleteSubscriptionItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSubscriptionItemBySubscriptionIdAndStripePlanArgs = {
  input: DeleteSubscriptionItemBySubscriptionIdAndStripePlanInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemEventArgs = {
  input: DeleteSystemEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemEventByNodeIdArgs = {
  input: DeleteSystemEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamArgs = {
  input: DeleteTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByNodeIdArgs = {
  input: DeleteTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTelescopeEntryArgs = {
  input: DeleteTelescopeEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTelescopeEntryByNodeIdArgs = {
  input: DeleteTelescopeEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTelescopeEntryByUuidArgs = {
  input: DeleteTelescopeEntryByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteToolArgs = {
  input: DeleteToolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteToolByNodeIdArgs = {
  input: DeleteToolByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTooltypeArgs = {
  input: DeleteTooltypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTooltypeByNodeIdArgs = {
  input: DeleteTooltypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByFacebookIdArgs = {
  input: DeleteUserByFacebookIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByGoogleIdArgs = {
  input: DeleteUserByGoogleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserInviteArgs = {
  input: DeleteUserInviteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserInviteByNodeIdArgs = {
  input: DeleteUserInviteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserInviteByTokenArgs = {
  input: DeleteUserInviteByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserSettingArgs = {
  input: DeleteUserSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserSettingByNodeIdArgs = {
  input: DeleteUserSettingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationTokenArgs = {
  input: DeleteVerificationTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationTokenByNodeIdArgs = {
  input: DeleteVerificationTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationTokenTypeArgs = {
  input: DeleteVerificationTokenTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationTokenTypeByNodeIdArgs = {
  input: DeleteVerificationTokenTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebsocketsStatisticsEntryArgs = {
  input: DeleteWebsocketsStatisticsEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebsocketsStatisticsEntryByNodeIdArgs = {
  input: DeleteWebsocketsStatisticsEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWorkTypeArgs = {
  input: DeleteWorkTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWorkTypeByNodeIdArgs = {
  input: DeleteWorkTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAbilityArgs = {
  input: UpdateAbilityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAbilityByNodeIdArgs = {
  input: UpdateAbilityByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAbilityRoleArgs = {
  input: UpdateAbilityRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAbilityRoleByNodeIdArgs = {
  input: UpdateAbilityRoleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAdminArgs = {
  input: UpdateAdminInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAdminByNodeIdArgs = {
  input: UpdateAdminByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAllowedSettingValueArgs = {
  input: UpdateAllowedSettingValueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAllowedSettingValueByNodeIdArgs = {
  input: UpdateAllowedSettingValueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentArgs = {
  input: UpdateAttachmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAttachmentByNodeIdArgs = {
  input: UpdateAttachmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCertificationArgs = {
  input: UpdateCertificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCertificationByNodeIdArgs = {
  input: UpdateCertificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCompanyArgs = {
  input: UpdateCompanyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCompanyByNodeIdArgs = {
  input: UpdateCompanyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentArgs = {
  input: UpdateComponentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentByDescriptionArgs = {
  input: UpdateComponentByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentByNodeIdArgs = {
  input: UpdateComponentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentBySlugArgs = {
  input: UpdateComponentBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentEventArgs = {
  input: UpdateComponentEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentEventByNodeIdArgs = {
  input: UpdateComponentEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentPropertyArgs = {
  input: UpdateComponentPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateComponentPropertyByNodeIdArgs = {
  input: UpdateComponentPropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCourseArgs = {
  input: UpdateCourseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCourseByNodeIdArgs = {
  input: UpdateCourseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDatatypeArgs = {
  input: UpdateDatatypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDatatypeByDescriptionArgs = {
  input: UpdateDatatypeByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDatatypeByNodeIdArgs = {
  input: UpdateDatatypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEquipmentArgs = {
  input: UpdateEquipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEquipmentByNameArgs = {
  input: UpdateEquipmentByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEquipmentByNodeIdArgs = {
  input: UpdateEquipmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEquipmentTypeArgs = {
  input: UpdateEquipmentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEquipmentTypeByNodeIdArgs = {
  input: UpdateEquipmentTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateErrorReportArgs = {
  input: UpdateErrorReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateErrorReportByNodeIdArgs = {
  input: UpdateErrorReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventByDescriptionArgs = {
  input: UpdateEventByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventByNodeIdArgs = {
  input: UpdateEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEventBySlugArgs = {
  input: UpdateEventBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFailedJobArgs = {
  input: UpdateFailedJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFailedJobByNodeIdArgs = {
  input: UpdateFailedJobByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFailedJobByUuidArgs = {
  input: UpdateFailedJobByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldArgs = {
  input: UpdateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldActionArgs = {
  input: UpdateFieldActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldActionByNodeIdArgs = {
  input: UpdateFieldActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldByNodeIdArgs = {
  input: UpdateFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldPropertyArgs = {
  input: UpdateFieldPropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldPropertyByNodeIdArgs = {
  input: UpdateFieldPropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldTranslationArgs = {
  input: UpdateFieldTranslationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldTranslationByNodeIdArgs = {
  input: UpdateFieldTranslationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFillupFormArgs = {
  input: UpdateFillupFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFillupFormByNodeIdArgs = {
  input: UpdateFillupFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFillupFormFieldArgs = {
  input: UpdateFillupFormFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFillupFormFieldByNodeIdArgs = {
  input: UpdateFillupFormFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormArgs = {
  input: UpdateFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormByNodeIdArgs = {
  input: UpdateFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormOrganizationArgs = {
  input: UpdateFormOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormOrganizationByNodeIdArgs = {
  input: UpdateFormOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateArgs = {
  input: UpdateFormTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateByNodeIdArgs = {
  input: UpdateFormTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateGroupArgs = {
  input: UpdateFormTemplateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateGroupByNodeIdArgs = {
  input: UpdateFormTemplateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateOrganizationArgs = {
  input: UpdateFormTemplateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateOrganizationByNodeIdArgs = {
  input: UpdateFormTemplateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateProjectArgs = {
  input: UpdateFormTemplateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateProjectByNodeIdArgs = {
  input: UpdateFormTemplateProjectByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateTeamArgs = {
  input: UpdateFormTemplateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateTeamByNodeIdArgs = {
  input: UpdateFormTemplateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateUserArgs = {
  input: UpdateFormTemplateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormTemplateUserByNodeIdArgs = {
  input: UpdateFormTemplateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormUserArgs = {
  input: UpdateFormUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFormUserByNodeIdArgs = {
  input: UpdateFormUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNodeIdArgs = {
  input: UpdateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateIssuanceArgs = {
  input: UpdateIssuanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateIssuanceByEquipmentIdAndSerialNumberArgs = {
  input: UpdateIssuanceByEquipmentIdAndSerialNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateIssuanceByNodeIdArgs = {
  input: UpdateIssuanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobArgs = {
  input: UpdateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobByNodeIdArgs = {
  input: UpdateJobByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailArgs = {
  input: UpdateJobSendingEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailByNodeIdArgs = {
  input: UpdateJobSendingEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailCategoryArgs = {
  input: UpdateJobSendingEmailCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailCategoryByNodeIdArgs = {
  input: UpdateJobSendingEmailCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailLogArgs = {
  input: UpdateJobSendingEmailLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobSendingEmailLogByNodeIdArgs = {
  input: UpdateJobSendingEmailLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKindArgs = {
  input: UpdateKindInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKindByDescriptionArgs = {
  input: UpdateKindByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKindByNodeIdArgs = {
  input: UpdateKindByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateKindBySlugArgs = {
  input: UpdateKindBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageArgs = {
  input: UpdateLanguageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLanguageByNodeIdArgs = {
  input: UpdateLanguageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLoginTransactionArgs = {
  input: UpdateLoginTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLoginTransactionByNodeIdArgs = {
  input: UpdateLoginTransactionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMetricArgs = {
  input: UpdateMetricInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMetricByNodeIdArgs = {
  input: UpdateMetricByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMigrationArgs = {
  input: UpdateMigrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMigrationByNodeIdArgs = {
  input: UpdateMigrationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNewsArgs = {
  input: UpdateNewsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNewsByNodeIdArgs = {
  input: UpdateNewsByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationByNodeIdArgs = {
  input: UpdateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationUserArgs = {
  input: UpdateOrganizationUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationUserByNodeIdArgs = {
  input: UpdateOrganizationUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonalAccessTokenArgs = {
  input: UpdatePersonalAccessTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonalAccessTokenByNodeIdArgs = {
  input: UpdatePersonalAccessTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonalAccessTokenByTokenArgs = {
  input: UpdatePersonalAccessTokenByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProfileArgs = {
  input: UpdateProfileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProfileByNodeIdArgs = {
  input: UpdateProfileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProjectByNodeIdArgs = {
  input: UpdateProjectByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProjectUserArgs = {
  input: UpdateProjectUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProjectUserByNodeIdArgs = {
  input: UpdateProjectUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyArgs = {
  input: UpdatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyByDescriptionArgs = {
  input: UpdatePropertyByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyByHintArgs = {
  input: UpdatePropertyByHintInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyByNodeIdArgs = {
  input: UpdatePropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyBySlugArgs = {
  input: UpdatePropertyBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleByNameArgs = {
  input: UpdateRoleByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleByNodeIdArgs = {
  input: UpdateRoleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleUserArgs = {
  input: UpdateRoleUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleUserByNodeIdArgs = {
  input: UpdateRoleUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleUserOrganizationArgs = {
  input: UpdateRoleUserOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleUserOrganizationByNodeIdArgs = {
  input: UpdateRoleUserOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSchedulerArgs = {
  input: UpdateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSchedulerByNodeIdArgs = {
  input: UpdateSchedulerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSchedulerFieldArgs = {
  input: UpdateSchedulerFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSchedulerFieldByNodeIdArgs = {
  input: UpdateSchedulerFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSentMailArgs = {
  input: UpdateSentMailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSentMailByNodeIdArgs = {
  input: UpdateSentMailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionArgs = {
  input: UpdateSessionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSessionByNodeIdArgs = {
  input: UpdateSessionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingArgs = {
  input: UpdateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingByDescriptionArgs = {
  input: UpdateSettingByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingByNodeIdArgs = {
  input: UpdateSettingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingGroupArgs = {
  input: UpdateSettingGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingGroupByDescriptionArgs = {
  input: UpdateSettingGroupByDescriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSettingGroupByNodeIdArgs = {
  input: UpdateSettingGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSubscriptionByNodeIdArgs = {
  input: UpdateSubscriptionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSubscriptionItemArgs = {
  input: UpdateSubscriptionItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSubscriptionItemByNodeIdArgs = {
  input: UpdateSubscriptionItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSubscriptionItemBySubscriptionIdAndStripePlanArgs = {
  input: UpdateSubscriptionItemBySubscriptionIdAndStripePlanInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemEventArgs = {
  input: UpdateSystemEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemEventByNodeIdArgs = {
  input: UpdateSystemEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamArgs = {
  input: UpdateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByNodeIdArgs = {
  input: UpdateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTelescopeEntryArgs = {
  input: UpdateTelescopeEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTelescopeEntryByNodeIdArgs = {
  input: UpdateTelescopeEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTelescopeEntryByUuidArgs = {
  input: UpdateTelescopeEntryByUuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateToolArgs = {
  input: UpdateToolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateToolByNodeIdArgs = {
  input: UpdateToolByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTooltypeArgs = {
  input: UpdateTooltypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTooltypeByNodeIdArgs = {
  input: UpdateTooltypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByFacebookIdArgs = {
  input: UpdateUserByFacebookIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByGoogleIdArgs = {
  input: UpdateUserByGoogleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInviteArgs = {
  input: UpdateUserInviteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInviteByNodeIdArgs = {
  input: UpdateUserInviteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserInviteByTokenArgs = {
  input: UpdateUserInviteByTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserSettingArgs = {
  input: UpdateUserSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserSettingByNodeIdArgs = {
  input: UpdateUserSettingByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationTokenArgs = {
  input: UpdateVerificationTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationTokenByNodeIdArgs = {
  input: UpdateVerificationTokenByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationTokenTypeArgs = {
  input: UpdateVerificationTokenTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationTokenTypeByNodeIdArgs = {
  input: UpdateVerificationTokenTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsocketsStatisticsEntryArgs = {
  input: UpdateWebsocketsStatisticsEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebsocketsStatisticsEntryByNodeIdArgs = {
  input: UpdateWebsocketsStatisticsEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWorkTypeArgs = {
  input: UpdateWorkTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWorkTypeByNodeIdArgs = {
  input: UpdateWorkTypeByNodeIdInput;
};

export type News = Node & {
  __typename?: 'News';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  news: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  userId: Scalars['BigInt']['output'];
};

/** A condition to be used against `News` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NewsCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `news` field. */
  news?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `News` values. */
export type NewsConnection = {
  __typename?: 'NewsConnection';
  /** A list of edges which contains the `News` and cursor to aid in pagination. */
  edges: Array<NewsEdge>;
  /** A list of `News` objects. */
  nodes: Array<News>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `News` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `News` edge in the connection. */
export type NewsEdge = {
  __typename?: 'NewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `News` at the end of the edge. */
  node: News;
};

/** A filter to be used against `News` object types. All fields are combined with a logical ‘and.’ */
export type NewsFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NewsFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `news` field. */
  news?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NewsFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NewsFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `News` */
export type NewsInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  news: Scalars['String']['input'];
  title: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Methods to use when ordering `News`. */
export enum NewsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NewsAsc = 'NEWS_ASC',
  NewsDesc = 'NEWS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Represents an update to a `News`. Fields that are set will be updated. */
export type NewsPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  news?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type Organization = Node & {
  __typename?: 'Organization';
  /** Reads a single `Admin` that is related to this `Organization`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByCompanyOrganizationIdAndAdminId: OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByGroupOrganizationIdAndAdminId: OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByProjectOrganizationIdAndAdminId: OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerOrgIdAndAdminId: OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByTeamOrganizationIdAndAdminId: OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByToolOrganizationIdAndAdminId: OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Certification`. */
  certifications: CertificationsConnection;
  /** Reads and enables pagination through a set of `Company`. */
  companies: CompaniesConnection;
  /** Reads and enables pagination through a set of `Course`. */
  courses: CoursesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `EquipmentType`. */
  equipmentTypes: EquipmentTypesConnection;
  /** Reads and enables pagination through a set of `EquipmentType`. */
  equipmentTypesByEquipmentOrganizationIdAndEquipmentTypeId: OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerOrgIdAndFillupformId: OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormOrganization`. */
  formOrganizations: FormOrganizationsConnection;
  /** Reads and enables pagination through a set of `FormTemplateOrganization`. */
  formTemplateOrganizations: FormTemplateOrganizationsConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateId: OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerOrgIdAndFormTemplateId: OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFormOrganizationOrganizationIdAndFormId: OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerOrgIdAndFormId: OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByGroupOrganizationIdAndParentId: OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerOrgIdAndGroupId: OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** Reads and enables pagination through a set of `Metric`. */
  metricsByToolOrganizationIdAndMetricId: OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyConnection;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  organizationUsers: OrganizationUsersConnection;
  /** Reads and enables pagination through a set of `Project`. */
  projects: ProjectsConnection;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizationsByOrgId: RoleUserOrganizationsConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByRoleUserOrganizationOrgIdAndRoleId: OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByUserInviteOrganizationIdAndRoleId: OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerOrgIdAndSchedulerFieldsId: OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teams: TeamsConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerOrgIdAndTeamId: OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByUserInviteOrganizationIdAndTeamId: OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
  /** Reads and enables pagination through a set of `Tooltype`. */
  tooltypesByToolOrganizationIdAndTooltypeId: OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByCertificationOrganizationIdAndAdminId: OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByCourseOrganizationIdAndAdminId: OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByEquipmentOrganizationIdAndPreparedBy: OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByJobOrganizationIdAndAdminId: OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByOrganizationUserOrganizationIdAndUserId: OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByRoleUserOrganizationOrgIdAndUserId: OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerOrgIdAndUserId: OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserInviteOrganizationIdAndAdminId: OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `WorkType`. */
  workTypes: WorkTypesConnection;
};


export type OrganizationAdminsByCompanyOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationAdminsByGroupOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationAdminsByProjectOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationAdminsBySchedulerOrgIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationAdminsByTeamOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationAdminsByToolOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type OrganizationCertificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CertificationCondition>;
  filter?: InputMaybe<CertificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};


export type OrganizationCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type OrganizationCoursesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CourseCondition>;
  filter?: InputMaybe<CourseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};


export type OrganizationEquipmentTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentTypeCondition>;
  filter?: InputMaybe<EquipmentTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};


export type OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentTypeCondition>;
  filter?: InputMaybe<EquipmentTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};


export type OrganizationEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};


export type OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type OrganizationFormOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormOrganizationCondition>;
  filter?: InputMaybe<FormOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};


export type OrganizationFormTemplateOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateOrganizationCondition>;
  filter?: InputMaybe<FormTemplateOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};


export type OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type OrganizationFormsByFormOrganizationOrganizationIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type OrganizationFormsBySchedulerOrgIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type OrganizationGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type OrganizationGroupsByGroupOrganizationIdAndParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type OrganizationGroupsBySchedulerOrgIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type OrganizationJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type OrganizationMetricsByToolOrganizationIdAndMetricIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MetricCondition>;
  filter?: InputMaybe<MetricFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};


export type OrganizationOrganizationUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationUserCondition>;
  filter?: InputMaybe<OrganizationUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};


export type OrganizationProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};


export type OrganizationRoleUserOrganizationsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};


export type OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type OrganizationRolesByUserInviteOrganizationIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type OrganizationSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type OrganizationTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type OrganizationTeamsBySchedulerOrgIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type OrganizationTeamsByUserInviteOrganizationIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type OrganizationToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};


export type OrganizationTooltypesByToolOrganizationIdAndTooltypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TooltypeCondition>;
  filter?: InputMaybe<TooltypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};


export type OrganizationUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};


export type OrganizationUsersByCertificationOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByCourseOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByEquipmentOrganizationIdAndPreparedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByJobOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByOrganizationUserOrganizationIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersBySchedulerOrgIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationUsersByUserInviteOrganizationIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type OrganizationWorkTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WorkTypeCondition>;
  filter?: InputMaybe<WorkTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkTypesOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Company`. */
export type OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Company`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Company`. */
export type OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Company`. */
  companies: CompaniesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Company`. */
export type OrganizationAdminsByCompanyOrganizationIdAndAdminIdManyToManyEdgeCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Group`. */
export type OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Group`. */
export type OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groups: GroupsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Group`. */
export type OrganizationAdminsByGroupOrganizationIdAndAdminIdManyToManyEdgeGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Project`. */
export type OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Project`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Project`. */
export type OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Project`. */
  projects: ProjectsConnection;
};


/** A `Admin` edge in the connection, with data from `Project`. */
export type OrganizationAdminsByProjectOrganizationIdAndAdminIdManyToManyEdgeProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type OrganizationAdminsBySchedulerOrgIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Team`. */
export type OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Team`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Team`. */
export type OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Team`. */
  teams: TeamsConnection;
};


/** A `Admin` edge in the connection, with data from `Team`. */
export type OrganizationAdminsByTeamOrganizationIdAndAdminIdManyToManyEdgeTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Tool`. */
export type OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Tool`. */
export type OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Admin` edge in the connection, with data from `Tool`. */
export type OrganizationAdminsByToolOrganizationIdAndAdminIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/**
 * A condition to be used against `Organization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `EquipmentType` values, with data from `Equipment`. */
export type OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyConnection = {
  __typename?: 'OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyConnection';
  /** A list of edges which contains the `EquipmentType`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyEdge>;
  /** A list of `EquipmentType` objects. */
  nodes: Array<EquipmentType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EquipmentType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EquipmentType` edge in the connection, with data from `Equipment`. */
export type OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyEdge = {
  __typename?: 'OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  /** The `EquipmentType` at the end of the edge. */
  node: EquipmentType;
};


/** A `EquipmentType` edge in the connection, with data from `Equipment`. */
export type OrganizationEquipmentTypesByEquipmentOrganizationIdAndEquipmentTypeIdManyToManyEdgeEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyConnection = {
  __typename?: 'OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyEdge = {
  __typename?: 'OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type OrganizationFillupFormsBySchedulerOrgIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `FormTemplateOrganization`. */
export type OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `FormTemplateOrganization`, and the cursor to aid in pagination. */
  edges: Array<OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `FormTemplateOrganization`. */
export type OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'OrganizationFormTemplatesByFormTemplateOrganizationOrganizationIdAndFormTemplateIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type OrganizationFormTemplatesBySchedulerOrgIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `FormOrganization`. */
export type OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyConnection = {
  __typename?: 'OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `FormOrganization`, and the cursor to aid in pagination. */
  edges: Array<OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `FormOrganization`. */
export type OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyEdge = {
  __typename?: 'OrganizationFormsByFormOrganizationOrganizationIdAndFormIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyConnection = {
  __typename?: 'OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyEdge = {
  __typename?: 'OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type OrganizationFormsBySchedulerOrgIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Group`. */
export type OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyConnection = {
  __typename?: 'OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Group`, and the cursor to aid in pagination. */
  edges: Array<OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Group`. */
export type OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyEdge = {
  __typename?: 'OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Group`. */
  childGroups: GroupsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `Group`. */
export type OrganizationGroupsByGroupOrganizationIdAndParentIdManyToManyEdgeChildGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyConnection = {
  __typename?: 'OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyEdge = {
  __typename?: 'OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type OrganizationGroupsBySchedulerOrgIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `Organization` */
export type OrganizationInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Metric` values, with data from `Tool`. */
export type OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyConnection = {
  __typename?: 'OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyConnection';
  /** A list of edges which contains the `Metric`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyEdge>;
  /** A list of `Metric` objects. */
  nodes: Array<Metric>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Metric` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Metric` edge in the connection, with data from `Tool`. */
export type OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyEdge = {
  __typename?: 'OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Metric` at the end of the edge. */
  node: Metric;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Metric` edge in the connection, with data from `Tool`. */
export type OrganizationMetricsByToolOrganizationIdAndMetricIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** Represents an update to a `Organization`. Fields that are set will be updated. */
export type OrganizationPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Role` values, with data from `RoleUserOrganization`. */
export type OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyConnection = {
  __typename?: 'OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `RoleUserOrganization`. */
export type OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyEdge = {
  __typename?: 'OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
};


/** A `Role` edge in the connection, with data from `RoleUserOrganization`. */
export type OrganizationRolesByRoleUserOrganizationOrgIdAndRoleIdManyToManyEdgeRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `Role` values, with data from `UserInvite`. */
export type OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyConnection = {
  __typename?: 'OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `UserInvite`. */
export type OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyEdge = {
  __typename?: 'OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Role` edge in the connection, with data from `UserInvite`. */
export type OrganizationRolesByUserInviteOrganizationIdAndRoleIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type OrganizationSchedulerFieldsBySchedulerOrgIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyConnection = {
  __typename?: 'OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyEdge = {
  __typename?: 'OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type OrganizationTeamsBySchedulerOrgIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `UserInvite`. */
export type OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyConnection = {
  __typename?: 'OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `UserInvite`. */
export type OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyEdge = {
  __typename?: 'OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Team` edge in the connection, with data from `UserInvite`. */
export type OrganizationTeamsByUserInviteOrganizationIdAndTeamIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `Tooltype` values, with data from `Tool`. */
export type OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyConnection = {
  __typename?: 'OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyConnection';
  /** A list of edges which contains the `Tooltype`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyEdge>;
  /** A list of `Tooltype` objects. */
  nodes: Array<Tooltype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tooltype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyEdge = {
  __typename?: 'OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tooltype` at the end of the edge. */
  node: Tooltype;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Tooltype` edge in the connection, with data from `Tool`. */
export type OrganizationTooltypesByToolOrganizationIdAndTooltypeIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

export type OrganizationUser = Node & {
  __typename?: 'OrganizationUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `OrganizationUser`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `OrganizationUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `OrganizationUser` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `OrganizationUser` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationUserFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `OrganizationUser` */
export type OrganizationUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  organizationId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `OrganizationUser`. Fields that are set will be updated. */
export type OrganizationUserPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values, with data from `Certification`. */
export type OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Certification`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Certification`. */
export type OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Certification`. */
  certificationsByAdminId: CertificationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Certification`. */
export type OrganizationUsersByCertificationOrganizationIdAndAdminIdManyToManyEdgeCertificationsByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CertificationCondition>;
  filter?: InputMaybe<CertificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Course`. */
export type OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Course`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Course`. */
export type OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Course`. */
  coursesByAdminId: CoursesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Course`. */
export type OrganizationUsersByCourseOrganizationIdAndAdminIdManyToManyEdgeCoursesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CourseCondition>;
  filter?: InputMaybe<CourseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Equipment`. */
export type OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyConnection = {
  __typename?: 'OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Equipment`. */
export type OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyEdge = {
  __typename?: 'OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipmentByPreparedBy: EquipmentConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Equipment`. */
export type OrganizationUsersByEquipmentOrganizationIdAndPreparedByManyToManyEdgeEquipmentByPreparedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Job`. */
export type OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Job`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Job`. */
export type OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Job`. */
  jobsByAdminId: JobsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `Job`. */
export type OrganizationUsersByJobOrganizationIdAndAdminIdManyToManyEdgeJobsByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `OrganizationUser`. */
export type OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `OrganizationUser`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `OrganizationUser`. */
export type OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByOrganizationUserOrganizationIdAndUserIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `User` values, with data from `RoleUserOrganization`. */
export type OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `RoleUserOrganization`. */
export type OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
};


/** A `User` edge in the connection, with data from `RoleUserOrganization`. */
export type OrganizationUsersByRoleUserOrganizationOrgIdAndUserIdManyToManyEdgeRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyConnection = {
  __typename?: 'OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyEdge = {
  __typename?: 'OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type OrganizationUsersBySchedulerOrgIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `UserInvite`. */
export type OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyConnection = {
  __typename?: 'OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `UserInvite`. */
export type OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyEdge = {
  __typename?: 'OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvitesByAdminId: UserInvitesConnection;
};


/** A `User` edge in the connection, with data from `UserInvite`. */
export type OrganizationUsersByUserInviteOrganizationIdAndAdminIdManyToManyEdgeUserInvitesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `OrganizationUser` values. */
export type OrganizationUsersConnection = {
  __typename?: 'OrganizationUsersConnection';
  /** A list of edges which contains the `OrganizationUser` and cursor to aid in pagination. */
  edges: Array<OrganizationUsersEdge>;
  /** A list of `OrganizationUser` objects. */
  nodes: Array<OrganizationUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganizationUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganizationUser` edge in the connection. */
export type OrganizationUsersEdge = {
  __typename?: 'OrganizationUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganizationUser` at the end of the edge. */
  node: OrganizationUser;
};

/** Methods to use when ordering `OrganizationUser`. */
export enum OrganizationUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Organization` values. */
export type OrganizationsConnection = {
  __typename?: 'OrganizationsConnection';
  /** A list of edges which contains the `Organization` and cursor to aid in pagination. */
  edges: Array<OrganizationsEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection. */
export type OrganizationsEdge = {
  __typename?: 'OrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};

/** Methods to use when ordering `Organization`. */
export enum OrganizationsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PasswordReset = {
  __typename?: 'PasswordReset';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  email: Scalars['String']['output'];
  token: Scalars['String']['output'];
};

/**
 * A condition to be used against `PasswordReset` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PasswordResetCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PasswordReset` object types. All fields are combined with a logical ‘and.’ */
export type PasswordResetFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PasswordResetFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PasswordResetFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PasswordResetFilter>>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `PasswordReset` */
export type PasswordResetInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  email: Scalars['String']['input'];
  token: Scalars['String']['input'];
};

/** A connection to a list of `PasswordReset` values. */
export type PasswordResetsConnection = {
  __typename?: 'PasswordResetsConnection';
  /** A list of edges which contains the `PasswordReset` and cursor to aid in pagination. */
  edges: Array<PasswordResetsEdge>;
  /** A list of `PasswordReset` objects. */
  nodes: Array<PasswordReset>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PasswordReset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PasswordReset` edge in the connection. */
export type PasswordResetsEdge = {
  __typename?: 'PasswordResetsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PasswordReset` at the end of the edge. */
  node: PasswordReset;
};

/** Methods to use when ordering `PasswordReset`. */
export enum PasswordResetsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  Natural = 'NATURAL',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC'
}

export type PersonalAccessToken = Node & {
  __typename?: 'PersonalAccessToken';
  abilities?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  lastUsedAt?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  tokenableId: Scalars['BigInt']['output'];
  tokenableType: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `PersonalAccessToken` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PersonalAccessTokenCondition = {
  /** Checks for equality with the object’s `abilities` field. */
  abilities?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `lastUsedAt` field. */
  lastUsedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tokenableId` field. */
  tokenableId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `tokenableType` field. */
  tokenableType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `PersonalAccessToken` object types. All fields are combined with a logical ‘and.’ */
export type PersonalAccessTokenFilter = {
  /** Filter by the object’s `abilities` field. */
  abilities?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersonalAccessTokenFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `lastUsedAt` field. */
  lastUsedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersonalAccessTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersonalAccessTokenFilter>>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tokenableId` field. */
  tokenableId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `tokenableType` field. */
  tokenableType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `PersonalAccessToken` */
export type PersonalAccessTokenInput = {
  abilities?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastUsedAt?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  token: Scalars['String']['input'];
  tokenableId: Scalars['BigInt']['input'];
  tokenableType: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `PersonalAccessToken`. Fields that are set will be updated. */
export type PersonalAccessTokenPatch = {
  abilities?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastUsedAt?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  tokenableId?: InputMaybe<Scalars['BigInt']['input']>;
  tokenableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `PersonalAccessToken` values. */
export type PersonalAccessTokensConnection = {
  __typename?: 'PersonalAccessTokensConnection';
  /** A list of edges which contains the `PersonalAccessToken` and cursor to aid in pagination. */
  edges: Array<PersonalAccessTokensEdge>;
  /** A list of `PersonalAccessToken` objects. */
  nodes: Array<PersonalAccessToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonalAccessToken` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PersonalAccessToken` edge in the connection. */
export type PersonalAccessTokensEdge = {
  __typename?: 'PersonalAccessTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PersonalAccessToken` at the end of the edge. */
  node: PersonalAccessToken;
};

/** Methods to use when ordering `PersonalAccessToken`. */
export enum PersonalAccessTokensOrderBy {
  AbilitiesAsc = 'ABILITIES_ASC',
  AbilitiesDesc = 'ABILITIES_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastUsedAtAsc = 'LAST_USED_AT_ASC',
  LastUsedAtDesc = 'LAST_USED_AT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TokenableIdAsc = 'TOKENABLE_ID_ASC',
  TokenableIdDesc = 'TOKENABLE_ID_DESC',
  TokenableTypeAsc = 'TOKENABLE_TYPE_ASC',
  TokenableTypeDesc = 'TOKENABLE_TYPE_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Profile = Node & {
  __typename?: 'Profile';
  address?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['BigInt']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  photo?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Profile`. */
  pro_id?: Maybe<User>;
  skills?: Maybe<Scalars['String']['output']>;
  stateProvince?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['BigInt']['output']>;
  zipcode?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Profile` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProfileCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `middleName` field. */
  middleName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `photo` field. */
  photo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `skills` field. */
  skills?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stateProvince` field. */
  stateProvince?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Profile` object types. All fields are combined with a logical ‘and.’ */
export type ProfileFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProfileFilter>>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DateFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `middleName` field. */
  middleName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProfileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProfileFilter>>;
  /** Filter by the object’s `photo` field. */
  photo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `skills` field. */
  skills?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stateProvince` field. */
  stateProvince?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `zipcode` field. */
  zipcode?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Profile` */
export type ProfileInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  photo?: InputMaybe<Scalars['String']['input']>;
  skills?: InputMaybe<Scalars['String']['input']>;
  stateProvince?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Profile`. Fields that are set will be updated. */
export type ProfilePatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  photo?: InputMaybe<Scalars['String']['input']>;
  skills?: InputMaybe<Scalars['String']['input']>;
  stateProvince?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  zipcode?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Profile` values. */
export type ProfilesConnection = {
  __typename?: 'ProfilesConnection';
  /** A list of edges which contains the `Profile` and cursor to aid in pagination. */
  edges: Array<ProfilesEdge>;
  /** A list of `Profile` objects. */
  nodes: Array<Profile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Profile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Profile` edge in the connection. */
export type ProfilesEdge = {
  __typename?: 'ProfilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Profile` at the end of the edge. */
  node: Profile;
};

/** Methods to use when ordering `Profile`. */
export enum ProfilesOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  MiddleNameAsc = 'MIDDLE_NAME_ASC',
  MiddleNameDesc = 'MIDDLE_NAME_DESC',
  Natural = 'NATURAL',
  PhotoAsc = 'PHOTO_ASC',
  PhotoDesc = 'PHOTO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkillsAsc = 'SKILLS_ASC',
  SkillsDesc = 'SKILLS_DESC',
  StateProvinceAsc = 'STATE_PROVINCE_ASC',
  StateProvinceDesc = 'STATE_PROVINCE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ZipcodeAsc = 'ZIPCODE_ASC',
  ZipcodeDesc = 'ZIPCODE_DESC'
}

export type Project = Node & {
  __typename?: 'Project';
  /** Reads a single `Admin` that is related to this `Project`. */
  admin?: Maybe<Admin>;
  adminId?: Maybe<Scalars['BigInt']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `FormTemplateProject`. */
  formTemplateProjects: FormTemplateProjectsConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTemplateProjectProjectIdAndFormTemplateId: ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Project`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `ProjectUser`. */
  projectUsers: ProjectUsersConnection;
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByProjectUserProjectIdAndUserId: ProjectUsersByProjectUserProjectIdAndUserIdManyToManyConnection;
  uuid?: Maybe<Scalars['String']['output']>;
};


export type ProjectFormTemplateProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateProjectCondition>;
  filter?: InputMaybe<FormTemplateProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};


export type ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type ProjectProjectUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectUserCondition>;
  filter?: InputMaybe<ProjectUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};


export type ProjectUsersByProjectUserProjectIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProjectCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’ */
export type ProjectFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProjectFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProjectFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProjectFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<StringFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `FormTemplateProject`. */
export type ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `FormTemplateProject`, and the cursor to aid in pagination. */
  edges: Array<ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `FormTemplateProject`. */
export type ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'ProjectFormTemplatesByFormTemplateProjectProjectIdAndFormTemplateIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** An input for mutations affecting `Project` */
export type ProjectInput = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Project`. Fields that are set will be updated. */
export type ProjectPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

export type ProjectUser = Node & {
  __typename?: 'ProjectUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Project` that is related to this `ProjectUser`. */
  project?: Maybe<Project>;
  projectId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `ProjectUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `ProjectUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProjectUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `projectId` field. */
  projectId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `ProjectUser` object types. All fields are combined with a logical ‘and.’ */
export type ProjectUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProjectUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProjectUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProjectUserFilter>>;
  /** Filter by the object’s `projectId` field. */
  projectId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `ProjectUser` */
export type ProjectUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  projectId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `ProjectUser`. Fields that are set will be updated. */
export type ProjectUserPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  projectId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values, with data from `ProjectUser`. */
export type ProjectUsersByProjectUserProjectIdAndUserIdManyToManyConnection = {
  __typename?: 'ProjectUsersByProjectUserProjectIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `ProjectUser`, and the cursor to aid in pagination. */
  edges: Array<ProjectUsersByProjectUserProjectIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `ProjectUser`. */
export type ProjectUsersByProjectUserProjectIdAndUserIdManyToManyEdge = {
  __typename?: 'ProjectUsersByProjectUserProjectIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `ProjectUser`. */
  projectUsers: ProjectUsersConnection;
};


/** A `User` edge in the connection, with data from `ProjectUser`. */
export type ProjectUsersByProjectUserProjectIdAndUserIdManyToManyEdgeProjectUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectUserCondition>;
  filter?: InputMaybe<ProjectUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};

/** A connection to a list of `ProjectUser` values. */
export type ProjectUsersConnection = {
  __typename?: 'ProjectUsersConnection';
  /** A list of edges which contains the `ProjectUser` and cursor to aid in pagination. */
  edges: Array<ProjectUsersEdge>;
  /** A list of `ProjectUser` objects. */
  nodes: Array<ProjectUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProjectUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ProjectUser` edge in the connection. */
export type ProjectUsersEdge = {
  __typename?: 'ProjectUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ProjectUser` at the end of the edge. */
  node: ProjectUser;
};

/** Methods to use when ordering `ProjectUser`. */
export enum ProjectUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjectIdAsc = 'PROJECT_ID_ASC',
  ProjectIdDesc = 'PROJECT_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Project` values. */
export type ProjectsConnection = {
  __typename?: 'ProjectsConnection';
  /** A list of edges which contains the `Project` and cursor to aid in pagination. */
  edges: Array<ProjectsEdge>;
  /** A list of `Project` objects. */
  nodes: Array<Project>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Project` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Project` edge in the connection. */
export type ProjectsEdge = {
  __typename?: 'ProjectsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Project` at the end of the edge. */
  node: Project;
};

/** Methods to use when ordering `Project`. */
export enum ProjectsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A connection to a list of `Property` values. */
export type PropertiesConnection = {
  __typename?: 'PropertiesConnection';
  /** A list of edges which contains the `Property` and cursor to aid in pagination. */
  edges: Array<PropertiesEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Property>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection. */
export type PropertiesEdge = {
  __typename?: 'PropertiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Property` at the end of the edge. */
  node: Property;
};

/** Methods to use when ordering `Property`. */
export enum PropertiesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DatatypeIdAsc = 'DATATYPE_ID_ASC',
  DatatypeIdDesc = 'DATATYPE_ID_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  HintAsc = 'HINT_ASC',
  HintDesc = 'HINT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KindIdAsc = 'KIND_ID_ASC',
  KindIdDesc = 'KIND_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SlugAsc = 'SLUG_ASC',
  SlugDesc = 'SLUG_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Property = Node & {
  __typename?: 'Property';
  /** Reads and enables pagination through a set of `ComponentProperty`. */
  componentProperties: ComponentPropertiesConnection;
  /** Reads and enables pagination through a set of `Component`. */
  componentsByComponentPropertyPropertyIdAndComponentId: PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Datatype` that is related to this `Property`. */
  datatype?: Maybe<Datatype>;
  datatypeId: Scalars['BigInt']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Event`. */
  eventsByFieldActionPropertyIdAndEventId: PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** Reads and enables pagination through a set of `FieldProperty`. */
  fieldProperties: FieldPropertiesConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsByFieldActionPropertyIdAndFieldId: PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Field`. */
  fieldsByFieldPropertyPropertyIdAndFieldId: PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyConnection;
  hint: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `Kind` that is related to this `Property`. */
  kind?: Maybe<Kind>;
  kindId: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  slug: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};


export type PropertyComponentPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentPropertyCondition>;
  filter?: InputMaybe<ComponentPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};


export type PropertyComponentsByComponentPropertyPropertyIdAndComponentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentCondition>;
  filter?: InputMaybe<ComponentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};


export type PropertyEventsByFieldActionPropertyIdAndEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type PropertyFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};


export type PropertyFieldPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldPropertyCondition>;
  filter?: InputMaybe<FieldPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};


export type PropertyFieldsByFieldActionPropertyIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


export type PropertyFieldsByFieldPropertyPropertyIdAndFieldIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** A connection to a list of `Component` values, with data from `ComponentProperty`. */
export type PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyConnection = {
  __typename?: 'PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyConnection';
  /** A list of edges which contains the `Component`, info from the `ComponentProperty`, and the cursor to aid in pagination. */
  edges: Array<PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyEdge>;
  /** A list of `Component` objects. */
  nodes: Array<Component>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Component` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Component` edge in the connection, with data from `ComponentProperty`. */
export type PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyEdge = {
  __typename?: 'PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyEdge';
  /** Reads and enables pagination through a set of `ComponentProperty`. */
  componentProperties: ComponentPropertiesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Component` at the end of the edge. */
  node: Component;
};


/** A `Component` edge in the connection, with data from `ComponentProperty`. */
export type PropertyComponentsByComponentPropertyPropertyIdAndComponentIdManyToManyEdgeComponentPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentPropertyCondition>;
  filter?: InputMaybe<ComponentPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};

/**
 * A condition to be used against `Property` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PropertyCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `datatypeId` field. */
  datatypeId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hint` field. */
  hint?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `kindId` field. */
  kindId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Event` values, with data from `FieldAction`. */
export type PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyConnection = {
  __typename?: 'PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyConnection';
  /** A list of edges which contains the `Event`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyEdge>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Event` edge in the connection, with data from `FieldAction`. */
export type PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyEdge = {
  __typename?: 'PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Event` at the end of the edge. */
  node: Event;
};


/** A `Event` edge in the connection, with data from `FieldAction`. */
export type PropertyEventsByFieldActionPropertyIdAndEventIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A connection to a list of `Field` values, with data from `FieldAction`. */
export type PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyConnection = {
  __typename?: 'PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `FieldAction`, and the cursor to aid in pagination. */
  edges: Array<PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `FieldAction`. */
export type PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyEdge = {
  __typename?: 'PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions: FieldActionsConnection;
  /** The `Field` at the end of the edge. */
  node: Field;
};


/** A `Field` edge in the connection, with data from `FieldAction`. */
export type PropertyFieldsByFieldActionPropertyIdAndFieldIdManyToManyEdgeFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** A connection to a list of `Field` values, with data from `FieldProperty`. */
export type PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyConnection = {
  __typename?: 'PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyConnection';
  /** A list of edges which contains the `Field`, info from the `FieldProperty`, and the cursor to aid in pagination. */
  edges: Array<PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyEdge>;
  /** A list of `Field` objects. */
  nodes: Array<Field>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Field` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Field` edge in the connection, with data from `FieldProperty`. */
export type PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyEdge = {
  __typename?: 'PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FieldProperty`. */
  fieldProperties: FieldPropertiesConnection;
  /** The `Field` at the end of the edge. */
  node: Field;
};


/** A `Field` edge in the connection, with data from `FieldProperty`. */
export type PropertyFieldsByFieldPropertyPropertyIdAndFieldIdManyToManyEdgeFieldPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldPropertyCondition>;
  filter?: InputMaybe<FieldPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};

/** A filter to be used against `Property` object types. All fields are combined with a logical ‘and.’ */
export type PropertyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PropertyFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `datatypeId` field. */
  datatypeId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hint` field. */
  hint?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `kindId` field. */
  kindId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PropertyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PropertyFilter>>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Property` */
export type PropertyInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  datatypeId: Scalars['BigInt']['input'];
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  hint: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  kindId: Scalars['BigInt']['input'];
  slug: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `Property`. Fields that are set will be updated. */
export type PropertyPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  datatypeId?: InputMaybe<Scalars['BigInt']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hint?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  kindId?: InputMaybe<Scalars['BigInt']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `Ability`. */
  abilities?: Maybe<AbilitiesConnection>;
  ability?: Maybe<Ability>;
  /** Reads a single `Ability` using its globally unique `ID`. */
  abilityByNodeId?: Maybe<Ability>;
  abilityRole?: Maybe<AbilityRole>;
  /** Reads a single `AbilityRole` using its globally unique `ID`. */
  abilityRoleByNodeId?: Maybe<AbilityRole>;
  /** Reads and enables pagination through a set of `AbilityRole`. */
  abilityRoles?: Maybe<AbilityRolesConnection>;
  admin?: Maybe<Admin>;
  /** Reads a single `Admin` using its globally unique `ID`. */
  adminByNodeId?: Maybe<Admin>;
  /** Reads and enables pagination through a set of `Admin`. */
  admins?: Maybe<AdminsConnection>;
  allowedSettingValue?: Maybe<AllowedSettingValue>;
  /** Reads a single `AllowedSettingValue` using its globally unique `ID`. */
  allowedSettingValueByNodeId?: Maybe<AllowedSettingValue>;
  /** Reads and enables pagination through a set of `AllowedSettingValue`. */
  allowedSettingValues?: Maybe<AllowedSettingValuesConnection>;
  attachment?: Maybe<Attachment>;
  /** Reads a single `Attachment` using its globally unique `ID`. */
  attachmentByNodeId?: Maybe<Attachment>;
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments?: Maybe<AttachmentsConnection>;
  certification?: Maybe<Certification>;
  /** Reads a single `Certification` using its globally unique `ID`. */
  certificationByNodeId?: Maybe<Certification>;
  /** Reads and enables pagination through a set of `Certification`. */
  certifications?: Maybe<CertificationsConnection>;
  /** Reads and enables pagination through a set of `Company`. */
  companies?: Maybe<CompaniesConnection>;
  company?: Maybe<Company>;
  /** Reads a single `Company` using its globally unique `ID`. */
  companyByNodeId?: Maybe<Company>;
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers?: Maybe<CompanyUsersConnection>;
  component?: Maybe<Component>;
  componentByDescription?: Maybe<Component>;
  /** Reads a single `Component` using its globally unique `ID`. */
  componentByNodeId?: Maybe<Component>;
  componentBySlug?: Maybe<Component>;
  componentEvent?: Maybe<ComponentEvent>;
  /** Reads a single `ComponentEvent` using its globally unique `ID`. */
  componentEventByNodeId?: Maybe<ComponentEvent>;
  /** Reads and enables pagination through a set of `ComponentEvent`. */
  componentEvents?: Maybe<ComponentEventsConnection>;
  /** Reads and enables pagination through a set of `ComponentProperty`. */
  componentProperties?: Maybe<ComponentPropertiesConnection>;
  componentProperty?: Maybe<ComponentProperty>;
  /** Reads a single `ComponentProperty` using its globally unique `ID`. */
  componentPropertyByNodeId?: Maybe<ComponentProperty>;
  /** Reads and enables pagination through a set of `Component`. */
  components?: Maybe<ComponentsConnection>;
  course?: Maybe<Course>;
  /** Reads a single `Course` using its globally unique `ID`. */
  courseByNodeId?: Maybe<Course>;
  /** Reads and enables pagination through a set of `Course`. */
  courses?: Maybe<CoursesConnection>;
  datatype?: Maybe<Datatype>;
  datatypeByDescription?: Maybe<Datatype>;
  /** Reads a single `Datatype` using its globally unique `ID`. */
  datatypeByNodeId?: Maybe<Datatype>;
  /** Reads and enables pagination through a set of `Datatype`. */
  datatypes?: Maybe<DatatypesConnection>;
  equipment?: Maybe<Equipment>;
  equipmentByName?: Maybe<Equipment>;
  /** Reads a single `Equipment` using its globally unique `ID`. */
  equipmentByNodeId?: Maybe<Equipment>;
  equipmentType?: Maybe<EquipmentType>;
  /** Reads a single `EquipmentType` using its globally unique `ID`. */
  equipmentTypeByNodeId?: Maybe<EquipmentType>;
  /** Reads and enables pagination through a set of `EquipmentType`. */
  equipmentTypes?: Maybe<EquipmentTypesConnection>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments?: Maybe<EquipmentConnection>;
  errorReport?: Maybe<ErrorReport>;
  /** Reads a single `ErrorReport` using its globally unique `ID`. */
  errorReportByNodeId?: Maybe<ErrorReport>;
  /** Reads and enables pagination through a set of `ErrorReport`. */
  errorReports?: Maybe<ErrorReportsConnection>;
  event?: Maybe<Event>;
  eventByDescription?: Maybe<Event>;
  /** Reads a single `Event` using its globally unique `ID`. */
  eventByNodeId?: Maybe<Event>;
  eventBySlug?: Maybe<Event>;
  /** Reads and enables pagination through a set of `Event`. */
  events?: Maybe<EventsConnection>;
  failedJob?: Maybe<FailedJob>;
  /** Reads a single `FailedJob` using its globally unique `ID`. */
  failedJobByNodeId?: Maybe<FailedJob>;
  failedJobByUuid?: Maybe<FailedJob>;
  /** Reads and enables pagination through a set of `FailedJob`. */
  failedJobs?: Maybe<FailedJobsConnection>;
  field?: Maybe<Field>;
  fieldAction?: Maybe<FieldAction>;
  /** Reads a single `FieldAction` using its globally unique `ID`. */
  fieldActionByNodeId?: Maybe<FieldAction>;
  /** Reads and enables pagination through a set of `FieldAction`. */
  fieldActions?: Maybe<FieldActionsConnection>;
  /** Reads a single `Field` using its globally unique `ID`. */
  fieldByNodeId?: Maybe<Field>;
  /** Reads and enables pagination through a set of `FieldProperty`. */
  fieldProperties?: Maybe<FieldPropertiesConnection>;
  fieldProperty?: Maybe<FieldProperty>;
  /** Reads a single `FieldProperty` using its globally unique `ID`. */
  fieldPropertyByNodeId?: Maybe<FieldProperty>;
  fieldTranslation?: Maybe<FieldTranslation>;
  /** Reads a single `FieldTranslation` using its globally unique `ID`. */
  fieldTranslationByNodeId?: Maybe<FieldTranslation>;
  /** Reads and enables pagination through a set of `FieldTranslation`. */
  fieldTranslations?: Maybe<FieldTranslationsConnection>;
  /** Reads and enables pagination through a set of `Field`. */
  fields?: Maybe<FieldsConnection>;
  fillupForm?: Maybe<FillupForm>;
  /** Reads a single `FillupForm` using its globally unique `ID`. */
  fillupFormByNodeId?: Maybe<FillupForm>;
  fillupFormField?: Maybe<FillupFormField>;
  /** Reads a single `FillupFormField` using its globally unique `ID`. */
  fillupFormFieldByNodeId?: Maybe<FillupFormField>;
  /** Reads and enables pagination through a set of `FillupFormField`. */
  fillupFormFields?: Maybe<FillupFormFieldsConnection>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms?: Maybe<FillupFormsConnection>;
  form?: Maybe<Form>;
  /** Reads a single `Form` using its globally unique `ID`. */
  formByNodeId?: Maybe<Form>;
  formOrganization?: Maybe<FormOrganization>;
  /** Reads a single `FormOrganization` using its globally unique `ID`. */
  formOrganizationByNodeId?: Maybe<FormOrganization>;
  /** Reads and enables pagination through a set of `FormOrganization`. */
  formOrganizations?: Maybe<FormOrganizationsConnection>;
  formTemplate?: Maybe<FormTemplate>;
  /** Reads a single `FormTemplate` using its globally unique `ID`. */
  formTemplateByNodeId?: Maybe<FormTemplate>;
  formTemplateGroup?: Maybe<FormTemplateGroup>;
  /** Reads a single `FormTemplateGroup` using its globally unique `ID`. */
  formTemplateGroupByNodeId?: Maybe<FormTemplateGroup>;
  /** Reads and enables pagination through a set of `FormTemplateGroup`. */
  formTemplateGroups?: Maybe<FormTemplateGroupsConnection>;
  formTemplateOrganization?: Maybe<FormTemplateOrganization>;
  /** Reads a single `FormTemplateOrganization` using its globally unique `ID`. */
  formTemplateOrganizationByNodeId?: Maybe<FormTemplateOrganization>;
  /** Reads and enables pagination through a set of `FormTemplateOrganization`. */
  formTemplateOrganizations?: Maybe<FormTemplateOrganizationsConnection>;
  formTemplateProject?: Maybe<FormTemplateProject>;
  /** Reads a single `FormTemplateProject` using its globally unique `ID`. */
  formTemplateProjectByNodeId?: Maybe<FormTemplateProject>;
  /** Reads and enables pagination through a set of `FormTemplateProject`. */
  formTemplateProjects?: Maybe<FormTemplateProjectsConnection>;
  formTemplateTeam?: Maybe<FormTemplateTeam>;
  /** Reads a single `FormTemplateTeam` using its globally unique `ID`. */
  formTemplateTeamByNodeId?: Maybe<FormTemplateTeam>;
  /** Reads and enables pagination through a set of `FormTemplateTeam`. */
  formTemplateTeams?: Maybe<FormTemplateTeamsConnection>;
  formTemplateUser?: Maybe<FormTemplateUser>;
  /** Reads a single `FormTemplateUser` using its globally unique `ID`. */
  formTemplateUserByNodeId?: Maybe<FormTemplateUser>;
  /** Reads and enables pagination through a set of `FormTemplateUser`. */
  formTemplateUsers?: Maybe<FormTemplateUsersConnection>;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplates?: Maybe<FormTemplatesConnection>;
  formUser?: Maybe<FormUser>;
  /** Reads a single `FormUser` using its globally unique `ID`. */
  formUserByNodeId?: Maybe<FormUser>;
  /** Reads and enables pagination through a set of `FormUser`. */
  formUsers?: Maybe<FormUsersConnection>;
  /** Reads and enables pagination through a set of `Form`. */
  forms?: Maybe<FormsConnection>;
  group?: Maybe<Group>;
  /** Reads a single `Group` using its globally unique `ID`. */
  groupByNodeId?: Maybe<Group>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers?: Maybe<GroupUsersConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  groups?: Maybe<GroupsConnection>;
  isValidJson?: Maybe<Scalars['Boolean']['output']>;
  isValidJsonArray?: Maybe<Scalars['Boolean']['output']>;
  issuance?: Maybe<Issuance>;
  issuanceByEquipmentIdAndSerialNumber?: Maybe<Issuance>;
  /** Reads a single `Issuance` using its globally unique `ID`. */
  issuanceByNodeId?: Maybe<Issuance>;
  /** Reads and enables pagination through a set of `Issuance`. */
  issuances?: Maybe<IssuancesConnection>;
  job?: Maybe<Job>;
  /** Reads a single `Job` using its globally unique `ID`. */
  jobByNodeId?: Maybe<Job>;
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** Reads a single `JobSendingEmail` using its globally unique `ID`. */
  jobSendingEmailByNodeId?: Maybe<JobSendingEmail>;
  /** Reads and enables pagination through a set of `JobSendingEmailCategory`. */
  jobSendingEmailCategories?: Maybe<JobSendingEmailCategoriesConnection>;
  jobSendingEmailCategory?: Maybe<JobSendingEmailCategory>;
  /** Reads a single `JobSendingEmailCategory` using its globally unique `ID`. */
  jobSendingEmailCategoryByNodeId?: Maybe<JobSendingEmailCategory>;
  jobSendingEmailLog?: Maybe<JobSendingEmailLog>;
  /** Reads a single `JobSendingEmailLog` using its globally unique `ID`. */
  jobSendingEmailLogByNodeId?: Maybe<JobSendingEmailLog>;
  /** Reads and enables pagination through a set of `JobSendingEmailLog`. */
  jobSendingEmailLogs?: Maybe<JobSendingEmailLogsConnection>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmails?: Maybe<JobSendingEmailsConnection>;
  /** Reads and enables pagination through a set of `Job`. */
  jobs?: Maybe<JobsConnection>;
  kind?: Maybe<Kind>;
  kindByDescription?: Maybe<Kind>;
  /** Reads a single `Kind` using its globally unique `ID`. */
  kindByNodeId?: Maybe<Kind>;
  kindBySlug?: Maybe<Kind>;
  /** Reads and enables pagination through a set of `Kind`. */
  kinds?: Maybe<KindsConnection>;
  language?: Maybe<Language>;
  /** Reads a single `Language` using its globally unique `ID`. */
  languageByNodeId?: Maybe<Language>;
  /** Reads and enables pagination through a set of `Language`. */
  languages?: Maybe<LanguagesConnection>;
  loginTransaction?: Maybe<LoginTransaction>;
  /** Reads a single `LoginTransaction` using its globally unique `ID`. */
  loginTransactionByNodeId?: Maybe<LoginTransaction>;
  /** Reads and enables pagination through a set of `LoginTransaction`. */
  loginTransactions?: Maybe<LoginTransactionsConnection>;
  metric?: Maybe<Metric>;
  /** Reads a single `Metric` using its globally unique `ID`. */
  metricByNodeId?: Maybe<Metric>;
  /** Reads and enables pagination through a set of `Metric`. */
  metrics?: Maybe<MetricsConnection>;
  migration?: Maybe<Migration>;
  /** Reads a single `Migration` using its globally unique `ID`. */
  migrationByNodeId?: Maybe<Migration>;
  /** Reads and enables pagination through a set of `Migration`. */
  migrations?: Maybe<MigrationsConnection>;
  news?: Maybe<News>;
  /** Reads a single `News` using its globally unique `ID`. */
  newsByNodeId?: Maybe<News>;
  /** Reads and enables pagination through a set of `News`. */
  newses?: Maybe<NewsConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  organization?: Maybe<Organization>;
  /** Reads a single `Organization` using its globally unique `ID`. */
  organizationByNodeId?: Maybe<Organization>;
  organizationUser?: Maybe<OrganizationUser>;
  /** Reads a single `OrganizationUser` using its globally unique `ID`. */
  organizationUserByNodeId?: Maybe<OrganizationUser>;
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  organizationUsers?: Maybe<OrganizationUsersConnection>;
  /** Reads and enables pagination through a set of `Organization`. */
  organizations?: Maybe<OrganizationsConnection>;
  /** Reads and enables pagination through a set of `PasswordReset`. */
  passwordResets?: Maybe<PasswordResetsConnection>;
  personalAccessToken?: Maybe<PersonalAccessToken>;
  /** Reads a single `PersonalAccessToken` using its globally unique `ID`. */
  personalAccessTokenByNodeId?: Maybe<PersonalAccessToken>;
  personalAccessTokenByToken?: Maybe<PersonalAccessToken>;
  /** Reads and enables pagination through a set of `PersonalAccessToken`. */
  personalAccessTokens?: Maybe<PersonalAccessTokensConnection>;
  profile?: Maybe<Profile>;
  /** Reads a single `Profile` using its globally unique `ID`. */
  profileByNodeId?: Maybe<Profile>;
  /** Reads and enables pagination through a set of `Profile`. */
  profiles?: Maybe<ProfilesConnection>;
  project?: Maybe<Project>;
  /** Reads a single `Project` using its globally unique `ID`. */
  projectByNodeId?: Maybe<Project>;
  projectUser?: Maybe<ProjectUser>;
  /** Reads a single `ProjectUser` using its globally unique `ID`. */
  projectUserByNodeId?: Maybe<ProjectUser>;
  /** Reads and enables pagination through a set of `ProjectUser`. */
  projectUsers?: Maybe<ProjectUsersConnection>;
  /** Reads and enables pagination through a set of `Project`. */
  projects?: Maybe<ProjectsConnection>;
  /** Reads and enables pagination through a set of `Property`. */
  properties?: Maybe<PropertiesConnection>;
  property?: Maybe<Property>;
  propertyByDescription?: Maybe<Property>;
  propertyByHint?: Maybe<Property>;
  /** Reads a single `Property` using its globally unique `ID`. */
  propertyByNodeId?: Maybe<Property>;
  propertyBySlug?: Maybe<Property>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  role?: Maybe<Role>;
  roleByName?: Maybe<Role>;
  /** Reads a single `Role` using its globally unique `ID`. */
  roleByNodeId?: Maybe<Role>;
  roleUser?: Maybe<RoleUser>;
  /** Reads a single `RoleUser` using its globally unique `ID`. */
  roleUserByNodeId?: Maybe<RoleUser>;
  roleUserOrganization?: Maybe<RoleUserOrganization>;
  /** Reads a single `RoleUserOrganization` using its globally unique `ID`. */
  roleUserOrganizationByNodeId?: Maybe<RoleUserOrganization>;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations?: Maybe<RoleUserOrganizationsConnection>;
  /** Reads and enables pagination through a set of `RoleUser`. */
  roleUsers?: Maybe<RoleUsersConnection>;
  /** Reads and enables pagination through a set of `Role`. */
  roles?: Maybe<RolesConnection>;
  scheduler?: Maybe<Scheduler>;
  /** Reads a single `Scheduler` using its globally unique `ID`. */
  schedulerByNodeId?: Maybe<Scheduler>;
  schedulerField?: Maybe<SchedulerField>;
  /** Reads a single `SchedulerField` using its globally unique `ID`. */
  schedulerFieldByNodeId?: Maybe<SchedulerField>;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFields?: Maybe<SchedulerFieldsConnection>;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers?: Maybe<SchedulersConnection>;
  sentMail?: Maybe<SentMail>;
  /** Reads a single `SentMail` using its globally unique `ID`. */
  sentMailByNodeId?: Maybe<SentMail>;
  /** Reads and enables pagination through a set of `SentMail`. */
  sentMails?: Maybe<SentMailConnection>;
  session?: Maybe<Session>;
  /** Reads a single `Session` using its globally unique `ID`. */
  sessionByNodeId?: Maybe<Session>;
  /** Reads and enables pagination through a set of `Session`. */
  sessions?: Maybe<SessionsConnection>;
  setting?: Maybe<Setting>;
  settingByDescription?: Maybe<Setting>;
  /** Reads a single `Setting` using its globally unique `ID`. */
  settingByNodeId?: Maybe<Setting>;
  settingGroup?: Maybe<SettingGroup>;
  settingGroupByDescription?: Maybe<SettingGroup>;
  /** Reads a single `SettingGroup` using its globally unique `ID`. */
  settingGroupByNodeId?: Maybe<SettingGroup>;
  /** Reads and enables pagination through a set of `SettingGroup`. */
  settingGroups?: Maybe<SettingGroupsConnection>;
  /** Reads and enables pagination through a set of `Setting`. */
  settings?: Maybe<SettingsConnection>;
  subscription?: Maybe<Subscription>;
  /** Reads a single `Subscription` using its globally unique `ID`. */
  subscriptionByNodeId?: Maybe<Subscription>;
  subscriptionItem?: Maybe<SubscriptionItem>;
  /** Reads a single `SubscriptionItem` using its globally unique `ID`. */
  subscriptionItemByNodeId?: Maybe<SubscriptionItem>;
  subscriptionItemBySubscriptionIdAndStripePlan?: Maybe<SubscriptionItem>;
  /** Reads and enables pagination through a set of `SubscriptionItem`. */
  subscriptionItems?: Maybe<SubscriptionItemsConnection>;
  /** Reads and enables pagination through a set of `Subscription`. */
  subscriptions?: Maybe<SubscriptionsConnection>;
  systemEvent?: Maybe<SystemEvent>;
  /** Reads a single `SystemEvent` using its globally unique `ID`. */
  systemEventByNodeId?: Maybe<SystemEvent>;
  /** Reads and enables pagination through a set of `SystemEvent`. */
  systemEvents?: Maybe<SystemEventsConnection>;
  team?: Maybe<Team>;
  /** Reads a single `Team` using its globally unique `ID`. */
  teamByNodeId?: Maybe<Team>;
  /** Reads and enables pagination through a set of `TeamUser`. */
  teamUsers?: Maybe<TeamUsersConnection>;
  /** Reads and enables pagination through a set of `Team`. */
  teams?: Maybe<TeamsConnection>;
  /** Reads and enables pagination through a set of `TelescopeEntry`. */
  telescopeEntries?: Maybe<TelescopeEntriesConnection>;
  /** Reads and enables pagination through a set of `TelescopeEntriesTag`. */
  telescopeEntriesTags?: Maybe<TelescopeEntriesTagsConnection>;
  telescopeEntry?: Maybe<TelescopeEntry>;
  /** Reads a single `TelescopeEntry` using its globally unique `ID`. */
  telescopeEntryByNodeId?: Maybe<TelescopeEntry>;
  telescopeEntryByUuid?: Maybe<TelescopeEntry>;
  /** Reads and enables pagination through a set of `TelescopeMonitoring`. */
  telescopeMonitorings?: Maybe<TelescopeMonitoringsConnection>;
  tool?: Maybe<Tool>;
  /** Reads a single `Tool` using its globally unique `ID`. */
  toolByNodeId?: Maybe<Tool>;
  /** Reads and enables pagination through a set of `ToolUser`. */
  toolUsers?: Maybe<ToolUsersConnection>;
  /** Reads and enables pagination through a set of `Tool`. */
  tools?: Maybe<ToolsConnection>;
  tooltype?: Maybe<Tooltype>;
  /** Reads a single `Tooltype` using its globally unique `ID`. */
  tooltypeByNodeId?: Maybe<Tooltype>;
  /** Reads and enables pagination through a set of `Tooltype`. */
  tooltypes?: Maybe<TooltypesConnection>;
  user?: Maybe<User>;
  userByFacebookId?: Maybe<User>;
  userByGoogleId?: Maybe<User>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  userInvite?: Maybe<UserInvite>;
  /** Reads a single `UserInvite` using its globally unique `ID`. */
  userInviteByNodeId?: Maybe<UserInvite>;
  userInviteByToken?: Maybe<UserInvite>;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites?: Maybe<UserInvitesConnection>;
  userSetting?: Maybe<UserSetting>;
  /** Reads a single `UserSetting` using its globally unique `ID`. */
  userSettingByNodeId?: Maybe<UserSetting>;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettings?: Maybe<UserSettingsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  verificationToken?: Maybe<VerificationToken>;
  /** Reads a single `VerificationToken` using its globally unique `ID`. */
  verificationTokenByNodeId?: Maybe<VerificationToken>;
  verificationTokenType?: Maybe<VerificationTokenType>;
  /** Reads a single `VerificationTokenType` using its globally unique `ID`. */
  verificationTokenTypeByNodeId?: Maybe<VerificationTokenType>;
  /** Reads and enables pagination through a set of `VerificationTokenType`. */
  verificationTokenTypes?: Maybe<VerificationTokenTypesConnection>;
  /** Reads and enables pagination through a set of `VerificationToken`. */
  verificationTokens?: Maybe<VerificationTokensConnection>;
  /** Reads and enables pagination through a set of `VwFieldPropertiesPivot`. */
  vwFieldPropertiesPivots?: Maybe<VwFieldPropertiesPivotsConnection>;
  /** Reads and enables pagination through a set of `VwFieldPropertyOptionAnswer`. */
  vwFieldPropertyOptionAnswers?: Maybe<VwFieldPropertyOptionAnswersConnection>;
  /** Reads and enables pagination through a set of `VwFieldPropertyOptionChoice`. */
  vwFieldPropertyOptionChoices?: Maybe<VwFieldPropertyOptionChoicesConnection>;
  /** Reads and enables pagination through a set of `WebsocketsStatisticsEntry`. */
  websocketsStatisticsEntries?: Maybe<WebsocketsStatisticsEntriesConnection>;
  websocketsStatisticsEntry?: Maybe<WebsocketsStatisticsEntry>;
  /** Reads a single `WebsocketsStatisticsEntry` using its globally unique `ID`. */
  websocketsStatisticsEntryByNodeId?: Maybe<WebsocketsStatisticsEntry>;
  workType?: Maybe<WorkType>;
  /** Reads a single `WorkType` using its globally unique `ID`. */
  workTypeByNodeId?: Maybe<WorkType>;
  /** Reads and enables pagination through a set of `WorkType`. */
  workTypes?: Maybe<WorkTypesConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AbilityCondition>;
  filter?: InputMaybe<AbilityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AbilitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilityArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilityByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilityRoleArgs = {
  abilityId: Scalars['BigInt']['input'];
  roleId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilityRoleByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAbilityRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AbilityRoleCondition>;
  filter?: InputMaybe<AbilityRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAdminArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAdminByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAdminsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllowedSettingValueArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAllowedSettingValueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAllowedSettingValuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AllowedSettingValueCondition>;
  filter?: InputMaybe<AllowedSettingValueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AllowedSettingValuesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  filter?: InputMaybe<AttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCertificationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCertificationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCertificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CertificationCondition>;
  filter?: InputMaybe<CertificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompaniesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentEventArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentEventCondition>;
  filter?: InputMaybe<ComponentEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentPropertyCondition>;
  filter?: InputMaybe<ComponentPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentPropertyArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentPropertyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryComponentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ComponentCondition>;
  filter?: InputMaybe<ComponentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCourseArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCourseByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCoursesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CourseCondition>;
  filter?: InputMaybe<CourseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDatatypeArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDatatypeByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDatatypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDatatypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DatatypeCondition>;
  filter?: InputMaybe<DatatypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DatatypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentTypeArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentTypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentTypeCondition>;
  filter?: InputMaybe<EquipmentTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryErrorReportArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryErrorReportByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryErrorReportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ErrorReportCondition>;
  filter?: InputMaybe<ErrorReportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ErrorReportsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFailedJobArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFailedJobByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFailedJobByUuidArgs = {
  uuid: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFailedJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FailedJobCondition>;
  filter?: InputMaybe<FailedJobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FailedJobsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldActionArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldActionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldActionCondition>;
  filter?: InputMaybe<FieldActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldPropertyCondition>;
  filter?: InputMaybe<FieldPropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldPropertyArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldPropertyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldTranslationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldTranslationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldTranslationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldTranslationCondition>;
  filter?: InputMaybe<FieldTranslationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FieldCondition>;
  filter?: InputMaybe<FieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormFieldArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormFieldByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormFieldCondition>;
  filter?: InputMaybe<FillupFormFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormOrganizationArgs = {
  formId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormOrganizationCondition>;
  filter?: InputMaybe<FormOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateGroupArgs = {
  formTemplateId: Scalars['BigInt']['input'];
  groupId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateGroupByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateGroupCondition>;
  filter?: InputMaybe<FormTemplateGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateOrganizationArgs = {
  formTemplateId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateOrganizationCondition>;
  filter?: InputMaybe<FormTemplateOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateProjectArgs = {
  formTemplateId: Scalars['BigInt']['input'];
  projectId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateProjectByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateProjectCondition>;
  filter?: InputMaybe<FormTemplateProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateTeamArgs = {
  formTemplateId: Scalars['BigInt']['input'];
  teamId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateTeamByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateTeamCondition>;
  filter?: InputMaybe<FormTemplateTeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateUserArgs = {
  formTemplateId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplateUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateUserCondition>;
  filter?: InputMaybe<FormTemplateUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormUserArgs = {
  formId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFormUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormUserCondition>;
  filter?: InputMaybe<FormUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupUserCondition>;
  filter?: InputMaybe<GroupUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryIsValidJsonArgs = {
  pValue?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryIsValidJsonArrayArgs = {
  pValue?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryIssuanceArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryIssuanceByEquipmentIdAndSerialNumberArgs = {
  equipmentId: Scalars['BigInt']['input'];
  serialNumber: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryIssuanceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryIssuancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IssuanceCondition>;
  filter?: InputMaybe<IssuanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCategoryCondition>;
  filter?: InputMaybe<JobSendingEmailCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailCategoryArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailCategoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailLogArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailLogByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailLogCondition>;
  filter?: InputMaybe<JobSendingEmailLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobSendingEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryKindArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKindByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKindByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKindBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryKindsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<KindCondition>;
  filter?: InputMaybe<KindFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<KindsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLanguagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LanguageCondition>;
  filter?: InputMaybe<LanguageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanguagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLoginTransactionArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoginTransactionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoginTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LoginTransactionCondition>;
  filter?: InputMaybe<LoginTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LoginTransactionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMetricArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMetricByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMetricsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MetricCondition>;
  filter?: InputMaybe<MetricFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MigrationCondition>;
  filter?: InputMaybe<MigrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNewsArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNewsByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNewsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NewsCondition>;
  filter?: InputMaybe<NewsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationUserArgs = {
  organizationId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationUserCondition>;
  filter?: InputMaybe<OrganizationUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPasswordResetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PasswordResetCondition>;
  filter?: InputMaybe<PasswordResetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PasswordResetsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonalAccessTokenArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonalAccessTokenByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonalAccessTokenByTokenArgs = {
  token: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonalAccessTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersonalAccessTokenCondition>;
  filter?: InputMaybe<PersonalAccessTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersonalAccessTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProfileArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProfileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProfileCondition>;
  filter?: InputMaybe<ProfileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectUserArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectUserCondition>;
  filter?: InputMaybe<ProjectUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyByHintArgs = {
  hint: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUserArgs = {
  roleId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUserOrganizationArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUserOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserCondition>;
  filter?: InputMaybe<RoleUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulerArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulerFieldArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulerFieldByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulerFieldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySentMailArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySentMailByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySentMailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SentMailCondition>;
  filter?: InputMaybe<SentMailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SentMailOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySessionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SessionCondition>;
  filter?: InputMaybe<SessionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingGroupArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingGroupByDescriptionArgs = {
  description: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingGroupByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SettingGroupCondition>;
  filter?: InputMaybe<SettingGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettingGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SettingCondition>;
  filter?: InputMaybe<SettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionItemArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionItemByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionItemBySubscriptionIdAndStripePlanArgs = {
  stripePlan: Scalars['String']['input'];
  subscriptionId: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SubscriptionItemCondition>;
  filter?: InputMaybe<SubscriptionItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SubscriptionCondition>;
  filter?: InputMaybe<SubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemEventArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemEventByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SystemEventCondition>;
  filter?: InputMaybe<SystemEventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemEventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamUserCondition>;
  filter?: InputMaybe<TeamUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeEntriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TelescopeEntryCondition>;
  filter?: InputMaybe<TelescopeEntryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TelescopeEntriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeEntriesTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TelescopeEntriesTagCondition>;
  filter?: InputMaybe<TelescopeEntriesTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TelescopeEntriesTagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeEntryArgs = {
  sequence: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeEntryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeEntryByUuidArgs = {
  uuid: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTelescopeMonitoringsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TelescopeMonitoringCondition>;
  filter?: InputMaybe<TelescopeMonitoringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TelescopeMonitoringsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryToolArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryToolByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryToolUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolUserCondition>;
  filter?: InputMaybe<ToolUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTooltypeArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTooltypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTooltypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TooltypeCondition>;
  filter?: InputMaybe<TooltypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByFacebookIdArgs = {
  facebookId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByGoogleIdArgs = {
  googleId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInviteArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInviteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInviteByTokenArgs = {
  token: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSettingArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSettingByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserSettingCondition>;
  filter?: InputMaybe<UserSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokenArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokenByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokenTypeArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokenTypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokenTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenTypeCondition>;
  filter?: InputMaybe<VerificationTokenTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokenTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenCondition>;
  filter?: InputMaybe<VerificationTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVwFieldPropertiesPivotsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VwFieldPropertiesPivotCondition>;
  filter?: InputMaybe<VwFieldPropertiesPivotFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VwFieldPropertiesPivotsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVwFieldPropertyOptionAnswersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VwFieldPropertyOptionAnswerCondition>;
  filter?: InputMaybe<VwFieldPropertyOptionAnswerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VwFieldPropertyOptionAnswersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVwFieldPropertyOptionChoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VwFieldPropertyOptionChoiceCondition>;
  filter?: InputMaybe<VwFieldPropertyOptionChoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VwFieldPropertyOptionChoicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsocketsStatisticsEntriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WebsocketsStatisticsEntryCondition>;
  filter?: InputMaybe<WebsocketsStatisticsEntryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WebsocketsStatisticsEntriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsocketsStatisticsEntryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebsocketsStatisticsEntryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWorkTypeArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWorkTypeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWorkTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WorkTypeCondition>;
  filter?: InputMaybe<WorkTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkTypesOrderBy>>;
};

export type Role = Node & {
  __typename?: 'Role';
  /** Reads and enables pagination through a set of `Ability`. */
  abilitiesByAbilityRoleRoleIdAndAbilityId: RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyConnection;
  /** Reads and enables pagination through a set of `AbilityRole`. */
  abilityRoles: AbilityRolesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  label?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByRoleUserOrganizationRoleIdAndOrgId: RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByUserInviteRoleIdAndOrganizationId: RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyConnection;
  /** Reads a single `Role` that is related to this `Role`. */
  parentRole?: Maybe<Role>;
  parentRoleId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
  /** Reads and enables pagination through a set of `RoleUser`. */
  roleUsers: RoleUsersConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByParentRoleId: RolesConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByUserInviteRoleIdAndTeamId: RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByRoleUserOrganizationRoleIdAndUserId: RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByRoleUserRoleIdAndUserId: RoleUsersByRoleUserRoleIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserInviteRoleIdAndAdminId: RoleUsersByUserInviteRoleIdAndAdminIdManyToManyConnection;
};


export type RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AbilityCondition>;
  filter?: InputMaybe<AbilityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AbilitiesOrderBy>>;
};


export type RoleAbilityRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AbilityRoleCondition>;
  filter?: InputMaybe<AbilityRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};


export type RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type RoleOrganizationsByUserInviteRoleIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type RoleRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};


export type RoleRoleUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserCondition>;
  filter?: InputMaybe<RoleUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};


export type RoleRolesByParentRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type RoleTeamsByUserInviteRoleIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type RoleUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};


export type RoleUsersByRoleUserOrganizationRoleIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type RoleUsersByRoleUserRoleIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type RoleUsersByUserInviteRoleIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Ability` values, with data from `AbilityRole`. */
export type RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyConnection = {
  __typename?: 'RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyConnection';
  /** A list of edges which contains the `Ability`, info from the `AbilityRole`, and the cursor to aid in pagination. */
  edges: Array<RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyEdge>;
  /** A list of `Ability` objects. */
  nodes: Array<Ability>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ability` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Ability` edge in the connection, with data from `AbilityRole`. */
export type RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyEdge = {
  __typename?: 'RoleAbilitiesByAbilityRoleRoleIdAndAbilityIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Ability` at the end of the edge. */
  node: Ability;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RoleCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentRoleId` field. */
  parentRoleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’ */
export type RoleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleFilter>>;
  /** Filter by the object’s `parentRoleId` field. */
  parentRoleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Role` */
export type RoleInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  parentRoleId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Organization` values, with data from `RoleUserOrganization`. */
export type RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyConnection = {
  __typename?: 'RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `RoleUserOrganization`. */
export type RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyEdge = {
  __typename?: 'RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizationsByOrgId: RoleUserOrganizationsConnection;
};


/** A `Organization` edge in the connection, with data from `RoleUserOrganization`. */
export type RoleOrganizationsByRoleUserOrganizationRoleIdAndOrgIdManyToManyEdgeRoleUserOrganizationsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `UserInvite`. */
export type RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type RoleOrganizationsByUserInviteRoleIdAndOrganizationIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** Represents an update to a `Role`. Fields that are set will be updated. */
export type RolePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentRoleId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Team` values, with data from `UserInvite`. */
export type RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyConnection = {
  __typename?: 'RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `UserInvite`. */
export type RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyEdge = {
  __typename?: 'RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Team` edge in the connection, with data from `UserInvite`. */
export type RoleTeamsByUserInviteRoleIdAndTeamIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

export type RoleUser = Node & {
  __typename?: 'RoleUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Role` that is related to this `RoleUser`. */
  role?: Maybe<Role>;
  roleId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `RoleUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `RoleUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RoleUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `RoleUser` object types. All fields are combined with a logical ‘and.’ */
export type RoleUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleUserFilter>>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `RoleUser` */
export type RoleUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  roleId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

export type RoleUserOrganization = Node & {
  __typename?: 'RoleUserOrganization';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `RoleUserOrganization`. */
  org?: Maybe<Organization>;
  orgId: Scalars['BigInt']['output'];
  /** Reads a single `Role` that is related to this `RoleUserOrganization`. */
  role?: Maybe<Role>;
  roleId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `RoleUserOrganization`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `RoleUserOrganization` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type RoleUserOrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `RoleUserOrganization` object types. All fields are combined with a logical ‘and.’ */
export type RoleUserOrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleUserOrganizationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleUserOrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleUserOrganizationFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `RoleUserOrganization` */
export type RoleUserOrganizationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  orgId: Scalars['BigInt']['input'];
  roleId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** Represents an update to a `RoleUserOrganization`. Fields that are set will be updated. */
export type RoleUserOrganizationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  orgId?: InputMaybe<Scalars['BigInt']['input']>;
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `RoleUserOrganization` values. */
export type RoleUserOrganizationsConnection = {
  __typename?: 'RoleUserOrganizationsConnection';
  /** A list of edges which contains the `RoleUserOrganization` and cursor to aid in pagination. */
  edges: Array<RoleUserOrganizationsEdge>;
  /** A list of `RoleUserOrganization` objects. */
  nodes: Array<RoleUserOrganization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoleUserOrganization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoleUserOrganization` edge in the connection. */
export type RoleUserOrganizationsEdge = {
  __typename?: 'RoleUserOrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RoleUserOrganization` at the end of the edge. */
  node: RoleUserOrganization;
};

/** Methods to use when ordering `RoleUserOrganization`. */
export enum RoleUserOrganizationsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Represents an update to a `RoleUser`. Fields that are set will be updated. */
export type RoleUserPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `User` values, with data from `RoleUserOrganization`. */
export type RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyConnection = {
  __typename?: 'RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `RoleUserOrganization`. */
export type RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyEdge = {
  __typename?: 'RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
};


/** A `User` edge in the connection, with data from `RoleUserOrganization`. */
export type RoleUsersByRoleUserOrganizationRoleIdAndUserIdManyToManyEdgeRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `RoleUser`. */
export type RoleUsersByRoleUserRoleIdAndUserIdManyToManyConnection = {
  __typename?: 'RoleUsersByRoleUserRoleIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `RoleUser`, and the cursor to aid in pagination. */
  edges: Array<RoleUsersByRoleUserRoleIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `RoleUser`. */
export type RoleUsersByRoleUserRoleIdAndUserIdManyToManyEdge = {
  __typename?: 'RoleUsersByRoleUserRoleIdAndUserIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `User` values, with data from `UserInvite`. */
export type RoleUsersByUserInviteRoleIdAndAdminIdManyToManyConnection = {
  __typename?: 'RoleUsersByUserInviteRoleIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<RoleUsersByUserInviteRoleIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `UserInvite`. */
export type RoleUsersByUserInviteRoleIdAndAdminIdManyToManyEdge = {
  __typename?: 'RoleUsersByUserInviteRoleIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvitesByAdminId: UserInvitesConnection;
};


/** A `User` edge in the connection, with data from `UserInvite`. */
export type RoleUsersByUserInviteRoleIdAndAdminIdManyToManyEdgeUserInvitesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `RoleUser` values. */
export type RoleUsersConnection = {
  __typename?: 'RoleUsersConnection';
  /** A list of edges which contains the `RoleUser` and cursor to aid in pagination. */
  edges: Array<RoleUsersEdge>;
  /** A list of `RoleUser` objects. */
  nodes: Array<RoleUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoleUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RoleUser` edge in the connection. */
export type RoleUsersEdge = {
  __typename?: 'RoleUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RoleUser` at the end of the edge. */
  node: RoleUser;
};

/** Methods to use when ordering `RoleUser`. */
export enum RoleUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Role` values. */
export type RolesConnection = {
  __typename?: 'RolesConnection';
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection. */
export type RolesEdge = {
  __typename?: 'RolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
};

/** Methods to use when ordering `Role`. */
export enum RolesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ParentRoleIdAsc = 'PARENT_ROLE_ID_ASC',
  ParentRoleIdDesc = 'PARENT_ROLE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Scheduler = Node & {
  __typename?: 'Scheduler';
  /** Reads a single `Admin` that is related to this `Scheduler`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `FillupForm` that is related to this `Scheduler`. */
  fillupform?: Maybe<FillupForm>;
  fillupformId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Form` that is related to this `Scheduler`. */
  form?: Maybe<Form>;
  formId: Scalars['BigInt']['output'];
  /** Reads a single `FormTemplate` that is related to this `Scheduler`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Group` that is related to this `Scheduler`. */
  group?: Maybe<Group>;
  groupId?: Maybe<Scalars['BigInt']['output']>;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Scheduler`. */
  org?: Maybe<Organization>;
  orgId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `SchedulerField` that is related to this `Scheduler`. */
  schedulerFields?: Maybe<SchedulerField>;
  schedulerFieldsId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `Team` that is related to this `Scheduler`. */
  team?: Maybe<Team>;
  teamId?: Maybe<Scalars['BigInt']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `Scheduler`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['BigInt']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Scheduler` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SchedulerCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fillupformId` field. */
  fillupformId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `schedulerFieldsId` field. */
  schedulerFieldsId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SchedulerField = Node & {
  __typename?: 'SchedulerField';
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerSchedulerFieldsIdAndAdminId: SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Field` that is related to this `SchedulerField`. */
  field?: Maybe<Field>;
  fieldId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerSchedulerFieldsIdAndFillupformId: SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyConnection;
  /** Reads a single `Form` that is related to this `SchedulerField`. */
  form?: Maybe<Form>;
  formId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads a single `FormTemplate` that is related to this `SchedulerField`. */
  formTemplate?: Maybe<FormTemplate>;
  formTemplateId?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateId: SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerSchedulerFieldsIdAndFormId: SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerSchedulerFieldsIdAndGroupId: SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerSchedulerFieldsIdAndOrgId: SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
  sortOrder: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerSchedulerFieldsIdAndTeamId: SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerSchedulerFieldsIdAndUserId: SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyConnection;
};


export type SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type SchedulerFieldSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyConnection = {
  __typename?: 'SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyEdge = {
  __typename?: 'SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldAdminsBySchedulerSchedulerFieldsIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/**
 * A condition to be used against `SchedulerField` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SchedulerFieldCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyConnection = {
  __typename?: 'SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyEdge = {
  __typename?: 'SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFillupFormsBySchedulerSchedulerFieldsIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `SchedulerField` object types. All fields are combined with a logical ‘and.’ */
export type SchedulerFieldFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SchedulerFieldFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SchedulerFieldFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SchedulerFieldFilter>>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFormTemplatesBySchedulerSchedulerFieldsIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyConnection = {
  __typename?: 'SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyEdge = {
  __typename?: 'SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldFormsBySchedulerSchedulerFieldsIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyConnection = {
  __typename?: 'SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyEdge = {
  __typename?: 'SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldGroupsBySchedulerSchedulerFieldsIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `SchedulerField` */
export type SchedulerFieldInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId: Scalars['BigInt']['input'];
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  sortOrder: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyConnection = {
  __typename?: 'SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyEdge = {
  __typename?: 'SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldOrganizationsBySchedulerSchedulerFieldsIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** Represents an update to a `SchedulerField`. Fields that are set will be updated. */
export type SchedulerFieldPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  sortOrder?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyConnection = {
  __typename?: 'SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyEdge = {
  __typename?: 'SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldTeamsBySchedulerSchedulerFieldsIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyConnection = {
  __typename?: 'SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyEdge = {
  __typename?: 'SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type SchedulerFieldUsersBySchedulerSchedulerFieldsIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `SchedulerField` values. */
export type SchedulerFieldsConnection = {
  __typename?: 'SchedulerFieldsConnection';
  /** A list of edges which contains the `SchedulerField` and cursor to aid in pagination. */
  edges: Array<SchedulerFieldsEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection. */
export type SchedulerFieldsEdge = {
  __typename?: 'SchedulerFieldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
};

/** Methods to use when ordering `SchedulerField`. */
export enum SchedulerFieldsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A filter to be used against `Scheduler` object types. All fields are combined with a logical ‘and.’ */
export type SchedulerFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SchedulerFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fillupformId` field. */
  fillupformId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formTemplateId` field. */
  formTemplateId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SchedulerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SchedulerFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `schedulerFieldsId` field. */
  schedulerFieldsId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Scheduler` */
export type SchedulerInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fillupformId?: InputMaybe<Scalars['BigInt']['input']>;
  formId: Scalars['BigInt']['input'];
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  orgId?: InputMaybe<Scalars['BigInt']['input']>;
  schedulerFieldsId?: InputMaybe<Scalars['BigInt']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Scheduler`. Fields that are set will be updated. */
export type SchedulerPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  fillupformId?: InputMaybe<Scalars['BigInt']['input']>;
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  formTemplateId?: InputMaybe<Scalars['BigInt']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  orgId?: InputMaybe<Scalars['BigInt']['input']>;
  schedulerFieldsId?: InputMaybe<Scalars['BigInt']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Scheduler` values. */
export type SchedulersConnection = {
  __typename?: 'SchedulersConnection';
  /** A list of edges which contains the `Scheduler` and cursor to aid in pagination. */
  edges: Array<SchedulersEdge>;
  /** A list of `Scheduler` objects. */
  nodes: Array<Scheduler>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scheduler` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Scheduler` edge in the connection. */
export type SchedulersEdge = {
  __typename?: 'SchedulersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Scheduler` at the end of the edge. */
  node: Scheduler;
};

/** Methods to use when ordering `Scheduler`. */
export enum SchedulersOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  FillupformIdAsc = 'FILLUPFORM_ID_ASC',
  FillupformIdDesc = 'FILLUPFORM_ID_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  FormTemplateIdAsc = 'FORM_TEMPLATE_ID_ASC',
  FormTemplateIdDesc = 'FORM_TEMPLATE_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SchedulerFieldsIdAsc = 'SCHEDULER_FIELDS_ID_ASC',
  SchedulerFieldsIdDesc = 'SCHEDULER_FIELDS_ID_DESC',
  TeamIdAsc = 'TEAM_ID_ASC',
  TeamIdDesc = 'TEAM_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type SentMail = Node & {
  __typename?: 'SentMail';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  log: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `SentMail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SentMailCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `log` field. */
  log?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `SentMail` values. */
export type SentMailConnection = {
  __typename?: 'SentMailConnection';
  /** A list of edges which contains the `SentMail` and cursor to aid in pagination. */
  edges: Array<SentMailEdge>;
  /** A list of `SentMail` objects. */
  nodes: Array<SentMail>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SentMail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SentMail` edge in the connection. */
export type SentMailEdge = {
  __typename?: 'SentMailEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SentMail` at the end of the edge. */
  node: SentMail;
};

/** A filter to be used against `SentMail` object types. All fields are combined with a logical ‘and.’ */
export type SentMailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SentMailFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `log` field. */
  log?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SentMailFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SentMailFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `SentMail` */
export type SentMailInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  log: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Methods to use when ordering `SentMail`. */
export enum SentMailOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LogAsc = 'LOG_ASC',
  LogDesc = 'LOG_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `SentMail`. Fields that are set will be updated. */
export type SentMailPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  log?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type Session = Node & {
  __typename?: 'Session';
  id: Scalars['String']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  lastActivity: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  payload: Scalars['String']['output'];
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['BigInt']['output']>;
};

/** A condition to be used against `Session` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SessionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lastActivity` field. */
  lastActivity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `payload` field. */
  payload?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userAgent` field. */
  userAgent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `Session` object types. All fields are combined with a logical ‘and.’ */
export type SessionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SessionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastActivity` field. */
  lastActivity?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SessionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SessionFilter>>;
  /** Filter by the object’s `payload` field. */
  payload?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userAgent` field. */
  userAgent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Session` */
export type SessionInput = {
  id: Scalars['String']['input'];
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  lastActivity: Scalars['Int']['input'];
  payload: Scalars['String']['input'];
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** Represents an update to a `Session`. Fields that are set will be updated. */
export type SessionPatch = {
  id?: InputMaybe<Scalars['String']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  lastActivity?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['String']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Session` values. */
export type SessionsConnection = {
  __typename?: 'SessionsConnection';
  /** A list of edges which contains the `Session` and cursor to aid in pagination. */
  edges: Array<SessionsEdge>;
  /** A list of `Session` objects. */
  nodes: Array<Session>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Session` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Session` edge in the connection. */
export type SessionsEdge = {
  __typename?: 'SessionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Session` at the end of the edge. */
  node: Session;
};

/** Methods to use when ordering `Session`. */
export enum SessionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  LastActivityAsc = 'LAST_ACTIVITY_ASC',
  LastActivityDesc = 'LAST_ACTIVITY_DESC',
  Natural = 'NATURAL',
  PayloadAsc = 'PAYLOAD_ASC',
  PayloadDesc = 'PAYLOAD_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserAgentAsc = 'USER_AGENT_ASC',
  UserAgentDesc = 'USER_AGENT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Setting = Node & {
  __typename?: 'Setting';
  /** Reads and enables pagination through a set of `AllowedSettingValue`. */
  allowedSettingValues: AllowedSettingValuesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  /** Reads a single `SettingGroup` that is related to this `Setting`. */
  group?: Maybe<SettingGroup>;
  groupId: Scalars['BigInt']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettings: UserSettingsConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserSettingSettingIdAndUserId: SettingUsersByUserSettingSettingIdAndUserIdManyToManyConnection;
  uuid: Scalars['UUID']['output'];
};


export type SettingAllowedSettingValuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AllowedSettingValueCondition>;
  filter?: InputMaybe<AllowedSettingValueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AllowedSettingValuesOrderBy>>;
};


export type SettingUserSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserSettingCondition>;
  filter?: InputMaybe<UserSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};


export type SettingUsersByUserSettingSettingIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SettingCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’ */
export type SettingFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SettingFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SettingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SettingFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

export type SettingGroup = Node & {
  __typename?: 'SettingGroup';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Setting`. */
  settingsByGroupId: SettingsConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
};


export type SettingGroupSettingsByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SettingCondition>;
  filter?: InputMaybe<SettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/**
 * A condition to be used against `SettingGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SettingGroupCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `SettingGroup` object types. All fields are combined with a logical ‘and.’ */
export type SettingGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SettingGroupFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SettingGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SettingGroupFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `SettingGroup` */
export type SettingGroupInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** Represents an update to a `SettingGroup`. Fields that are set will be updated. */
export type SettingGroupPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `SettingGroup` values. */
export type SettingGroupsConnection = {
  __typename?: 'SettingGroupsConnection';
  /** A list of edges which contains the `SettingGroup` and cursor to aid in pagination. */
  edges: Array<SettingGroupsEdge>;
  /** A list of `SettingGroup` objects. */
  nodes: Array<SettingGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SettingGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SettingGroup` edge in the connection. */
export type SettingGroupsEdge = {
  __typename?: 'SettingGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SettingGroup` at the end of the edge. */
  node: SettingGroup;
};

/** Methods to use when ordering `SettingGroup`. */
export enum SettingGroupsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** An input for mutations affecting `Setting` */
export type SettingInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  groupId: Scalars['BigInt']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export type SettingPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `User` values, with data from `UserSetting`. */
export type SettingUsersByUserSettingSettingIdAndUserIdManyToManyConnection = {
  __typename?: 'SettingUsersByUserSettingSettingIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserSetting`, and the cursor to aid in pagination. */
  edges: Array<SettingUsersByUserSettingSettingIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `UserSetting`. */
export type SettingUsersByUserSettingSettingIdAndUserIdManyToManyEdge = {
  __typename?: 'SettingUsersByUserSettingSettingIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettings: UserSettingsConnection;
};


/** A `User` edge in the connection, with data from `UserSetting`. */
export type SettingUsersByUserSettingSettingIdAndUserIdManyToManyEdgeUserSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserSettingCondition>;
  filter?: InputMaybe<UserSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};

/** A connection to a list of `Setting` values. */
export type SettingsConnection = {
  __typename?: 'SettingsConnection';
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: Array<SettingsEdge>;
  /** A list of `Setting` objects. */
  nodes: Array<Setting>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Setting` edge in the connection. */
export type SettingsEdge = {
  __typename?: 'SettingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Setting` at the end of the edge. */
  node: Setting;
};

/** Methods to use when ordering `Setting`. */
export enum SettingsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

export type Subscription = Node & {
  __typename?: 'Subscription';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  endsAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  stripeId: Scalars['String']['output'];
  stripePlan?: Maybe<Scalars['String']['output']>;
  stripeStatus: Scalars['String']['output'];
  trialEndsAt?: Maybe<Scalars['Datetime']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `Subscription` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SubscriptionCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endsAt` field. */
  endsAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stripeId` field. */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stripePlan` field. */
  stripePlan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stripeStatus` field. */
  stripeStatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `trialEndsAt` field. */
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `Subscription` object types. All fields are combined with a logical ‘and.’ */
export type SubscriptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SubscriptionFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endsAt` field. */
  endsAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SubscriptionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SubscriptionFilter>>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stripeId` field. */
  stripeId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stripePlan` field. */
  stripePlan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stripeStatus` field. */
  stripeStatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trialEndsAt` field. */
  trialEndsAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Subscription` */
export type SubscriptionInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  endsAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  quantity?: InputMaybe<Scalars['Int']['input']>;
  stripeId: Scalars['String']['input'];
  stripePlan?: InputMaybe<Scalars['String']['input']>;
  stripeStatus: Scalars['String']['input'];
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

export type SubscriptionItem = Node & {
  __typename?: 'SubscriptionItem';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  stripeId: Scalars['String']['output'];
  stripePlan: Scalars['String']['output'];
  subscriptionId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `SubscriptionItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SubscriptionItemCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stripeId` field. */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stripePlan` field. */
  stripePlan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subscriptionId` field. */
  subscriptionId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `SubscriptionItem` object types. All fields are combined with a logical ‘and.’ */
export type SubscriptionItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SubscriptionItemFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SubscriptionItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SubscriptionItemFilter>>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stripeId` field. */
  stripeId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stripePlan` field. */
  stripePlan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subscriptionId` field. */
  subscriptionId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `SubscriptionItem` */
export type SubscriptionItemInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  stripeId: Scalars['String']['input'];
  stripePlan: Scalars['String']['input'];
  subscriptionId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `SubscriptionItem`. Fields that are set will be updated. */
export type SubscriptionItemPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  stripePlan?: InputMaybe<Scalars['String']['input']>;
  subscriptionId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `SubscriptionItem` values. */
export type SubscriptionItemsConnection = {
  __typename?: 'SubscriptionItemsConnection';
  /** A list of edges which contains the `SubscriptionItem` and cursor to aid in pagination. */
  edges: Array<SubscriptionItemsEdge>;
  /** A list of `SubscriptionItem` objects. */
  nodes: Array<SubscriptionItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SubscriptionItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SubscriptionItem` edge in the connection. */
export type SubscriptionItemsEdge = {
  __typename?: 'SubscriptionItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SubscriptionItem` at the end of the edge. */
  node: SubscriptionItem;
};

/** Methods to use when ordering `SubscriptionItem`. */
export enum SubscriptionItemsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  StripeIdAsc = 'STRIPE_ID_ASC',
  StripeIdDesc = 'STRIPE_ID_DESC',
  StripePlanAsc = 'STRIPE_PLAN_ASC',
  StripePlanDesc = 'STRIPE_PLAN_DESC',
  SubscriptionIdAsc = 'SUBSCRIPTION_ID_ASC',
  SubscriptionIdDesc = 'SUBSCRIPTION_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Represents an update to a `Subscription`. Fields that are set will be updated. */
export type SubscriptionPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  endsAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  stripePlan?: InputMaybe<Scalars['String']['input']>;
  stripeStatus?: InputMaybe<Scalars['String']['input']>;
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A connection to a list of `Subscription` values. */
export type SubscriptionsConnection = {
  __typename?: 'SubscriptionsConnection';
  /** A list of edges which contains the `Subscription` and cursor to aid in pagination. */
  edges: Array<SubscriptionsEdge>;
  /** A list of `Subscription` objects. */
  nodes: Array<Subscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Subscription` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Subscription` edge in the connection. */
export type SubscriptionsEdge = {
  __typename?: 'SubscriptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Subscription` at the end of the edge. */
  node: Subscription;
};

/** Methods to use when ordering `Subscription`. */
export enum SubscriptionsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  EndsAtAsc = 'ENDS_AT_ASC',
  EndsAtDesc = 'ENDS_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  StripeIdAsc = 'STRIPE_ID_ASC',
  StripeIdDesc = 'STRIPE_ID_DESC',
  StripePlanAsc = 'STRIPE_PLAN_ASC',
  StripePlanDesc = 'STRIPE_PLAN_DESC',
  StripeStatusAsc = 'STRIPE_STATUS_ASC',
  StripeStatusDesc = 'STRIPE_STATUS_DESC',
  TrialEndsAtAsc = 'TRIAL_ENDS_AT_ASC',
  TrialEndsAtDesc = 'TRIAL_ENDS_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type SystemEvent = Node & {
  __typename?: 'SystemEvent';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `SystemEvent` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SystemEventCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `SystemEvent` object types. All fields are combined with a logical ‘and.’ */
export type SystemEventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SystemEventFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SystemEventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SystemEventFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `SystemEvent` */
export type SystemEventInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `SystemEvent`. Fields that are set will be updated. */
export type SystemEventPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `SystemEvent` values. */
export type SystemEventsConnection = {
  __typename?: 'SystemEventsConnection';
  /** A list of edges which contains the `SystemEvent` and cursor to aid in pagination. */
  edges: Array<SystemEventsEdge>;
  /** A list of `SystemEvent` objects. */
  nodes: Array<SystemEvent>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SystemEvent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SystemEvent` edge in the connection. */
export type SystemEventsEdge = {
  __typename?: 'SystemEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SystemEvent` at the end of the edge. */
  node: SystemEvent;
};

/** Methods to use when ordering `SystemEvent`. */
export enum SystemEventsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type Team = Node & {
  __typename?: 'Team';
  /** Reads a single `Admin` that is related to this `Team`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFormTeamIdAndAdminId: TeamAdminsByFormTeamIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerTeamIdAndAdminId: TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerTeamIdAndFillupformId: TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplateTeam`. */
  formTemplateTeams: FormTemplateTeamsConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTeamIdAndCreatedFromTemplateId: TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTemplateTeamTeamIdAndFormTemplateId: TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerTeamIdAndFormTemplateId: TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerTeamIdAndFormId: TeamFormsBySchedulerTeamIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByFormTeamIdAndGroupId: TeamGroupsByFormTeamIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerTeamIdAndGroupId: TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Team`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerTeamIdAndOrgId: TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByUserInviteTeamIdAndOrganizationId: TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByUserInviteTeamIdAndRoleId: TeamRolesByUserInviteTeamIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerTeamIdAndSchedulerFieldsId: TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  /** Reads and enables pagination through a set of `TeamUser`. */
  teamUsers: TeamUsersConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersBySchedulerTeamIdAndUserId: TeamUsersBySchedulerTeamIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByTeamUserTeamIdAndUserId: TeamUsersByTeamUserTeamIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByUserInviteTeamIdAndAdminId: TeamUsersByUserInviteTeamIdAndAdminIdManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
};


export type TeamAdminsByFormTeamIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type TeamAdminsBySchedulerTeamIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type TeamFillupFormsBySchedulerTeamIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type TeamFormTemplateTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateTeamCondition>;
  filter?: InputMaybe<FormTemplateTeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};


export type TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type TeamFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type TeamFormsBySchedulerTeamIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type TeamGroupsByFormTeamIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type TeamGroupsBySchedulerTeamIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type TeamOrganizationsBySchedulerTeamIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type TeamOrganizationsByUserInviteTeamIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type TeamRolesByUserInviteTeamIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type TeamSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type TeamTeamUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamUserCondition>;
  filter?: InputMaybe<TeamUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};


export type TeamUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};


export type TeamUsersBySchedulerTeamIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type TeamUsersByTeamUserTeamIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type TeamUsersByUserInviteTeamIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Form`. */
export type TeamAdminsByFormTeamIdAndAdminIdManyToManyConnection = {
  __typename?: 'TeamAdminsByFormTeamIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<TeamAdminsByFormTeamIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Form`. */
export type TeamAdminsByFormTeamIdAndAdminIdManyToManyEdge = {
  __typename?: 'TeamAdminsByFormTeamIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `Form`. */
export type TeamAdminsByFormTeamIdAndAdminIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyConnection = {
  __typename?: 'TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyEdge = {
  __typename?: 'TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type TeamAdminsBySchedulerTeamIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TeamCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyConnection = {
  __typename?: 'TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyEdge = {
  __typename?: 'TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type TeamFillupFormsBySchedulerTeamIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `Team` object types. All fields are combined with a logical ‘and.’ */
export type TeamFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TeamFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TeamFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TeamFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `Form`. */
export type TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyConnection = {
  __typename?: 'TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyEdge = {
  __typename?: 'TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  formsByCreatedFromTemplateId: FormsConnection;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
};


/** A `FormTemplate` edge in the connection, with data from `Form`. */
export type TeamFormTemplatesByFormTeamIdAndCreatedFromTemplateIdManyToManyEdgeFormsByCreatedFromTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `FormTemplate` values, with data from `FormTemplateTeam`. */
export type TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `FormTemplateTeam`, and the cursor to aid in pagination. */
  edges: Array<TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `FormTemplateTeam`. */
export type TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'TeamFormTemplatesByFormTemplateTeamTeamIdAndFormTemplateIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type TeamFormTemplatesBySchedulerTeamIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type TeamFormsBySchedulerTeamIdAndFormIdManyToManyConnection = {
  __typename?: 'TeamFormsBySchedulerTeamIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamFormsBySchedulerTeamIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type TeamFormsBySchedulerTeamIdAndFormIdManyToManyEdge = {
  __typename?: 'TeamFormsBySchedulerTeamIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type TeamFormsBySchedulerTeamIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Form`. */
export type TeamGroupsByFormTeamIdAndGroupIdManyToManyConnection = {
  __typename?: 'TeamGroupsByFormTeamIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Form`, and the cursor to aid in pagination. */
  edges: Array<TeamGroupsByFormTeamIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Form`. */
export type TeamGroupsByFormTeamIdAndGroupIdManyToManyEdge = {
  __typename?: 'TeamGroupsByFormTeamIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Form`. */
  forms: FormsConnection;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `Form`. */
export type TeamGroupsByFormTeamIdAndGroupIdManyToManyEdgeFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyConnection = {
  __typename?: 'TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyEdge = {
  __typename?: 'TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type TeamGroupsBySchedulerTeamIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `Team` */
export type TeamInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyConnection = {
  __typename?: 'TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyEdge = {
  __typename?: 'TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type TeamOrganizationsBySchedulerTeamIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `UserInvite`. */
export type TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type TeamOrganizationsByUserInviteTeamIdAndOrganizationIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** Represents an update to a `Team`. Fields that are set will be updated. */
export type TeamPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Role` values, with data from `UserInvite`. */
export type TeamRolesByUserInviteTeamIdAndRoleIdManyToManyConnection = {
  __typename?: 'TeamRolesByUserInviteTeamIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<TeamRolesByUserInviteTeamIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `UserInvite`. */
export type TeamRolesByUserInviteTeamIdAndRoleIdManyToManyEdge = {
  __typename?: 'TeamRolesByUserInviteTeamIdAndRoleIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Role` edge in the connection, with data from `UserInvite`. */
export type TeamRolesByUserInviteTeamIdAndRoleIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type TeamSchedulerFieldsBySchedulerTeamIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type TeamUser = {
  __typename?: 'TeamUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Team` that is related to this `TeamUser`. */
  team?: Maybe<Team>;
  teamId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `TeamUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `TeamUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TeamUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `TeamUser` object types. All fields are combined with a logical ‘and.’ */
export type TeamUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TeamUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TeamUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TeamUserFilter>>;
  /** Filter by the object’s `teamId` field. */
  teamId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `TeamUser` */
export type TeamUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  teamId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** A connection to a list of `User` values, with data from `Scheduler`. */
export type TeamUsersBySchedulerTeamIdAndUserIdManyToManyConnection = {
  __typename?: 'TeamUsersBySchedulerTeamIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<TeamUsersBySchedulerTeamIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `Scheduler`. */
export type TeamUsersBySchedulerTeamIdAndUserIdManyToManyEdge = {
  __typename?: 'TeamUsersBySchedulerTeamIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `User` edge in the connection, with data from `Scheduler`. */
export type TeamUsersBySchedulerTeamIdAndUserIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `TeamUser`. */
export type TeamUsersByTeamUserTeamIdAndUserIdManyToManyConnection = {
  __typename?: 'TeamUsersByTeamUserTeamIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `TeamUser`, and the cursor to aid in pagination. */
  edges: Array<TeamUsersByTeamUserTeamIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `TeamUser`. */
export type TeamUsersByTeamUserTeamIdAndUserIdManyToManyEdge = {
  __typename?: 'TeamUsersByTeamUserTeamIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `TeamUser`. */
  teamUsers: TeamUsersConnection;
};


/** A `User` edge in the connection, with data from `TeamUser`. */
export type TeamUsersByTeamUserTeamIdAndUserIdManyToManyEdgeTeamUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamUserCondition>;
  filter?: InputMaybe<TeamUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `UserInvite`. */
export type TeamUsersByUserInviteTeamIdAndAdminIdManyToManyConnection = {
  __typename?: 'TeamUsersByUserInviteTeamIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<TeamUsersByUserInviteTeamIdAndAdminIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `UserInvite`. */
export type TeamUsersByUserInviteTeamIdAndAdminIdManyToManyEdge = {
  __typename?: 'TeamUsersByUserInviteTeamIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvitesByAdminId: UserInvitesConnection;
};


/** A `User` edge in the connection, with data from `UserInvite`. */
export type TeamUsersByUserInviteTeamIdAndAdminIdManyToManyEdgeUserInvitesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `TeamUser` values. */
export type TeamUsersConnection = {
  __typename?: 'TeamUsersConnection';
  /** A list of edges which contains the `TeamUser` and cursor to aid in pagination. */
  edges: Array<TeamUsersEdge>;
  /** A list of `TeamUser` objects. */
  nodes: Array<TeamUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TeamUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TeamUser` edge in the connection. */
export type TeamUsersEdge = {
  __typename?: 'TeamUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TeamUser` at the end of the edge. */
  node: TeamUser;
};

/** Methods to use when ordering `TeamUser`. */
export enum TeamUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  Natural = 'NATURAL',
  TeamIdAsc = 'TEAM_ID_ASC',
  TeamIdDesc = 'TEAM_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Team` values. */
export type TeamsConnection = {
  __typename?: 'TeamsConnection';
  /** A list of edges which contains the `Team` and cursor to aid in pagination. */
  edges: Array<TeamsEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection. */
export type TeamsEdge = {
  __typename?: 'TeamsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
};

/** Methods to use when ordering `Team`. */
export enum TeamsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A connection to a list of `TelescopeEntry` values. */
export type TelescopeEntriesConnection = {
  __typename?: 'TelescopeEntriesConnection';
  /** A list of edges which contains the `TelescopeEntry` and cursor to aid in pagination. */
  edges: Array<TelescopeEntriesEdge>;
  /** A list of `TelescopeEntry` objects. */
  nodes: Array<TelescopeEntry>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TelescopeEntry` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TelescopeEntry` edge in the connection. */
export type TelescopeEntriesEdge = {
  __typename?: 'TelescopeEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TelescopeEntry` at the end of the edge. */
  node: TelescopeEntry;
};

/** Methods to use when ordering `TelescopeEntry`. */
export enum TelescopeEntriesOrderBy {
  BatchIdAsc = 'BATCH_ID_ASC',
  BatchIdDesc = 'BATCH_ID_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FamilyHashAsc = 'FAMILY_HASH_ASC',
  FamilyHashDesc = 'FAMILY_HASH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  ShouldDisplayOnIndexAsc = 'SHOULD_DISPLAY_ON_INDEX_ASC',
  ShouldDisplayOnIndexDesc = 'SHOULD_DISPLAY_ON_INDEX_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type TelescopeEntriesTag = {
  __typename?: 'TelescopeEntriesTag';
  /** Reads a single `TelescopeEntry` that is related to this `TelescopeEntriesTag`. */
  entry?: Maybe<TelescopeEntry>;
  entryUuid: Scalars['UUID']['output'];
  tag: Scalars['String']['output'];
};

/**
 * A condition to be used against `TelescopeEntriesTag` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TelescopeEntriesTagCondition = {
  /** Checks for equality with the object’s `entryUuid` field. */
  entryUuid?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `tag` field. */
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TelescopeEntriesTag` object types. All fields are combined with a logical ‘and.’ */
export type TelescopeEntriesTagFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TelescopeEntriesTagFilter>>;
  /** Filter by the object’s `entryUuid` field. */
  entryUuid?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TelescopeEntriesTagFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TelescopeEntriesTagFilter>>;
  /** Filter by the object’s `tag` field. */
  tag?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TelescopeEntriesTag` */
export type TelescopeEntriesTagInput = {
  entryUuid: Scalars['UUID']['input'];
  tag: Scalars['String']['input'];
};

/** A connection to a list of `TelescopeEntriesTag` values. */
export type TelescopeEntriesTagsConnection = {
  __typename?: 'TelescopeEntriesTagsConnection';
  /** A list of edges which contains the `TelescopeEntriesTag` and cursor to aid in pagination. */
  edges: Array<TelescopeEntriesTagsEdge>;
  /** A list of `TelescopeEntriesTag` objects. */
  nodes: Array<TelescopeEntriesTag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TelescopeEntriesTag` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TelescopeEntriesTag` edge in the connection. */
export type TelescopeEntriesTagsEdge = {
  __typename?: 'TelescopeEntriesTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TelescopeEntriesTag` at the end of the edge. */
  node: TelescopeEntriesTag;
};

/** Methods to use when ordering `TelescopeEntriesTag`. */
export enum TelescopeEntriesTagsOrderBy {
  EntryUuidAsc = 'ENTRY_UUID_ASC',
  EntryUuidDesc = 'ENTRY_UUID_DESC',
  Natural = 'NATURAL',
  TagAsc = 'TAG_ASC',
  TagDesc = 'TAG_DESC'
}

export type TelescopeEntry = Node & {
  __typename?: 'TelescopeEntry';
  batchId: Scalars['UUID']['output'];
  content: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  familyHash?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sequence: Scalars['BigInt']['output'];
  shouldDisplayOnIndex: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `TelescopeEntriesTag`. */
  telescopeEntriesTagsByEntryUuid: TelescopeEntriesTagsConnection;
  type: Scalars['String']['output'];
  uuid: Scalars['UUID']['output'];
};


export type TelescopeEntryTelescopeEntriesTagsByEntryUuidArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TelescopeEntriesTagCondition>;
  filter?: InputMaybe<TelescopeEntriesTagFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TelescopeEntriesTagsOrderBy>>;
};

/**
 * A condition to be used against `TelescopeEntry` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TelescopeEntryCondition = {
  /** Checks for equality with the object’s `batchId` field. */
  batchId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `familyHash` field. */
  familyHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `shouldDisplayOnIndex` field. */
  shouldDisplayOnIndex?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `TelescopeEntry` object types. All fields are combined with a logical ‘and.’ */
export type TelescopeEntryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TelescopeEntryFilter>>;
  /** Filter by the object’s `batchId` field. */
  batchId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `familyHash` field. */
  familyHash?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TelescopeEntryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TelescopeEntryFilter>>;
  /** Filter by the object’s `sequence` field. */
  sequence?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `shouldDisplayOnIndex` field. */
  shouldDisplayOnIndex?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `TelescopeEntry` */
export type TelescopeEntryInput = {
  batchId: Scalars['UUID']['input'];
  content: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  familyHash?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['BigInt']['input']>;
  shouldDisplayOnIndex?: InputMaybe<Scalars['Boolean']['input']>;
  type: Scalars['String']['input'];
  uuid: Scalars['UUID']['input'];
};

/** Represents an update to a `TelescopeEntry`. Fields that are set will be updated. */
export type TelescopeEntryPatch = {
  batchId?: InputMaybe<Scalars['UUID']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  familyHash?: InputMaybe<Scalars['String']['input']>;
  sequence?: InputMaybe<Scalars['BigInt']['input']>;
  shouldDisplayOnIndex?: InputMaybe<Scalars['Boolean']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

export type TelescopeMonitoring = {
  __typename?: 'TelescopeMonitoring';
  tag: Scalars['String']['output'];
};

/**
 * A condition to be used against `TelescopeMonitoring` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TelescopeMonitoringCondition = {
  /** Checks for equality with the object’s `tag` field. */
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TelescopeMonitoring` object types. All fields are combined with a logical ‘and.’ */
export type TelescopeMonitoringFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TelescopeMonitoringFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<TelescopeMonitoringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TelescopeMonitoringFilter>>;
  /** Filter by the object’s `tag` field. */
  tag?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TelescopeMonitoring` */
export type TelescopeMonitoringInput = {
  tag: Scalars['String']['input'];
};

/** A connection to a list of `TelescopeMonitoring` values. */
export type TelescopeMonitoringsConnection = {
  __typename?: 'TelescopeMonitoringsConnection';
  /** A list of edges which contains the `TelescopeMonitoring` and cursor to aid in pagination. */
  edges: Array<TelescopeMonitoringsEdge>;
  /** A list of `TelescopeMonitoring` objects. */
  nodes: Array<TelescopeMonitoring>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TelescopeMonitoring` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TelescopeMonitoring` edge in the connection. */
export type TelescopeMonitoringsEdge = {
  __typename?: 'TelescopeMonitoringsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TelescopeMonitoring` at the end of the edge. */
  node: TelescopeMonitoring;
};

/** Methods to use when ordering `TelescopeMonitoring`. */
export enum TelescopeMonitoringsOrderBy {
  Natural = 'NATURAL',
  TagAsc = 'TAG_ASC',
  TagDesc = 'TAG_DESC'
}

export type Tool = Node & {
  __typename?: 'Tool';
  /** Reads a single `Admin` that is related to this `Tool`. */
  admin?: Maybe<Admin>;
  adminId: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Attachment`. */
  attachments: AttachmentsConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  currentUsage: Scalars['String']['output'];
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['BigInt']['output'];
  /** Reads a single `Metric` that is related to this `Tool`. */
  metric?: Maybe<Metric>;
  metricId: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  nextMaintenance: Scalars['String']['output'];
  nextMaintenanceDate?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Tool`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ToolUser`. */
  toolUsers: ToolUsersConnection;
  /** Reads a single `Tooltype` that is related to this `Tool`. */
  tooltype?: Maybe<Tooltype>;
  tooltypeId: Scalars['BigInt']['output'];
  typeOthersName?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByToolUserToolIdAndUserId: ToolUsersByToolUserToolIdAndUserIdManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
};


export type ToolAttachmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AttachmentCondition>;
  filter?: InputMaybe<AttachmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};


export type ToolToolUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolUserCondition>;
  filter?: InputMaybe<ToolUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};


export type ToolUsersByToolUserToolIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** A condition to be used against `Tool` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ToolCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentUsage` field. */
  currentUsage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `metricId` field. */
  metricId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nextMaintenance` field. */
  nextMaintenance?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nextMaintenanceDate` field. */
  nextMaintenanceDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tooltypeId` field. */
  tooltypeId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `typeOthersName` field. */
  typeOthersName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Tool` object types. All fields are combined with a logical ‘and.’ */
export type ToolFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ToolFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentUsage` field. */
  currentUsage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `metricId` field. */
  metricId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nextMaintenance` field. */
  nextMaintenance?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nextMaintenanceDate` field. */
  nextMaintenanceDate?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ToolFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ToolFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tooltypeId` field. */
  tooltypeId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `typeOthersName` field. */
  typeOthersName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Tool` */
export type ToolInput = {
  adminId: Scalars['BigInt']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  currentUsage?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  metricId?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  nextMaintenance?: InputMaybe<Scalars['String']['input']>;
  nextMaintenanceDate?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  tooltypeId?: InputMaybe<Scalars['BigInt']['input']>;
  typeOthersName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `Tool`. Fields that are set will be updated. */
export type ToolPatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  currentUsage?: InputMaybe<Scalars['String']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  metricId?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nextMaintenance?: InputMaybe<Scalars['String']['input']>;
  nextMaintenanceDate?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  tooltypeId?: InputMaybe<Scalars['BigInt']['input']>;
  typeOthersName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

export type ToolUser = {
  __typename?: 'ToolUser';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Tool` that is related to this `ToolUser`. */
  tool?: Maybe<Tool>;
  toolId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `ToolUser`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `ToolUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ToolUserCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `toolId` field. */
  toolId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `ToolUser` object types. All fields are combined with a logical ‘and.’ */
export type ToolUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ToolUserFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ToolUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ToolUserFilter>>;
  /** Filter by the object’s `toolId` field. */
  toolId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `ToolUser` */
export type ToolUserInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  toolId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
};

/** A connection to a list of `User` values, with data from `ToolUser`. */
export type ToolUsersByToolUserToolIdAndUserIdManyToManyConnection = {
  __typename?: 'ToolUsersByToolUserToolIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `ToolUser`, and the cursor to aid in pagination. */
  edges: Array<ToolUsersByToolUserToolIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `ToolUser`. */
export type ToolUsersByToolUserToolIdAndUserIdManyToManyEdge = {
  __typename?: 'ToolUsersByToolUserToolIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `ToolUser`. */
  toolUsers: ToolUsersConnection;
};


/** A `User` edge in the connection, with data from `ToolUser`. */
export type ToolUsersByToolUserToolIdAndUserIdManyToManyEdgeToolUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolUserCondition>;
  filter?: InputMaybe<ToolUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};

/** A connection to a list of `ToolUser` values. */
export type ToolUsersConnection = {
  __typename?: 'ToolUsersConnection';
  /** A list of edges which contains the `ToolUser` and cursor to aid in pagination. */
  edges: Array<ToolUsersEdge>;
  /** A list of `ToolUser` objects. */
  nodes: Array<ToolUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ToolUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ToolUser` edge in the connection. */
export type ToolUsersEdge = {
  __typename?: 'ToolUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ToolUser` at the end of the edge. */
  node: ToolUser;
};

/** Methods to use when ordering `ToolUser`. */
export enum ToolUsersOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  Natural = 'NATURAL',
  ToolIdAsc = 'TOOL_ID_ASC',
  ToolIdDesc = 'TOOL_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Tool` values. */
export type ToolsConnection = {
  __typename?: 'ToolsConnection';
  /** A list of edges which contains the `Tool` and cursor to aid in pagination. */
  edges: Array<ToolsEdge>;
  /** A list of `Tool` objects. */
  nodes: Array<Tool>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tool` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tool` edge in the connection. */
export type ToolsEdge = {
  __typename?: 'ToolsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tool` at the end of the edge. */
  node: Tool;
};

/** Methods to use when ordering `Tool`. */
export enum ToolsOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  CurrentUsageAsc = 'CURRENT_USAGE_ASC',
  CurrentUsageDesc = 'CURRENT_USAGE_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MetricIdAsc = 'METRIC_ID_ASC',
  MetricIdDesc = 'METRIC_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NextMaintenanceAsc = 'NEXT_MAINTENANCE_ASC',
  NextMaintenanceDateAsc = 'NEXT_MAINTENANCE_DATE_ASC',
  NextMaintenanceDateDesc = 'NEXT_MAINTENANCE_DATE_DESC',
  NextMaintenanceDesc = 'NEXT_MAINTENANCE_DESC',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  TooltypeIdAsc = 'TOOLTYPE_ID_ASC',
  TooltypeIdDesc = 'TOOLTYPE_ID_DESC',
  TypeOthersNameAsc = 'TYPE_OTHERS_NAME_ASC',
  TypeOthersNameDesc = 'TYPE_OTHERS_NAME_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type Tooltype = Node & {
  __typename?: 'Tooltype';
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByToolTooltypeIdAndAdminId: TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['BigInt']['output'];
  /** Reads and enables pagination through a set of `Metric`. */
  metricsByToolTooltypeIdAndMetricId: TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyConnection;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByToolTooltypeIdAndOrganizationId: TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid: Scalars['UUID']['output'];
};


export type TooltypeAdminsByToolTooltypeIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type TooltypeMetricsByToolTooltypeIdAndMetricIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MetricCondition>;
  filter?: InputMaybe<MetricFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};


export type TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type TooltypeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Tool`. */
export type TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyConnection = {
  __typename?: 'TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Tool`. */
export type TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyEdge = {
  __typename?: 'TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Admin` edge in the connection, with data from `Tool`. */
export type TooltypeAdminsByToolTooltypeIdAndAdminIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/**
 * A condition to be used against `Tooltype` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TooltypeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Tooltype` object types. All fields are combined with a logical ‘and.’ */
export type TooltypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TooltypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TooltypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TooltypeFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Tooltype` */
export type TooltypeInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid: Scalars['UUID']['input'];
};

/** A connection to a list of `Metric` values, with data from `Tool`. */
export type TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyConnection = {
  __typename?: 'TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyConnection';
  /** A list of edges which contains the `Metric`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyEdge>;
  /** A list of `Metric` objects. */
  nodes: Array<Metric>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Metric` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Metric` edge in the connection, with data from `Tool`. */
export type TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyEdge = {
  __typename?: 'TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Metric` at the end of the edge. */
  node: Metric;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Metric` edge in the connection, with data from `Tool`. */
export type TooltypeMetricsByToolTooltypeIdAndMetricIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Tool`. */
export type TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Tool`, and the cursor to aid in pagination. */
  edges: Array<TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Tool`. */
export type TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Tool`. */
  tools: ToolsConnection;
};


/** A `Organization` edge in the connection, with data from `Tool`. */
export type TooltypeOrganizationsByToolTooltypeIdAndOrganizationIdManyToManyEdgeToolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** Represents an update to a `Tooltype`. Fields that are set will be updated. */
export type TooltypePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Tooltype` values. */
export type TooltypesConnection = {
  __typename?: 'TooltypesConnection';
  /** A list of edges which contains the `Tooltype` and cursor to aid in pagination. */
  edges: Array<TooltypesEdge>;
  /** A list of `Tooltype` objects. */
  nodes: Array<Tooltype>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tooltype` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tooltype` edge in the connection. */
export type TooltypesEdge = {
  __typename?: 'TooltypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tooltype` at the end of the edge. */
  node: Tooltype;
};

/** Methods to use when ordering `Tooltype`. */
export enum TooltypesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** All input for the `updateAbilityByNodeId` mutation. */
export type UpdateAbilityByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Ability` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Ability` being updated. */
  patch: AbilityPatch;
};

/** All input for the `updateAbility` mutation. */
export type UpdateAbilityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Ability` being updated. */
  patch: AbilityPatch;
};

/** The output of our update `Ability` mutation. */
export type UpdateAbilityPayload = {
  __typename?: 'UpdateAbilityPayload';
  /** The `Ability` that was updated by this mutation. */
  ability?: Maybe<Ability>;
  /** An edge for our `Ability`. May be used by Relay 1. */
  abilityEdge?: Maybe<AbilitiesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Ability` mutation. */
export type UpdateAbilityPayloadAbilityEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilitiesOrderBy>>;
};

/** All input for the `updateAbilityRoleByNodeId` mutation. */
export type UpdateAbilityRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AbilityRole` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `AbilityRole` being updated. */
  patch: AbilityRolePatch;
};

/** All input for the `updateAbilityRole` mutation. */
export type UpdateAbilityRoleInput = {
  abilityId: Scalars['BigInt']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `AbilityRole` being updated. */
  patch: AbilityRolePatch;
  roleId: Scalars['BigInt']['input'];
};

/** The output of our update `AbilityRole` mutation. */
export type UpdateAbilityRolePayload = {
  __typename?: 'UpdateAbilityRolePayload';
  /** Reads a single `Ability` that is related to this `AbilityRole`. */
  ability?: Maybe<Ability>;
  /** The `AbilityRole` that was updated by this mutation. */
  abilityRole?: Maybe<AbilityRole>;
  /** An edge for our `AbilityRole`. May be used by Relay 1. */
  abilityRoleEdge?: Maybe<AbilityRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `AbilityRole`. */
  role?: Maybe<Role>;
};


/** The output of our update `AbilityRole` mutation. */
export type UpdateAbilityRolePayloadAbilityRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AbilityRolesOrderBy>>;
};

/** All input for the `updateAdminByNodeId` mutation. */
export type UpdateAdminByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Admin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Admin` being updated. */
  patch: AdminPatch;
};

/** All input for the `updateAdmin` mutation. */
export type UpdateAdminInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Admin` being updated. */
  patch: AdminPatch;
};

/** The output of our update `Admin` mutation. */
export type UpdateAdminPayload = {
  __typename?: 'UpdateAdminPayload';
  /** The `Admin` that was updated by this mutation. */
  admin?: Maybe<Admin>;
  /** An edge for our `Admin`. May be used by Relay 1. */
  adminEdge?: Maybe<AdminsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Admin`. */
  user?: Maybe<User>;
};


/** The output of our update `Admin` mutation. */
export type UpdateAdminPayloadAdminEdgeArgs = {
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};

/** All input for the `updateAllowedSettingValueByNodeId` mutation. */
export type UpdateAllowedSettingValueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AllowedSettingValue` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `AllowedSettingValue` being updated. */
  patch: AllowedSettingValuePatch;
};

/** All input for the `updateAllowedSettingValue` mutation. */
export type UpdateAllowedSettingValueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `AllowedSettingValue` being updated. */
  patch: AllowedSettingValuePatch;
};

/** The output of our update `AllowedSettingValue` mutation. */
export type UpdateAllowedSettingValuePayload = {
  __typename?: 'UpdateAllowedSettingValuePayload';
  /** The `AllowedSettingValue` that was updated by this mutation. */
  allowedSettingValue?: Maybe<AllowedSettingValue>;
  /** An edge for our `AllowedSettingValue`. May be used by Relay 1. */
  allowedSettingValueEdge?: Maybe<AllowedSettingValuesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `AllowedSettingValue`. */
  setting?: Maybe<Setting>;
};


/** The output of our update `AllowedSettingValue` mutation. */
export type UpdateAllowedSettingValuePayloadAllowedSettingValueEdgeArgs = {
  orderBy?: InputMaybe<Array<AllowedSettingValuesOrderBy>>;
};

/** All input for the `updateAttachmentByNodeId` mutation. */
export type UpdateAttachmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Attachment` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** All input for the `updateAttachment` mutation. */
export type UpdateAttachmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Attachment` being updated. */
  patch: AttachmentPatch;
};

/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayload = {
  __typename?: 'UpdateAttachmentPayload';
  /** The `Attachment` that was updated by this mutation. */
  attachment?: Maybe<Attachment>;
  /** An edge for our `Attachment`. May be used by Relay 1. */
  attachmentEdge?: Maybe<AttachmentsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Tool` that is related to this `Attachment`. */
  tool?: Maybe<Tool>;
};


/** The output of our update `Attachment` mutation. */
export type UpdateAttachmentPayloadAttachmentEdgeArgs = {
  orderBy?: InputMaybe<Array<AttachmentsOrderBy>>;
};

/** All input for the `updateCertificationByNodeId` mutation. */
export type UpdateCertificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Certification` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Certification` being updated. */
  patch: CertificationPatch;
};

/** All input for the `updateCertification` mutation. */
export type UpdateCertificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Certification` being updated. */
  patch: CertificationPatch;
};

/** The output of our update `Certification` mutation. */
export type UpdateCertificationPayload = {
  __typename?: 'UpdateCertificationPayload';
  /** Reads a single `User` that is related to this `Certification`. */
  admin?: Maybe<User>;
  /** The `Certification` that was updated by this mutation. */
  certification?: Maybe<Certification>;
  /** An edge for our `Certification`. May be used by Relay 1. */
  certificationEdge?: Maybe<CertificationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Certification`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Certification` mutation. */
export type UpdateCertificationPayloadCertificationEdgeArgs = {
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};

/** All input for the `updateCompanyByNodeId` mutation. */
export type UpdateCompanyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Company` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Company` being updated. */
  patch: CompanyPatch;
};

/** All input for the `updateCompany` mutation. */
export type UpdateCompanyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Company` being updated. */
  patch: CompanyPatch;
};

/** The output of our update `Company` mutation. */
export type UpdateCompanyPayload = {
  __typename?: 'UpdateCompanyPayload';
  /** Reads a single `Admin` that is related to this `Company`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Company` that was updated by this mutation. */
  company?: Maybe<Company>;
  /** An edge for our `Company`. May be used by Relay 1. */
  companyEdge?: Maybe<CompaniesEdge>;
  /** Reads a single `Organization` that is related to this `Company`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Company` mutation. */
export type UpdateCompanyPayloadCompanyEdgeArgs = {
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};

/** All input for the `updateComponentByDescription` mutation. */
export type UpdateComponentByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Component` being updated. */
  patch: ComponentPatch;
};

/** All input for the `updateComponentByNodeId` mutation. */
export type UpdateComponentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Component` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Component` being updated. */
  patch: ComponentPatch;
};

/** All input for the `updateComponentBySlug` mutation. */
export type UpdateComponentBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Component` being updated. */
  patch: ComponentPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateComponentEventByNodeId` mutation. */
export type UpdateComponentEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ComponentEvent` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ComponentEvent` being updated. */
  patch: ComponentEventPatch;
};

/** All input for the `updateComponentEvent` mutation. */
export type UpdateComponentEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `ComponentEvent` being updated. */
  patch: ComponentEventPatch;
};

/** The output of our update `ComponentEvent` mutation. */
export type UpdateComponentEventPayload = {
  __typename?: 'UpdateComponentEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentEvent`. */
  component?: Maybe<Component>;
  /** The `ComponentEvent` that was updated by this mutation. */
  componentEvent?: Maybe<ComponentEvent>;
  /** An edge for our `ComponentEvent`. May be used by Relay 1. */
  componentEventEdge?: Maybe<ComponentEventsEdge>;
  /** Reads a single `Event` that is related to this `ComponentEvent`. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ComponentEvent` mutation. */
export type UpdateComponentEventPayloadComponentEventEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentEventsOrderBy>>;
};

/** All input for the `updateComponent` mutation. */
export type UpdateComponentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Component` being updated. */
  patch: ComponentPatch;
};

/** The output of our update `Component` mutation. */
export type UpdateComponentPayload = {
  __typename?: 'UpdateComponentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Component` that was updated by this mutation. */
  component?: Maybe<Component>;
  /** An edge for our `Component`. May be used by Relay 1. */
  componentEdge?: Maybe<ComponentsEdge>;
  /** Reads a single `Component` that is related to this `Component`. */
  parent?: Maybe<Component>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Component` mutation. */
export type UpdateComponentPayloadComponentEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentsOrderBy>>;
};

/** All input for the `updateComponentPropertyByNodeId` mutation. */
export type UpdateComponentPropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ComponentProperty` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ComponentProperty` being updated. */
  patch: ComponentPropertyPatch;
};

/** All input for the `updateComponentProperty` mutation. */
export type UpdateComponentPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `ComponentProperty` being updated. */
  patch: ComponentPropertyPatch;
};

/** The output of our update `ComponentProperty` mutation. */
export type UpdateComponentPropertyPayload = {
  __typename?: 'UpdateComponentPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `ComponentProperty`. */
  component?: Maybe<Component>;
  /** The `ComponentProperty` that was updated by this mutation. */
  componentProperty?: Maybe<ComponentProperty>;
  /** An edge for our `ComponentProperty`. May be used by Relay 1. */
  componentPropertyEdge?: Maybe<ComponentPropertiesEdge>;
  /** Reads a single `Property` that is related to this `ComponentProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ComponentProperty` mutation. */
export type UpdateComponentPropertyPayloadComponentPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<ComponentPropertiesOrderBy>>;
};

/** All input for the `updateCourseByNodeId` mutation. */
export type UpdateCourseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Course` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Course` being updated. */
  patch: CoursePatch;
};

/** All input for the `updateCourse` mutation. */
export type UpdateCourseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Course` being updated. */
  patch: CoursePatch;
};

/** The output of our update `Course` mutation. */
export type UpdateCoursePayload = {
  __typename?: 'UpdateCoursePayload';
  /** Reads a single `User` that is related to this `Course`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Course` that was updated by this mutation. */
  course?: Maybe<Course>;
  /** An edge for our `Course`. May be used by Relay 1. */
  courseEdge?: Maybe<CoursesEdge>;
  /** Reads a single `Organization` that is related to this `Course`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Course` mutation. */
export type UpdateCoursePayloadCourseEdgeArgs = {
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};

/** All input for the `updateDatatypeByDescription` mutation. */
export type UpdateDatatypeByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Datatype` being updated. */
  patch: DatatypePatch;
};

/** All input for the `updateDatatypeByNodeId` mutation. */
export type UpdateDatatypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Datatype` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Datatype` being updated. */
  patch: DatatypePatch;
};

/** All input for the `updateDatatype` mutation. */
export type UpdateDatatypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Datatype` being updated. */
  patch: DatatypePatch;
};

/** The output of our update `Datatype` mutation. */
export type UpdateDatatypePayload = {
  __typename?: 'UpdateDatatypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Datatype` that was updated by this mutation. */
  datatype?: Maybe<Datatype>;
  /** An edge for our `Datatype`. May be used by Relay 1. */
  datatypeEdge?: Maybe<DatatypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Datatype` mutation. */
export type UpdateDatatypePayloadDatatypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DatatypesOrderBy>>;
};

/** All input for the `updateEquipmentByName` mutation. */
export type UpdateEquipmentByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Equipment` being updated. */
  patch: EquipmentPatch;
};

/** All input for the `updateEquipmentByNodeId` mutation. */
export type UpdateEquipmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Equipment` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Equipment` being updated. */
  patch: EquipmentPatch;
};

/** All input for the `updateEquipment` mutation. */
export type UpdateEquipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Equipment` being updated. */
  patch: EquipmentPatch;
};

/** The output of our update `Equipment` mutation. */
export type UpdateEquipmentPayload = {
  __typename?: 'UpdateEquipmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Equipment` that was updated by this mutation. */
  equipment?: Maybe<Equipment>;
  /** An edge for our `Equipment`. May be used by Relay 1. */
  equipmentEdge?: Maybe<EquipmentEdge>;
  /** Reads a single `EquipmentType` that is related to this `Equipment`. */
  equipmentType?: Maybe<EquipmentType>;
  /** Reads a single `Organization` that is related to this `Equipment`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Equipment`. */
  userByPreparedBy?: Maybe<User>;
};


/** The output of our update `Equipment` mutation. */
export type UpdateEquipmentPayloadEquipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** All input for the `updateEquipmentTypeByNodeId` mutation. */
export type UpdateEquipmentTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EquipmentType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `EquipmentType` being updated. */
  patch: EquipmentTypePatch;
};

/** All input for the `updateEquipmentType` mutation. */
export type UpdateEquipmentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `EquipmentType` being updated. */
  patch: EquipmentTypePatch;
};

/** The output of our update `EquipmentType` mutation. */
export type UpdateEquipmentTypePayload = {
  __typename?: 'UpdateEquipmentTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `EquipmentType` that was updated by this mutation. */
  equipmentType?: Maybe<EquipmentType>;
  /** An edge for our `EquipmentType`. May be used by Relay 1. */
  equipmentTypeEdge?: Maybe<EquipmentTypesEdge>;
  /** Reads a single `Organization` that is related to this `EquipmentType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `EquipmentType` mutation. */
export type UpdateEquipmentTypePayloadEquipmentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};

/** All input for the `updateErrorReportByNodeId` mutation. */
export type UpdateErrorReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ErrorReport` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ErrorReport` being updated. */
  patch: ErrorReportPatch;
};

/** All input for the `updateErrorReport` mutation. */
export type UpdateErrorReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `ErrorReport` being updated. */
  patch: ErrorReportPatch;
};

/** The output of our update `ErrorReport` mutation. */
export type UpdateErrorReportPayload = {
  __typename?: 'UpdateErrorReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ErrorReport` that was updated by this mutation. */
  errorReport?: Maybe<ErrorReport>;
  /** An edge for our `ErrorReport`. May be used by Relay 1. */
  errorReportEdge?: Maybe<ErrorReportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ErrorReport` mutation. */
export type UpdateErrorReportPayloadErrorReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ErrorReportsOrderBy>>;
};

/** All input for the `updateEventByDescription` mutation. */
export type UpdateEventByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** All input for the `updateEventByNodeId` mutation. */
export type UpdateEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** All input for the `updateEventBySlug` mutation. */
export type UpdateEventBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  patch: EventPatch;
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Event` that was updated by this mutation. */
  event?: Maybe<Event>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadEventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateFailedJobByNodeId` mutation. */
export type UpdateFailedJobByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FailedJob` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FailedJob` being updated. */
  patch: FailedJobPatch;
};

/** All input for the `updateFailedJobByUuid` mutation. */
export type UpdateFailedJobByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FailedJob` being updated. */
  patch: FailedJobPatch;
  uuid: Scalars['String']['input'];
};

/** All input for the `updateFailedJob` mutation. */
export type UpdateFailedJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FailedJob` being updated. */
  patch: FailedJobPatch;
};

/** The output of our update `FailedJob` mutation. */
export type UpdateFailedJobPayload = {
  __typename?: 'UpdateFailedJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FailedJob` that was updated by this mutation. */
  failedJob?: Maybe<FailedJob>;
  /** An edge for our `FailedJob`. May be used by Relay 1. */
  failedJobEdge?: Maybe<FailedJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FailedJob` mutation. */
export type UpdateFailedJobPayloadFailedJobEdgeArgs = {
  orderBy?: InputMaybe<Array<FailedJobsOrderBy>>;
};

/** All input for the `updateFieldActionByNodeId` mutation. */
export type UpdateFieldActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldAction` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FieldAction` being updated. */
  patch: FieldActionPatch;
};

/** All input for the `updateFieldAction` mutation. */
export type UpdateFieldActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FieldAction` being updated. */
  patch: FieldActionPatch;
};

/** The output of our update `FieldAction` mutation. */
export type UpdateFieldActionPayload = {
  __typename?: 'UpdateFieldActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Event` that is related to this `FieldAction`. */
  event?: Maybe<Event>;
  /** Reads a single `Field` that is related to this `FieldAction`. */
  field?: Maybe<Field>;
  /** The `FieldAction` that was updated by this mutation. */
  fieldAction?: Maybe<FieldAction>;
  /** An edge for our `FieldAction`. May be used by Relay 1. */
  fieldActionEdge?: Maybe<FieldActionsEdge>;
  /** Reads a single `Property` that is related to this `FieldAction`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FieldAction` mutation. */
export type UpdateFieldActionPayloadFieldActionEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldActionsOrderBy>>;
};

/** All input for the `updateFieldByNodeId` mutation. */
export type UpdateFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Field` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** All input for the `updateField` mutation. */
export type UpdateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** The output of our update `Field` mutation. */
export type UpdateFieldPayload = {
  __typename?: 'UpdateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Component` that is related to this `Field`. */
  component?: Maybe<Component>;
  /** The `Field` that was updated by this mutation. */
  field?: Maybe<Field>;
  /** An edge for our `Field`. May be used by Relay 1. */
  fieldEdge?: Maybe<FieldsEdge>;
  /** Reads a single `Form` that is related to this `Field`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Field` mutation. */
export type UpdateFieldPayloadFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldsOrderBy>>;
};

/** All input for the `updateFieldPropertyByNodeId` mutation. */
export type UpdateFieldPropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldProperty` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FieldProperty` being updated. */
  patch: FieldPropertyPatch;
};

/** All input for the `updateFieldProperty` mutation. */
export type UpdateFieldPropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FieldProperty` being updated. */
  patch: FieldPropertyPatch;
};

/** The output of our update `FieldProperty` mutation. */
export type UpdateFieldPropertyPayload = {
  __typename?: 'UpdateFieldPropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FieldProperty`. */
  field?: Maybe<Field>;
  /** The `FieldProperty` that was updated by this mutation. */
  fieldProperty?: Maybe<FieldProperty>;
  /** An edge for our `FieldProperty`. May be used by Relay 1. */
  fieldPropertyEdge?: Maybe<FieldPropertiesEdge>;
  /** Reads a single `Property` that is related to this `FieldProperty`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FieldProperty` mutation. */
export type UpdateFieldPropertyPayloadFieldPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldPropertiesOrderBy>>;
};

/** All input for the `updateFieldTranslationByNodeId` mutation. */
export type UpdateFieldTranslationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FieldTranslation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FieldTranslation` being updated. */
  patch: FieldTranslationPatch;
};

/** All input for the `updateFieldTranslation` mutation. */
export type UpdateFieldTranslationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FieldTranslation` being updated. */
  patch: FieldTranslationPatch;
};

/** The output of our update `FieldTranslation` mutation. */
export type UpdateFieldTranslationPayload = {
  __typename?: 'UpdateFieldTranslationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FieldTranslation`. */
  field?: Maybe<Field>;
  /** The `FieldTranslation` that was updated by this mutation. */
  fieldTranslation?: Maybe<FieldTranslation>;
  /** An edge for our `FieldTranslation`. May be used by Relay 1. */
  fieldTranslationEdge?: Maybe<FieldTranslationsEdge>;
  /** Reads a single `Language` that is related to this `FieldTranslation`. */
  language?: Maybe<Language>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FieldTranslation` mutation. */
export type UpdateFieldTranslationPayloadFieldTranslationEdgeArgs = {
  orderBy?: InputMaybe<Array<FieldTranslationsOrderBy>>;
};

/** All input for the `updateFillupFormByNodeId` mutation. */
export type UpdateFillupFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FillupForm` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FillupForm` being updated. */
  patch: FillupFormPatch;
};

/** All input for the `updateFillupFormFieldByNodeId` mutation. */
export type UpdateFillupFormFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FillupFormField` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FillupFormField` being updated. */
  patch: FillupFormFieldPatch;
};

/** All input for the `updateFillupFormField` mutation. */
export type UpdateFillupFormFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FillupFormField` being updated. */
  patch: FillupFormFieldPatch;
};

/** The output of our update `FillupFormField` mutation. */
export type UpdateFillupFormFieldPayload = {
  __typename?: 'UpdateFillupFormFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `FillupFormField`. */
  field?: Maybe<Field>;
  /** Reads a single `FillupForm` that is related to this `FillupFormField`. */
  fillupForm?: Maybe<FillupForm>;
  /** The `FillupFormField` that was updated by this mutation. */
  fillupFormField?: Maybe<FillupFormField>;
  /** An edge for our `FillupFormField`. May be used by Relay 1. */
  fillupFormFieldEdge?: Maybe<FillupFormFieldsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FillupFormField` mutation. */
export type UpdateFillupFormFieldPayloadFillupFormFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormFieldsOrderBy>>;
};

/** All input for the `updateFillupForm` mutation. */
export type UpdateFillupFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FillupForm` being updated. */
  patch: FillupFormPatch;
};

/** The output of our update `FillupForm` mutation. */
export type UpdateFillupFormPayload = {
  __typename?: 'UpdateFillupFormPayload';
  /** Reads a single `Admin` that is related to this `FillupForm`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FillupForm` that was updated by this mutation. */
  fillupForm?: Maybe<FillupForm>;
  /** An edge for our `FillupForm`. May be used by Relay 1. */
  fillupFormEdge?: Maybe<FillupFormsEdge>;
  /** Reads a single `Form` that is related to this `FillupForm`. */
  form?: Maybe<Form>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  user?: Maybe<User>;
  /** Reads a single `User` that is related to this `FillupForm`. */
  userByApprovedBy?: Maybe<User>;
};


/** The output of our update `FillupForm` mutation. */
export type UpdateFillupFormPayloadFillupFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** All input for the `updateFormByNodeId` mutation. */
export type UpdateFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Form` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Form` being updated. */
  patch: FormPatch;
};

/** All input for the `updateForm` mutation. */
export type UpdateFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Form` being updated. */
  patch: FormPatch;
};

/** All input for the `updateFormOrganizationByNodeId` mutation. */
export type UpdateFormOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormOrganization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormOrganization` being updated. */
  patch: FormOrganizationPatch;
};

/** All input for the `updateFormOrganization` mutation. */
export type UpdateFormOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormOrganization` being updated. */
  patch: FormOrganizationPatch;
};

/** The output of our update `FormOrganization` mutation. */
export type UpdateFormOrganizationPayload = {
  __typename?: 'UpdateFormOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormOrganization`. */
  form?: Maybe<Form>;
  /** The `FormOrganization` that was updated by this mutation. */
  formOrganization?: Maybe<FormOrganization>;
  /** An edge for our `FormOrganization`. May be used by Relay 1. */
  formOrganizationEdge?: Maybe<FormOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FormOrganization` mutation. */
export type UpdateFormOrganizationPayloadFormOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormOrganizationsOrderBy>>;
};

/** The output of our update `Form` mutation. */
export type UpdateFormPayload = {
  __typename?: 'UpdateFormPayload';
  /** Reads a single `Admin` that is related to this `Form`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `Form`. */
  createdFromTemplate?: Maybe<FormTemplate>;
  /** The `Form` that was updated by this mutation. */
  form?: Maybe<Form>;
  /** An edge for our `Form`. May be used by Relay 1. */
  formEdge?: Maybe<FormsEdge>;
  /** Reads a single `Group` that is related to this `Form`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Form`. */
  team?: Maybe<Team>;
};


/** The output of our update `Form` mutation. */
export type UpdateFormPayloadFormEdgeArgs = {
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};

/** All input for the `updateFormTemplateByNodeId` mutation. */
export type UpdateFormTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplate` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplate` being updated. */
  patch: FormTemplatePatch;
};

/** All input for the `updateFormTemplateGroupByNodeId` mutation. */
export type UpdateFormTemplateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplateGroup` being updated. */
  patch: FormTemplateGroupPatch;
};

/** All input for the `updateFormTemplateGroup` mutation. */
export type UpdateFormTemplateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  groupId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplateGroup` being updated. */
  patch: FormTemplateGroupPatch;
};

/** The output of our update `FormTemplateGroup` mutation. */
export type UpdateFormTemplateGroupPayload = {
  __typename?: 'UpdateFormTemplateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateGroup`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateGroup` that was updated by this mutation. */
  formTemplateGroup?: Maybe<FormTemplateGroup>;
  /** An edge for our `FormTemplateGroup`. May be used by Relay 1. */
  formTemplateGroupEdge?: Maybe<FormTemplateGroupsEdge>;
  /** Reads a single `Group` that is related to this `FormTemplateGroup`. */
  group?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FormTemplateGroup` mutation. */
export type UpdateFormTemplateGroupPayloadFormTemplateGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateGroupsOrderBy>>;
};

/** All input for the `updateFormTemplate` mutation. */
export type UpdateFormTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplate` being updated. */
  patch: FormTemplatePatch;
};

/** All input for the `updateFormTemplateOrganizationByNodeId` mutation. */
export type UpdateFormTemplateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateOrganization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplateOrganization` being updated. */
  patch: FormTemplateOrganizationPatch;
};

/** All input for the `updateFormTemplateOrganization` mutation. */
export type UpdateFormTemplateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  organizationId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplateOrganization` being updated. */
  patch: FormTemplateOrganizationPatch;
};

/** The output of our update `FormTemplateOrganization` mutation. */
export type UpdateFormTemplateOrganizationPayload = {
  __typename?: 'UpdateFormTemplateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateOrganization`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateOrganization` that was updated by this mutation. */
  formTemplateOrganization?: Maybe<FormTemplateOrganization>;
  /** An edge for our `FormTemplateOrganization`. May be used by Relay 1. */
  formTemplateOrganizationEdge?: Maybe<FormTemplateOrganizationsEdge>;
  /** Reads a single `Organization` that is related to this `FormTemplateOrganization`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FormTemplateOrganization` mutation. */
export type UpdateFormTemplateOrganizationPayloadFormTemplateOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateOrganizationsOrderBy>>;
};

/** The output of our update `FormTemplate` mutation. */
export type UpdateFormTemplatePayload = {
  __typename?: 'UpdateFormTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormTemplate`. */
  form?: Maybe<Form>;
  /** The `FormTemplate` that was updated by this mutation. */
  formTemplate?: Maybe<FormTemplate>;
  /** An edge for our `FormTemplate`. May be used by Relay 1. */
  formTemplateEdge?: Maybe<FormTemplatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FormTemplate` mutation. */
export type UpdateFormTemplatePayloadFormTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};

/** All input for the `updateFormTemplateProjectByNodeId` mutation. */
export type UpdateFormTemplateProjectByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateProject` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplateProject` being updated. */
  patch: FormTemplateProjectPatch;
};

/** All input for the `updateFormTemplateProject` mutation. */
export type UpdateFormTemplateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplateProject` being updated. */
  patch: FormTemplateProjectPatch;
  projectId: Scalars['BigInt']['input'];
};

/** The output of our update `FormTemplateProject` mutation. */
export type UpdateFormTemplateProjectPayload = {
  __typename?: 'UpdateFormTemplateProjectPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateProject`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateProject` that was updated by this mutation. */
  formTemplateProject?: Maybe<FormTemplateProject>;
  /** An edge for our `FormTemplateProject`. May be used by Relay 1. */
  formTemplateProjectEdge?: Maybe<FormTemplateProjectsEdge>;
  /** Reads a single `Project` that is related to this `FormTemplateProject`. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FormTemplateProject` mutation. */
export type UpdateFormTemplateProjectPayloadFormTemplateProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateProjectsOrderBy>>;
};

/** All input for the `updateFormTemplateTeamByNodeId` mutation. */
export type UpdateFormTemplateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateTeam` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplateTeam` being updated. */
  patch: FormTemplateTeamPatch;
};

/** All input for the `updateFormTemplateTeam` mutation. */
export type UpdateFormTemplateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplateTeam` being updated. */
  patch: FormTemplateTeamPatch;
  teamId: Scalars['BigInt']['input'];
};

/** The output of our update `FormTemplateTeam` mutation. */
export type UpdateFormTemplateTeamPayload = {
  __typename?: 'UpdateFormTemplateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateTeam`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateTeam` that was updated by this mutation. */
  formTemplateTeam?: Maybe<FormTemplateTeam>;
  /** An edge for our `FormTemplateTeam`. May be used by Relay 1. */
  formTemplateTeamEdge?: Maybe<FormTemplateTeamsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Team` that is related to this `FormTemplateTeam`. */
  team?: Maybe<Team>;
};


/** The output of our update `FormTemplateTeam` mutation. */
export type UpdateFormTemplateTeamPayloadFormTemplateTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateTeamsOrderBy>>;
};

/** All input for the `updateFormTemplateUserByNodeId` mutation. */
export type UpdateFormTemplateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormTemplateUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormTemplateUser` being updated. */
  patch: FormTemplateUserPatch;
};

/** All input for the `updateFormTemplateUser` mutation. */
export type UpdateFormTemplateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formTemplateId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormTemplateUser` being updated. */
  patch: FormTemplateUserPatch;
  userId: Scalars['BigInt']['input'];
};

/** The output of our update `FormTemplateUser` mutation. */
export type UpdateFormTemplateUserPayload = {
  __typename?: 'UpdateFormTemplateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FormTemplate` that is related to this `FormTemplateUser`. */
  formTemplate?: Maybe<FormTemplate>;
  /** The `FormTemplateUser` that was updated by this mutation. */
  formTemplateUser?: Maybe<FormTemplateUser>;
  /** An edge for our `FormTemplateUser`. May be used by Relay 1. */
  formTemplateUserEdge?: Maybe<FormTemplateUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormTemplateUser`. */
  user?: Maybe<User>;
};


/** The output of our update `FormTemplateUser` mutation. */
export type UpdateFormTemplateUserPayloadFormTemplateUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};

/** All input for the `updateFormUserByNodeId` mutation. */
export type UpdateFormUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FormUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `FormUser` being updated. */
  patch: FormUserPatch;
};

/** All input for the `updateFormUser` mutation. */
export type UpdateFormUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  formId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `FormUser` being updated. */
  patch: FormUserPatch;
  userId: Scalars['BigInt']['input'];
};

/** The output of our update `FormUser` mutation. */
export type UpdateFormUserPayload = {
  __typename?: 'UpdateFormUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Form` that is related to this `FormUser`. */
  form?: Maybe<Form>;
  /** The `FormUser` that was updated by this mutation. */
  formUser?: Maybe<FormUser>;
  /** An edge for our `FormUser`. May be used by Relay 1. */
  formUserEdge?: Maybe<FormUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FormUser`. */
  user?: Maybe<User>;
};


/** The output of our update `FormUser` mutation. */
export type UpdateFormUserPayloadFormUserEdgeArgs = {
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};

/** All input for the `updateGroupByNodeId` mutation. */
export type UpdateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /** Reads a single `Admin` that is related to this `Group`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Group` that was updated by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Reads a single `Organization` that is related to this `Group`. */
  organization?: Maybe<Organization>;
  /** Reads a single `Group` that is related to this `Group`. */
  parent?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateIssuanceByEquipmentIdAndSerialNumber` mutation. */
export type UpdateIssuanceByEquipmentIdAndSerialNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  equipmentId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Issuance` being updated. */
  patch: IssuancePatch;
  serialNumber: Scalars['String']['input'];
};

/** All input for the `updateIssuanceByNodeId` mutation. */
export type UpdateIssuanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Issuance` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Issuance` being updated. */
  patch: IssuancePatch;
};

/** All input for the `updateIssuance` mutation. */
export type UpdateIssuanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Issuance` being updated. */
  patch: IssuancePatch;
};

/** The output of our update `Issuance` mutation. */
export type UpdateIssuancePayload = {
  __typename?: 'UpdateIssuancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Equipment` that is related to this `Issuance`. */
  equipment?: Maybe<Equipment>;
  /** The `Issuance` that was updated by this mutation. */
  issuance?: Maybe<Issuance>;
  /** An edge for our `Issuance`. May be used by Relay 1. */
  issuanceEdge?: Maybe<IssuancesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Issuance`. */
  user?: Maybe<User>;
};


/** The output of our update `Issuance` mutation. */
export type UpdateIssuancePayloadIssuanceEdgeArgs = {
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};

/** All input for the `updateJobByNodeId` mutation. */
export type UpdateJobByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Job` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Job` being updated. */
  patch: JobPatch;
};

/** All input for the `updateJob` mutation. */
export type UpdateJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Job` being updated. */
  patch: JobPatch;
};

/** The output of our update `Job` mutation. */
export type UpdateJobPayload = {
  __typename?: 'UpdateJobPayload';
  /** Reads a single `User` that is related to this `Job`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Job` that was updated by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Reads a single `Organization` that is related to this `Job`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Job` mutation. */
export type UpdateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the `updateJobSendingEmailByNodeId` mutation. */
export type UpdateJobSendingEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmail` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmail` being updated. */
  patch: JobSendingEmailPatch;
};

/** All input for the `updateJobSendingEmailCategoryByNodeId` mutation. */
export type UpdateJobSendingEmailCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmailCategory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmailCategory` being updated. */
  patch: JobSendingEmailCategoryPatch;
};

/** All input for the `updateJobSendingEmailCategory` mutation. */
export type UpdateJobSendingEmailCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmailCategory` being updated. */
  patch: JobSendingEmailCategoryPatch;
};

/** The output of our update `JobSendingEmailCategory` mutation. */
export type UpdateJobSendingEmailCategoryPayload = {
  __typename?: 'UpdateJobSendingEmailCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JobSendingEmailCategory` that was updated by this mutation. */
  jobSendingEmailCategory?: Maybe<JobSendingEmailCategory>;
  /** An edge for our `JobSendingEmailCategory`. May be used by Relay 1. */
  jobSendingEmailCategoryEdge?: Maybe<JobSendingEmailCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `JobSendingEmailCategory` mutation. */
export type UpdateJobSendingEmailCategoryPayloadJobSendingEmailCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};

/** All input for the `updateJobSendingEmail` mutation. */
export type UpdateJobSendingEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmail` being updated. */
  patch: JobSendingEmailPatch;
};

/** All input for the `updateJobSendingEmailLogByNodeId` mutation. */
export type UpdateJobSendingEmailLogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JobSendingEmailLog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmailLog` being updated. */
  patch: JobSendingEmailLogPatch;
};

/** All input for the `updateJobSendingEmailLog` mutation. */
export type UpdateJobSendingEmailLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `JobSendingEmailLog` being updated. */
  patch: JobSendingEmailLogPatch;
};

/** The output of our update `JobSendingEmailLog` mutation. */
export type UpdateJobSendingEmailLogPayload = {
  __typename?: 'UpdateJobSendingEmailLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `JobSendingEmail` that is related to this `JobSendingEmailLog`. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** The `JobSendingEmailLog` that was updated by this mutation. */
  jobSendingEmailLog?: Maybe<JobSendingEmailLog>;
  /** An edge for our `JobSendingEmailLog`. May be used by Relay 1. */
  jobSendingEmailLogEdge?: Maybe<JobSendingEmailLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `JobSendingEmailLog` mutation. */
export type UpdateJobSendingEmailLogPayloadJobSendingEmailLogEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailLogsOrderBy>>;
};

/** The output of our update `JobSendingEmail` mutation. */
export type UpdateJobSendingEmailPayload = {
  __typename?: 'UpdateJobSendingEmailPayload';
  /** Reads a single `JobSendingEmailCategory` that is related to this `JobSendingEmail`. */
  category?: Maybe<JobSendingEmailCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JobSendingEmail` that was updated by this mutation. */
  jobSendingEmail?: Maybe<JobSendingEmail>;
  /** An edge for our `JobSendingEmail`. May be used by Relay 1. */
  jobSendingEmailEdge?: Maybe<JobSendingEmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentFrom?: Maybe<User>;
  /** Reads a single `User` that is related to this `JobSendingEmail`. */
  userBySentTo?: Maybe<User>;
};


/** The output of our update `JobSendingEmail` mutation. */
export type UpdateJobSendingEmailPayloadJobSendingEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** All input for the `updateKindByDescription` mutation. */
export type UpdateKindByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Kind` being updated. */
  patch: KindPatch;
};

/** All input for the `updateKindByNodeId` mutation. */
export type UpdateKindByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Kind` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Kind` being updated. */
  patch: KindPatch;
};

/** All input for the `updateKindBySlug` mutation. */
export type UpdateKindBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Kind` being updated. */
  patch: KindPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateKind` mutation. */
export type UpdateKindInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Kind` being updated. */
  patch: KindPatch;
};

/** The output of our update `Kind` mutation. */
export type UpdateKindPayload = {
  __typename?: 'UpdateKindPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Kind` that was updated by this mutation. */
  kind?: Maybe<Kind>;
  /** An edge for our `Kind`. May be used by Relay 1. */
  kindEdge?: Maybe<KindsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Kind` mutation. */
export type UpdateKindPayloadKindEdgeArgs = {
  orderBy?: InputMaybe<Array<KindsOrderBy>>;
};

/** All input for the `updateLanguageByNodeId` mutation. */
export type UpdateLanguageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Language` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** All input for the `updateLanguage` mutation. */
export type UpdateLanguageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Language` being updated. */
  patch: LanguagePatch;
};

/** The output of our update `Language` mutation. */
export type UpdateLanguagePayload = {
  __typename?: 'UpdateLanguagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Language` that was updated by this mutation. */
  language?: Maybe<Language>;
  /** An edge for our `Language`. May be used by Relay 1. */
  languageEdge?: Maybe<LanguagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Language` mutation. */
export type UpdateLanguagePayloadLanguageEdgeArgs = {
  orderBy?: InputMaybe<Array<LanguagesOrderBy>>;
};

/** All input for the `updateLoginTransactionByNodeId` mutation. */
export type UpdateLoginTransactionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LoginTransaction` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `LoginTransaction` being updated. */
  patch: LoginTransactionPatch;
};

/** All input for the `updateLoginTransaction` mutation. */
export type UpdateLoginTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `LoginTransaction` being updated. */
  patch: LoginTransactionPatch;
};

/** The output of our update `LoginTransaction` mutation. */
export type UpdateLoginTransactionPayload = {
  __typename?: 'UpdateLoginTransactionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LoginTransaction` that was updated by this mutation. */
  loginTransaction?: Maybe<LoginTransaction>;
  /** An edge for our `LoginTransaction`. May be used by Relay 1. */
  loginTransactionEdge?: Maybe<LoginTransactionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoginTransaction`. */
  user?: Maybe<User>;
};


/** The output of our update `LoginTransaction` mutation. */
export type UpdateLoginTransactionPayloadLoginTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<LoginTransactionsOrderBy>>;
};

/** All input for the `updateMetricByNodeId` mutation. */
export type UpdateMetricByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Metric` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Metric` being updated. */
  patch: MetricPatch;
};

/** All input for the `updateMetric` mutation. */
export type UpdateMetricInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Metric` being updated. */
  patch: MetricPatch;
};

/** The output of our update `Metric` mutation. */
export type UpdateMetricPayload = {
  __typename?: 'UpdateMetricPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Metric` that was updated by this mutation. */
  metric?: Maybe<Metric>;
  /** An edge for our `Metric`. May be used by Relay 1. */
  metricEdge?: Maybe<MetricsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Metric` mutation. */
export type UpdateMetricPayloadMetricEdgeArgs = {
  orderBy?: InputMaybe<Array<MetricsOrderBy>>;
};

/** All input for the `updateMigrationByNodeId` mutation. */
export type UpdateMigrationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Migration` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Migration` being updated. */
  patch: MigrationPatch;
};

/** All input for the `updateMigration` mutation. */
export type UpdateMigrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Migration` being updated. */
  patch: MigrationPatch;
};

/** The output of our update `Migration` mutation. */
export type UpdateMigrationPayload = {
  __typename?: 'UpdateMigrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Migration` that was updated by this mutation. */
  migration?: Maybe<Migration>;
  /** An edge for our `Migration`. May be used by Relay 1. */
  migrationEdge?: Maybe<MigrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Migration` mutation. */
export type UpdateMigrationPayloadMigrationEdgeArgs = {
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};

/** All input for the `updateNewsByNodeId` mutation. */
export type UpdateNewsByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `News` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `News` being updated. */
  patch: NewsPatch;
};

/** All input for the `updateNews` mutation. */
export type UpdateNewsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `News` being updated. */
  patch: NewsPatch;
};

/** The output of our update `News` mutation. */
export type UpdateNewsPayload = {
  __typename?: 'UpdateNewsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `News` that was updated by this mutation. */
  news?: Maybe<News>;
  /** An edge for our `News`. May be used by Relay 1. */
  newsEdge?: Maybe<NewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `News` mutation. */
export type UpdateNewsPayloadNewsEdgeArgs = {
  orderBy?: InputMaybe<Array<NewsOrderBy>>;
};

/** All input for the `updateOrganizationByNodeId` mutation. */
export type UpdateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** All input for the `updateOrganization` mutation. */
export type UpdateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayload = {
  __typename?: 'UpdateOrganizationPayload';
  /** Reads a single `Admin` that is related to this `Organization`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was updated by this mutation. */
  organization?: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge?: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};

/** All input for the `updateOrganizationUserByNodeId` mutation. */
export type UpdateOrganizationUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OrganizationUser` being updated. */
  patch: OrganizationUserPatch;
};

/** All input for the `updateOrganizationUser` mutation. */
export type UpdateOrganizationUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `OrganizationUser` being updated. */
  patch: OrganizationUserPatch;
  userId: Scalars['BigInt']['input'];
};

/** The output of our update `OrganizationUser` mutation. */
export type UpdateOrganizationUserPayload = {
  __typename?: 'UpdateOrganizationUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationUser`. */
  organization?: Maybe<Organization>;
  /** The `OrganizationUser` that was updated by this mutation. */
  organizationUser?: Maybe<OrganizationUser>;
  /** An edge for our `OrganizationUser`. May be used by Relay 1. */
  organizationUserEdge?: Maybe<OrganizationUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationUser`. */
  user?: Maybe<User>;
};


/** The output of our update `OrganizationUser` mutation. */
export type UpdateOrganizationUserPayloadOrganizationUserEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};

/** All input for the `updatePersonalAccessTokenByNodeId` mutation. */
export type UpdatePersonalAccessTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PersonalAccessToken` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PersonalAccessToken` being updated. */
  patch: PersonalAccessTokenPatch;
};

/** All input for the `updatePersonalAccessTokenByToken` mutation. */
export type UpdatePersonalAccessTokenByTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `PersonalAccessToken` being updated. */
  patch: PersonalAccessTokenPatch;
  token: Scalars['String']['input'];
};

/** All input for the `updatePersonalAccessToken` mutation. */
export type UpdatePersonalAccessTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `PersonalAccessToken` being updated. */
  patch: PersonalAccessTokenPatch;
};

/** The output of our update `PersonalAccessToken` mutation. */
export type UpdatePersonalAccessTokenPayload = {
  __typename?: 'UpdatePersonalAccessTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PersonalAccessToken` that was updated by this mutation. */
  personalAccessToken?: Maybe<PersonalAccessToken>;
  /** An edge for our `PersonalAccessToken`. May be used by Relay 1. */
  personalAccessTokenEdge?: Maybe<PersonalAccessTokensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PersonalAccessToken` mutation. */
export type UpdatePersonalAccessTokenPayloadPersonalAccessTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<PersonalAccessTokensOrderBy>>;
};

/** All input for the `updateProfileByNodeId` mutation. */
export type UpdateProfileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Profile` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Profile` being updated. */
  patch: ProfilePatch;
};

/** All input for the `updateProfile` mutation. */
export type UpdateProfileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Profile` being updated. */
  patch: ProfilePatch;
};

/** The output of our update `Profile` mutation. */
export type UpdateProfilePayload = {
  __typename?: 'UpdateProfilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Profile`. */
  pro_id?: Maybe<User>;
  /** The `Profile` that was updated by this mutation. */
  profile?: Maybe<Profile>;
  /** An edge for our `Profile`. May be used by Relay 1. */
  profileEdge?: Maybe<ProfilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Profile`. */
  user?: Maybe<User>;
};


/** The output of our update `Profile` mutation. */
export type UpdateProfilePayloadProfileEdgeArgs = {
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>;
};

/** All input for the `updateProjectByNodeId` mutation. */
export type UpdateProjectByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Project` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Project` being updated. */
  patch: ProjectPatch;
};

/** All input for the `updateProject` mutation. */
export type UpdateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Project` being updated. */
  patch: ProjectPatch;
};

/** The output of our update `Project` mutation. */
export type UpdateProjectPayload = {
  __typename?: 'UpdateProjectPayload';
  /** Reads a single `Admin` that is related to this `Project`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Project`. */
  organization?: Maybe<Organization>;
  /** The `Project` that was updated by this mutation. */
  project?: Maybe<Project>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Project` mutation. */
export type UpdateProjectPayloadProjectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `updateProjectUserByNodeId` mutation. */
export type UpdateProjectUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ProjectUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ProjectUser` being updated. */
  patch: ProjectUserPatch;
};

/** All input for the `updateProjectUser` mutation. */
export type UpdateProjectUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `ProjectUser` being updated. */
  patch: ProjectUserPatch;
};

/** The output of our update `ProjectUser` mutation. */
export type UpdateProjectUserPayload = {
  __typename?: 'UpdateProjectUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Project` that is related to this `ProjectUser`. */
  project?: Maybe<Project>;
  /** The `ProjectUser` that was updated by this mutation. */
  projectUser?: Maybe<ProjectUser>;
  /** An edge for our `ProjectUser`. May be used by Relay 1. */
  projectUserEdge?: Maybe<ProjectUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ProjectUser`. */
  user?: Maybe<User>;
};


/** The output of our update `ProjectUser` mutation. */
export type UpdateProjectUserPayloadProjectUserEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};

/** All input for the `updatePropertyByDescription` mutation. */
export type UpdatePropertyByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** All input for the `updatePropertyByHint` mutation. */
export type UpdatePropertyByHintInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  hint: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** All input for the `updatePropertyByNodeId` mutation. */
export type UpdatePropertyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Property` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** All input for the `updatePropertyBySlug` mutation. */
export type UpdatePropertyBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateProperty` mutation. */
export type UpdatePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** The output of our update `Property` mutation. */
export type UpdatePropertyPayload = {
  __typename?: 'UpdatePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Datatype` that is related to this `Property`. */
  datatype?: Maybe<Datatype>;
  /** Reads a single `Kind` that is related to this `Property`. */
  kind?: Maybe<Kind>;
  /** The `Property` that was updated by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Property` mutation. */
export type UpdatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the `updateRoleByName` mutation. */
export type UpdateRoleByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch;
};

/** All input for the `updateRoleByNodeId` mutation. */
export type UpdateRoleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch;
};

/** All input for the `updateRole` mutation. */
export type UpdateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  patch: RolePatch;
};

/** The output of our update `Role` mutation. */
export type UpdateRolePayload = {
  __typename?: 'UpdateRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Role` that is related to this `Role`. */
  parentRole?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our update `Role` mutation. */
export type UpdateRolePayloadRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `updateRoleUserByNodeId` mutation. */
export type UpdateRoleUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleUser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoleUser` being updated. */
  patch: RoleUserPatch;
};

/** All input for the `updateRoleUser` mutation. */
export type UpdateRoleUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `RoleUser` being updated. */
  patch: RoleUserPatch;
  roleId: Scalars['BigInt']['input'];
  userId: Scalars['BigInt']['input'];
};

/** All input for the `updateRoleUserOrganizationByNodeId` mutation. */
export type UpdateRoleUserOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RoleUserOrganization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RoleUserOrganization` being updated. */
  patch: RoleUserOrganizationPatch;
};

/** All input for the `updateRoleUserOrganization` mutation. */
export type UpdateRoleUserOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `RoleUserOrganization` being updated. */
  patch: RoleUserOrganizationPatch;
};

/** The output of our update `RoleUserOrganization` mutation. */
export type UpdateRoleUserOrganizationPayload = {
  __typename?: 'UpdateRoleUserOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `RoleUserOrganization`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUserOrganization`. */
  role?: Maybe<Role>;
  /** The `RoleUserOrganization` that was updated by this mutation. */
  roleUserOrganization?: Maybe<RoleUserOrganization>;
  /** An edge for our `RoleUserOrganization`. May be used by Relay 1. */
  roleUserOrganizationEdge?: Maybe<RoleUserOrganizationsEdge>;
  /** Reads a single `User` that is related to this `RoleUserOrganization`. */
  user?: Maybe<User>;
};


/** The output of our update `RoleUserOrganization` mutation. */
export type UpdateRoleUserOrganizationPayloadRoleUserOrganizationEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** The output of our update `RoleUser` mutation. */
export type UpdateRoleUserPayload = {
  __typename?: 'UpdateRoleUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `RoleUser`. */
  role?: Maybe<Role>;
  /** The `RoleUser` that was updated by this mutation. */
  roleUser?: Maybe<RoleUser>;
  /** An edge for our `RoleUser`. May be used by Relay 1. */
  roleUserEdge?: Maybe<RoleUsersEdge>;
  /** Reads a single `User` that is related to this `RoleUser`. */
  user?: Maybe<User>;
};


/** The output of our update `RoleUser` mutation. */
export type UpdateRoleUserPayloadRoleUserEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};

/** All input for the `updateSchedulerByNodeId` mutation. */
export type UpdateSchedulerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  patch: SchedulerPatch;
};

/** All input for the `updateSchedulerFieldByNodeId` mutation. */
export type UpdateSchedulerFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SchedulerField` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SchedulerField` being updated. */
  patch: SchedulerFieldPatch;
};

/** All input for the `updateSchedulerField` mutation. */
export type UpdateSchedulerFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `SchedulerField` being updated. */
  patch: SchedulerFieldPatch;
};

/** The output of our update `SchedulerField` mutation. */
export type UpdateSchedulerFieldPayload = {
  __typename?: 'UpdateSchedulerFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Field` that is related to this `SchedulerField`. */
  field?: Maybe<Field>;
  /** Reads a single `Form` that is related to this `SchedulerField`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `SchedulerField`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SchedulerField` that was updated by this mutation. */
  schedulerField?: Maybe<SchedulerField>;
  /** An edge for our `SchedulerField`. May be used by Relay 1. */
  schedulerFieldEdge?: Maybe<SchedulerFieldsEdge>;
};


/** The output of our update `SchedulerField` mutation. */
export type UpdateSchedulerFieldPayloadSchedulerFieldEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};

/** All input for the `updateScheduler` mutation. */
export type UpdateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  patch: SchedulerPatch;
};

/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayload = {
  __typename?: 'UpdateSchedulerPayload';
  /** Reads a single `Admin` that is related to this `Scheduler`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FillupForm` that is related to this `Scheduler`. */
  fillupform?: Maybe<FillupForm>;
  /** Reads a single `Form` that is related to this `Scheduler`. */
  form?: Maybe<Form>;
  /** Reads a single `FormTemplate` that is related to this `Scheduler`. */
  formTemplate?: Maybe<FormTemplate>;
  /** Reads a single `Group` that is related to this `Scheduler`. */
  group?: Maybe<Group>;
  /** Reads a single `Organization` that is related to this `Scheduler`. */
  org?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Scheduler` that was updated by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
  /** Reads a single `SchedulerField` that is related to this `Scheduler`. */
  schedulerFields?: Maybe<SchedulerField>;
  /** Reads a single `Team` that is related to this `Scheduler`. */
  team?: Maybe<Team>;
  /** Reads a single `User` that is related to this `Scheduler`. */
  user?: Maybe<User>;
};


/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayloadSchedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `updateSentMailByNodeId` mutation. */
export type UpdateSentMailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SentMail` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SentMail` being updated. */
  patch: SentMailPatch;
};

/** All input for the `updateSentMail` mutation. */
export type UpdateSentMailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `SentMail` being updated. */
  patch: SentMailPatch;
};

/** The output of our update `SentMail` mutation. */
export type UpdateSentMailPayload = {
  __typename?: 'UpdateSentMailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SentMail` that was updated by this mutation. */
  sentMail?: Maybe<SentMail>;
  /** An edge for our `SentMail`. May be used by Relay 1. */
  sentMailEdge?: Maybe<SentMailEdge>;
};


/** The output of our update `SentMail` mutation. */
export type UpdateSentMailPayloadSentMailEdgeArgs = {
  orderBy?: InputMaybe<Array<SentMailOrderBy>>;
};

/** All input for the `updateSessionByNodeId` mutation. */
export type UpdateSessionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Session` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
};

/** All input for the `updateSession` mutation. */
export type UpdateSessionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Session` being updated. */
  patch: SessionPatch;
};

/** The output of our update `Session` mutation. */
export type UpdateSessionPayload = {
  __typename?: 'UpdateSessionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Session` that was updated by this mutation. */
  session?: Maybe<Session>;
  /** An edge for our `Session`. May be used by Relay 1. */
  sessionEdge?: Maybe<SessionsEdge>;
};


/** The output of our update `Session` mutation. */
export type UpdateSessionPayloadSessionEdgeArgs = {
  orderBy?: InputMaybe<Array<SessionsOrderBy>>;
};

/** All input for the `updateSettingByDescription` mutation. */
export type UpdateSettingByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch;
};

/** All input for the `updateSettingByNodeId` mutation. */
export type UpdateSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch;
};

/** All input for the `updateSettingGroupByDescription` mutation. */
export type UpdateSettingGroupByDescriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `SettingGroup` being updated. */
  patch: SettingGroupPatch;
};

/** All input for the `updateSettingGroupByNodeId` mutation. */
export type UpdateSettingGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SettingGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SettingGroup` being updated. */
  patch: SettingGroupPatch;
};

/** All input for the `updateSettingGroup` mutation. */
export type UpdateSettingGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `SettingGroup` being updated. */
  patch: SettingGroupPatch;
};

/** The output of our update `SettingGroup` mutation. */
export type UpdateSettingGroupPayload = {
  __typename?: 'UpdateSettingGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SettingGroup` that was updated by this mutation. */
  settingGroup?: Maybe<SettingGroup>;
  /** An edge for our `SettingGroup`. May be used by Relay 1. */
  settingGroupEdge?: Maybe<SettingGroupsEdge>;
};


/** The output of our update `SettingGroup` mutation. */
export type UpdateSettingGroupPayloadSettingGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingGroupsOrderBy>>;
};

/** All input for the `updateSetting` mutation. */
export type UpdateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  patch: SettingPatch;
};

/** The output of our update `Setting` mutation. */
export type UpdateSettingPayload = {
  __typename?: 'UpdateSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `SettingGroup` that is related to this `Setting`. */
  group?: Maybe<SettingGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<Setting>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our update `Setting` mutation. */
export type UpdateSettingPayloadSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `updateSubscriptionByNodeId` mutation. */
export type UpdateSubscriptionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Subscription` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Subscription` being updated. */
  patch: SubscriptionPatch;
};

/** All input for the `updateSubscription` mutation. */
export type UpdateSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Subscription` being updated. */
  patch: SubscriptionPatch;
};

/** All input for the `updateSubscriptionItemByNodeId` mutation. */
export type UpdateSubscriptionItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SubscriptionItem` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SubscriptionItem` being updated. */
  patch: SubscriptionItemPatch;
};

/** All input for the `updateSubscriptionItemBySubscriptionIdAndStripePlan` mutation. */
export type UpdateSubscriptionItemBySubscriptionIdAndStripePlanInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `SubscriptionItem` being updated. */
  patch: SubscriptionItemPatch;
  stripePlan: Scalars['String']['input'];
  subscriptionId: Scalars['BigInt']['input'];
};

/** All input for the `updateSubscriptionItem` mutation. */
export type UpdateSubscriptionItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `SubscriptionItem` being updated. */
  patch: SubscriptionItemPatch;
};

/** The output of our update `SubscriptionItem` mutation. */
export type UpdateSubscriptionItemPayload = {
  __typename?: 'UpdateSubscriptionItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SubscriptionItem` that was updated by this mutation. */
  subscriptionItem?: Maybe<SubscriptionItem>;
  /** An edge for our `SubscriptionItem`. May be used by Relay 1. */
  subscriptionItemEdge?: Maybe<SubscriptionItemsEdge>;
};


/** The output of our update `SubscriptionItem` mutation. */
export type UpdateSubscriptionItemPayloadSubscriptionItemEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionItemsOrderBy>>;
};

/** The output of our update `Subscription` mutation. */
export type UpdateSubscriptionPayload = {
  __typename?: 'UpdateSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Subscription` that was updated by this mutation. */
  subscription?: Maybe<Subscription>;
  /** An edge for our `Subscription`. May be used by Relay 1. */
  subscriptionEdge?: Maybe<SubscriptionsEdge>;
};


/** The output of our update `Subscription` mutation. */
export type UpdateSubscriptionPayloadSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<SubscriptionsOrderBy>>;
};

/** All input for the `updateSystemEventByNodeId` mutation. */
export type UpdateSystemEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemEvent` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SystemEvent` being updated. */
  patch: SystemEventPatch;
};

/** All input for the `updateSystemEvent` mutation. */
export type UpdateSystemEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `SystemEvent` being updated. */
  patch: SystemEventPatch;
};

/** The output of our update `SystemEvent` mutation. */
export type UpdateSystemEventPayload = {
  __typename?: 'UpdateSystemEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemEvent` that was updated by this mutation. */
  systemEvent?: Maybe<SystemEvent>;
  /** An edge for our `SystemEvent`. May be used by Relay 1. */
  systemEventEdge?: Maybe<SystemEventsEdge>;
};


/** The output of our update `SystemEvent` mutation. */
export type UpdateSystemEventPayloadSystemEventEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemEventsOrderBy>>;
};

/** All input for the `updateTeamByNodeId` mutation. */
export type UpdateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Team` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
};

/** All input for the `updateTeam` mutation. */
export type UpdateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
};

/** The output of our update `Team` mutation. */
export type UpdateTeamPayload = {
  __typename?: 'UpdateTeamPayload';
  /** Reads a single `Admin` that is related to this `Team`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `Team`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Team` that was updated by this mutation. */
  team?: Maybe<Team>;
  /** An edge for our `Team`. May be used by Relay 1. */
  teamEdge?: Maybe<TeamsEdge>;
};


/** The output of our update `Team` mutation. */
export type UpdateTeamPayloadTeamEdgeArgs = {
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};

/** All input for the `updateTelescopeEntryByNodeId` mutation. */
export type UpdateTelescopeEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TelescopeEntry` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TelescopeEntry` being updated. */
  patch: TelescopeEntryPatch;
};

/** All input for the `updateTelescopeEntryByUuid` mutation. */
export type UpdateTelescopeEntryByUuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `TelescopeEntry` being updated. */
  patch: TelescopeEntryPatch;
  uuid: Scalars['UUID']['input'];
};

/** All input for the `updateTelescopeEntry` mutation. */
export type UpdateTelescopeEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `TelescopeEntry` being updated. */
  patch: TelescopeEntryPatch;
  sequence: Scalars['BigInt']['input'];
};

/** The output of our update `TelescopeEntry` mutation. */
export type UpdateTelescopeEntryPayload = {
  __typename?: 'UpdateTelescopeEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TelescopeEntry` that was updated by this mutation. */
  telescopeEntry?: Maybe<TelescopeEntry>;
  /** An edge for our `TelescopeEntry`. May be used by Relay 1. */
  telescopeEntryEdge?: Maybe<TelescopeEntriesEdge>;
};


/** The output of our update `TelescopeEntry` mutation. */
export type UpdateTelescopeEntryPayloadTelescopeEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<TelescopeEntriesOrderBy>>;
};

/** All input for the `updateToolByNodeId` mutation. */
export type UpdateToolByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Tool` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Tool` being updated. */
  patch: ToolPatch;
};

/** All input for the `updateTool` mutation. */
export type UpdateToolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Tool` being updated. */
  patch: ToolPatch;
};

/** The output of our update `Tool` mutation. */
export type UpdateToolPayload = {
  __typename?: 'UpdateToolPayload';
  /** Reads a single `Admin` that is related to this `Tool`. */
  admin?: Maybe<Admin>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Metric` that is related to this `Tool`. */
  metric?: Maybe<Metric>;
  /** Reads a single `Organization` that is related to this `Tool`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tool` that was updated by this mutation. */
  tool?: Maybe<Tool>;
  /** An edge for our `Tool`. May be used by Relay 1. */
  toolEdge?: Maybe<ToolsEdge>;
  /** Reads a single `Tooltype` that is related to this `Tool`. */
  tooltype?: Maybe<Tooltype>;
};


/** The output of our update `Tool` mutation. */
export type UpdateToolPayloadToolEdgeArgs = {
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};

/** All input for the `updateTooltypeByNodeId` mutation. */
export type UpdateTooltypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Tooltype` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Tooltype` being updated. */
  patch: TooltypePatch;
};

/** All input for the `updateTooltype` mutation. */
export type UpdateTooltypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `Tooltype` being updated. */
  patch: TooltypePatch;
};

/** The output of our update `Tooltype` mutation. */
export type UpdateTooltypePayload = {
  __typename?: 'UpdateTooltypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tooltype` that was updated by this mutation. */
  tooltype?: Maybe<Tooltype>;
  /** An edge for our `Tooltype`. May be used by Relay 1. */
  tooltypeEdge?: Maybe<TooltypesEdge>;
};


/** The output of our update `Tooltype` mutation. */
export type UpdateTooltypePayloadTooltypeEdgeArgs = {
  orderBy?: InputMaybe<Array<TooltypesOrderBy>>;
};

/** All input for the `updateUserByFacebookId` mutation. */
export type UpdateUserByFacebookIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  facebookId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByGoogleId` mutation. */
export type UpdateUserByGoogleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  googleId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserInviteByNodeId` mutation. */
export type UpdateUserInviteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserInvite` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserInvite` being updated. */
  patch: UserInvitePatch;
};

/** All input for the `updateUserInviteByToken` mutation. */
export type UpdateUserInviteByTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `UserInvite` being updated. */
  patch: UserInvitePatch;
  token: Scalars['String']['input'];
};

/** All input for the `updateUserInvite` mutation. */
export type UpdateUserInviteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `UserInvite` being updated. */
  patch: UserInvitePatch;
};

/** The output of our update `UserInvite` mutation. */
export type UpdateUserInvitePayload = {
  __typename?: 'UpdateUserInvitePayload';
  /** Reads a single `User` that is related to this `UserInvite`. */
  admin?: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `UserInvite`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Role` that is related to this `UserInvite`. */
  role?: Maybe<Role>;
  /** Reads a single `Team` that is related to this `UserInvite`. */
  team?: Maybe<Team>;
  /** The `UserInvite` that was updated by this mutation. */
  userInvite?: Maybe<UserInvite>;
  /** An edge for our `UserInvite`. May be used by Relay 1. */
  userInviteEdge?: Maybe<UserInvitesEdge>;
};


/** The output of our update `UserInvite` mutation. */
export type UpdateUserInvitePayloadUserInviteEdgeArgs = {
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `User`. */
  parent?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserSettingByNodeId` mutation. */
export type UpdateUserSettingByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserSetting` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserSetting` being updated. */
  patch: UserSettingPatch;
};

/** All input for the `updateUserSetting` mutation. */
export type UpdateUserSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `UserSetting` being updated. */
  patch: UserSettingPatch;
};

/** The output of our update `UserSetting` mutation. */
export type UpdateUserSettingPayload = {
  __typename?: 'UpdateUserSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  setting?: Maybe<Setting>;
  /** Reads a single `User` that is related to this `UserSetting`. */
  user?: Maybe<User>;
  /** The `UserSetting` that was updated by this mutation. */
  userSetting?: Maybe<UserSetting>;
  /** An edge for our `UserSetting`. May be used by Relay 1. */
  userSettingEdge?: Maybe<UserSettingsEdge>;
};


/** The output of our update `UserSetting` mutation. */
export type UpdateUserSettingPayloadUserSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};

/** All input for the `updateVerificationTokenByNodeId` mutation. */
export type UpdateVerificationTokenByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VerificationToken` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `VerificationToken` being updated. */
  patch: VerificationTokenPatch;
};

/** All input for the `updateVerificationToken` mutation. */
export type UpdateVerificationTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `VerificationToken` being updated. */
  patch: VerificationTokenPatch;
};

/** The output of our update `VerificationToken` mutation. */
export type UpdateVerificationTokenPayload = {
  __typename?: 'UpdateVerificationTokenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `VerificationToken`. */
  user?: Maybe<User>;
  /** The `VerificationToken` that was updated by this mutation. */
  verificationToken?: Maybe<VerificationToken>;
  /** An edge for our `VerificationToken`. May be used by Relay 1. */
  verificationTokenEdge?: Maybe<VerificationTokensEdge>;
  /** Reads a single `VerificationTokenType` that is related to this `VerificationToken`. */
  verificationTokenType?: Maybe<VerificationTokenType>;
};


/** The output of our update `VerificationToken` mutation. */
export type UpdateVerificationTokenPayloadVerificationTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** All input for the `updateVerificationTokenTypeByNodeId` mutation. */
export type UpdateVerificationTokenTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VerificationTokenType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `VerificationTokenType` being updated. */
  patch: VerificationTokenTypePatch;
};

/** All input for the `updateVerificationTokenType` mutation. */
export type UpdateVerificationTokenTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `VerificationTokenType` being updated. */
  patch: VerificationTokenTypePatch;
};

/** The output of our update `VerificationTokenType` mutation. */
export type UpdateVerificationTokenTypePayload = {
  __typename?: 'UpdateVerificationTokenTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VerificationTokenType` that was updated by this mutation. */
  verificationTokenType?: Maybe<VerificationTokenType>;
  /** An edge for our `VerificationTokenType`. May be used by Relay 1. */
  verificationTokenTypeEdge?: Maybe<VerificationTokenTypesEdge>;
};


/** The output of our update `VerificationTokenType` mutation. */
export type UpdateVerificationTokenTypePayloadVerificationTokenTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationTokenTypesOrderBy>>;
};

/** All input for the `updateWebsocketsStatisticsEntryByNodeId` mutation. */
export type UpdateWebsocketsStatisticsEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WebsocketsStatisticsEntry` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `WebsocketsStatisticsEntry` being updated. */
  patch: WebsocketsStatisticsEntryPatch;
};

/** All input for the `updateWebsocketsStatisticsEntry` mutation. */
export type UpdateWebsocketsStatisticsEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `WebsocketsStatisticsEntry` being updated. */
  patch: WebsocketsStatisticsEntryPatch;
};

/** The output of our update `WebsocketsStatisticsEntry` mutation. */
export type UpdateWebsocketsStatisticsEntryPayload = {
  __typename?: 'UpdateWebsocketsStatisticsEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebsocketsStatisticsEntry` that was updated by this mutation. */
  websocketsStatisticsEntry?: Maybe<WebsocketsStatisticsEntry>;
  /** An edge for our `WebsocketsStatisticsEntry`. May be used by Relay 1. */
  websocketsStatisticsEntryEdge?: Maybe<WebsocketsStatisticsEntriesEdge>;
};


/** The output of our update `WebsocketsStatisticsEntry` mutation. */
export type UpdateWebsocketsStatisticsEntryPayloadWebsocketsStatisticsEntryEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsocketsStatisticsEntriesOrderBy>>;
};

/** All input for the `updateWorkTypeByNodeId` mutation. */
export type UpdateWorkTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WorkType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `WorkType` being updated. */
  patch: WorkTypePatch;
};

/** All input for the `updateWorkType` mutation. */
export type UpdateWorkTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['BigInt']['input'];
  /** An object where the defined keys will be set on the `WorkType` being updated. */
  patch: WorkTypePatch;
};

/** The output of our update `WorkType` mutation. */
export type UpdateWorkTypePayload = {
  __typename?: 'UpdateWorkTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `WorkType`. */
  organization?: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WorkType` that was updated by this mutation. */
  workType?: Maybe<WorkType>;
  /** An edge for our `WorkType`. May be used by Relay 1. */
  workTypeEdge?: Maybe<WorkTypesEdge>;
};


/** The output of our update `WorkType` mutation. */
export type UpdateWorkTypePayloadWorkTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkTypesOrderBy>>;
};

export type User = Node & {
  __typename?: 'User';
  /** Reads a single `Admin` that is related to this `User`. */
  admin?: Maybe<Admin>;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFillupFormApprovedByAndAdminId: UserAdminsByFillupFormApprovedByAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsByFillupFormUserIdAndAdminId: UserAdminsByFillupFormUserIdAndAdminIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Admin`. */
  adminsBySchedulerUserIdAndAdminId: UserAdminsBySchedulerUserIdAndAdminIdManyToManyConnection;
  cardBrand?: Maybe<Scalars['String']['output']>;
  cardLastFour?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Certification`. */
  certificationsByAdminId: CertificationsConnection;
  /** Reads and enables pagination through a set of `User`. */
  childUsers: UsersConnection;
  /** Reads and enables pagination through a set of `Company`. */
  companiesByCompanyUserUserIdAndCompanyId: UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  /** Reads and enables pagination through a set of `Course`. */
  coursesByAdminId: CoursesConnection;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  deviceName?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  emailVerifiedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipmentByIssuanceUserIdAndEquipmentId: UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipmentByPreparedBy: EquipmentConnection;
  /** Reads and enables pagination through a set of `EquipmentType`. */
  equipmentTypesByEquipmentPreparedByAndEquipmentTypeId: UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyConnection;
  facebookId?: Maybe<Scalars['String']['output']>;
  favoriteColor?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsByApprovedBy: FillupFormsConnection;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsBySchedulerUserIdAndFillupformId: UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplateUser`. */
  formTemplateUsers: FormTemplateUsersConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesByFormTemplateUserUserIdAndFormTemplateId: UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormTemplate`. */
  formTemplatesBySchedulerUserIdAndFormTemplateId: UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyConnection;
  /** Reads and enables pagination through a set of `FormUser`. */
  formUsers: FormUsersConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFillupFormApprovedByAndFormId: UserFormsByFillupFormApprovedByAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFillupFormUserIdAndFormId: UserFormsByFillupFormUserIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsByFormUserUserIdAndFormId: UserFormsByFormUserUserIdAndFormIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Form`. */
  formsBySchedulerUserIdAndFormId: UserFormsBySchedulerUserIdAndFormIdManyToManyConnection;
  googleId?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByGroupUserUserIdAndGroupId: UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Group`. */
  groupsBySchedulerUserIdAndGroupId: UserGroupsBySchedulerUserIdAndGroupIdManyToManyConnection;
  id: Scalars['BigInt']['output'];
  isActive: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `Issuance`. */
  issuances: IssuancesConnection;
  /** Reads and enables pagination through a set of `JobSendingEmailCategory`. */
  jobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryId: UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyConnection;
  /** Reads and enables pagination through a set of `JobSendingEmailCategory`. */
  jobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryId: UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyConnection;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentFrom: JobSendingEmailsConnection;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentTo: JobSendingEmailsConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobsByAdminId: JobsConnection;
  /** Reads and enables pagination through a set of `LoginTransaction`. */
  loginTransactions: LoginTransactionsConnection;
  /** The user_name on register form. */
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationUser`. */
  organizationUsers: OrganizationUsersConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByCertificationAdminIdAndOrganizationId: UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByCourseAdminIdAndOrganizationId: UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByEquipmentPreparedByAndOrganizationId: UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByJobAdminIdAndOrganizationId: UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByOrganizationUserUserIdAndOrganizationId: UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByRoleUserOrganizationUserIdAndOrgId: UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsBySchedulerUserIdAndOrgId: UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Organization`. */
  organizationsByUserInviteAdminIdAndOrganizationId: UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyConnection;
  /** Reads a single `User` that is related to this `User`. */
  parent?: Maybe<User>;
  parentId?: Maybe<Scalars['BigInt']['output']>;
  password: Scalars['String']['output'];
  /** Mobile number useful when sending verification code. */
  phoneNumber?: Maybe<Scalars['String']['output']>;
  /** Make sure to empty before sending another verification. */
  phoneNumberVerificationCode?: Maybe<Scalars['String']['output']>;
  phoneNumberVerifiedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Profile` that is related to this `User`. */
  profile?: Maybe<Profile>;
  /** Reads and enables pagination through a set of `Profile`. */
  profiles: ProfilesConnection;
  /** Reads and enables pagination through a set of `ProjectUser`. */
  projectUsers: ProjectUsersConnection;
  /** Reads and enables pagination through a set of `Project`. */
  projectsByProjectUserUserIdAndProjectId: UserProjectsByProjectUserUserIdAndProjectIdManyToManyConnection;
  qrValue?: Maybe<Scalars['String']['output']>;
  rememberToken?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
  /** Reads and enables pagination through a set of `RoleUser`. */
  roleUsers: RoleUsersConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByRoleUserOrganizationUserIdAndRoleId: UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByRoleUserUserIdAndRoleId: UserRolesByRoleUserUserIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Role`. */
  rolesByUserInviteAdminIdAndRoleId: UserRolesByUserInviteAdminIdAndRoleIdManyToManyConnection;
  /** Reads and enables pagination through a set of `SchedulerField`. */
  schedulerFieldsBySchedulerUserIdAndSchedulerFieldsId: UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
  /** Reads and enables pagination through a set of `Setting`. */
  settingsByUserSettingUserIdAndSettingId: UserSettingsByUserSettingUserIdAndSettingIdManyToManyConnection;
  stripeId?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TeamUser`. */
  teamUsers: TeamUsersConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsBySchedulerUserIdAndTeamId: UserTeamsBySchedulerUserIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByTeamUserUserIdAndTeamId: UserTeamsByTeamUserUserIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByUserInviteAdminIdAndTeamId: UserTeamsByUserInviteAdminIdAndTeamIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ToolUser`. */
  toolUsers: ToolUsersConnection;
  /** Reads and enables pagination through a set of `Tool`. */
  toolsByToolUserUserIdAndToolId: UserToolsByToolUserUserIdAndToolIdManyToManyConnection;
  trialEndsAt?: Maybe<Scalars['Datetime']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvitesByAdminId: UserInvitesConnection;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettings: UserSettingsConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormApprovedByAndUserId: UserUsersByFillupFormApprovedByAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByFillupFormUserIdAndApprovedBy: UserUsersByFillupFormUserIdAndApprovedByManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByJobSendingEmailSentFromAndSentTo: UserUsersByJobSendingEmailSentFromAndSentToManyToManyConnection;
  /** Reads and enables pagination through a set of `User`. */
  usersByJobSendingEmailSentToAndSentFrom: UserUsersByJobSendingEmailSentToAndSentFromManyToManyConnection;
  uuid?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `VerificationTokenType`. */
  verificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeId: UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `VerificationToken`. */
  verificationTokens: VerificationTokensConnection;
};


export type UserAdminsByFillupFormApprovedByAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type UserAdminsByFillupFormUserIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type UserAdminsBySchedulerUserIdAndAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdminCondition>;
  filter?: InputMaybe<AdminFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdminsOrderBy>>;
};


export type UserCertificationsByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CertificationCondition>;
  filter?: InputMaybe<CertificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};


export type UserChildUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type UserCompaniesByCompanyUserUserIdAndCompanyIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyCondition>;
  filter?: InputMaybe<CompanyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompaniesOrderBy>>;
};


export type UserCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};


export type UserCoursesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CourseCondition>;
  filter?: InputMaybe<CourseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};


export type UserEquipmentByIssuanceUserIdAndEquipmentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};


export type UserEquipmentByPreparedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};


export type UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentTypeCondition>;
  filter?: InputMaybe<EquipmentTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentTypesOrderBy>>;
};


export type UserFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type UserFillupFormsByApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type UserFillupFormsBySchedulerUserIdAndFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};


export type UserFormTemplateUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateUserCondition>;
  filter?: InputMaybe<FormTemplateUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplateUsersOrderBy>>;
};


export type UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type UserFormTemplatesBySchedulerUserIdAndFormTemplateIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormTemplateCondition>;
  filter?: InputMaybe<FormTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormTemplatesOrderBy>>;
};


export type UserFormUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormUserCondition>;
  filter?: InputMaybe<FormUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormUsersOrderBy>>;
};


export type UserFormsByFillupFormApprovedByAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type UserFormsByFillupFormUserIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type UserFormsByFormUserUserIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type UserFormsBySchedulerUserIdAndFormIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FormCondition>;
  filter?: InputMaybe<FormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FormsOrderBy>>;
};


export type UserGroupUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupUserCondition>;
  filter?: InputMaybe<GroupUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};


export type UserGroupsByGroupUserUserIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type UserGroupsBySchedulerUserIdAndGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type UserIssuancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IssuanceCondition>;
  filter?: InputMaybe<IssuanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};


export type UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCategoryCondition>;
  filter?: InputMaybe<JobSendingEmailCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};


export type UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCategoryCondition>;
  filter?: InputMaybe<JobSendingEmailCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailCategoriesOrderBy>>;
};


export type UserJobSendingEmailsBySentFromArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};


export type UserJobSendingEmailsBySentToArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};


export type UserJobsByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type UserLoginTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LoginTransactionCondition>;
  filter?: InputMaybe<LoginTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LoginTransactionsOrderBy>>;
};


export type UserOrganizationUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationUserCondition>;
  filter?: InputMaybe<OrganizationUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationUsersOrderBy>>;
};


export type UserOrganizationsByCertificationAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByCourseAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByEquipmentPreparedByAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByJobAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByOrganizationUserUserIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsBySchedulerUserIdAndOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserOrganizationsByUserInviteAdminIdAndOrganizationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


export type UserProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProfileCondition>;
  filter?: InputMaybe<ProfileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProfilesOrderBy>>;
};


export type UserProjectUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectUserCondition>;
  filter?: InputMaybe<ProjectUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};


export type UserProjectsByProjectUserUserIdAndProjectIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectCondition>;
  filter?: InputMaybe<ProjectFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};


export type UserRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};


export type UserRoleUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserCondition>;
  filter?: InputMaybe<RoleUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUsersOrderBy>>;
};


export type UserRolesByRoleUserOrganizationUserIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type UserRolesByRoleUserUserIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type UserRolesByUserInviteAdminIdAndRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleCondition>;
  filter?: InputMaybe<RoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};


export type UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerFieldCondition>;
  filter?: InputMaybe<SchedulerFieldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulerFieldsOrderBy>>;
};


export type UserSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};


export type UserSettingsByUserSettingUserIdAndSettingIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SettingCondition>;
  filter?: InputMaybe<SettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};


export type UserTeamUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamUserCondition>;
  filter?: InputMaybe<TeamUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};


export type UserTeamsBySchedulerUserIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type UserTeamsByTeamUserUserIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type UserTeamsByUserInviteAdminIdAndTeamIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamCondition>;
  filter?: InputMaybe<TeamFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamsOrderBy>>;
};


export type UserToolUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolUserCondition>;
  filter?: InputMaybe<ToolUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};


export type UserToolsByToolUserUserIdAndToolIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolCondition>;
  filter?: InputMaybe<ToolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolsOrderBy>>;
};


export type UserUserInvitesByAdminIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};


export type UserUserSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserSettingCondition>;
  filter?: InputMaybe<UserSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};


export type UserUsersByFillupFormApprovedByAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type UserUsersByFillupFormUserIdAndApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type UserUsersByJobSendingEmailSentFromAndSentToArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type UserUsersByJobSendingEmailSentToAndSentFromArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenTypeCondition>;
  filter?: InputMaybe<VerificationTokenTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokenTypesOrderBy>>;
};


export type UserVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenCondition>;
  filter?: InputMaybe<VerificationTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `FillupForm`. */
export type UserAdminsByFillupFormApprovedByAndAdminIdManyToManyConnection = {
  __typename?: 'UserAdminsByFillupFormApprovedByAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserAdminsByFillupFormApprovedByAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type UserAdminsByFillupFormApprovedByAndAdminIdManyToManyEdge = {
  __typename?: 'UserAdminsByFillupFormApprovedByAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type UserAdminsByFillupFormApprovedByAndAdminIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `FillupForm`. */
export type UserAdminsByFillupFormUserIdAndAdminIdManyToManyConnection = {
  __typename?: 'UserAdminsByFillupFormUserIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserAdminsByFillupFormUserIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type UserAdminsByFillupFormUserIdAndAdminIdManyToManyEdge = {
  __typename?: 'UserAdminsByFillupFormUserIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Admin` at the end of the edge. */
  node: Admin;
};


/** A `Admin` edge in the connection, with data from `FillupForm`. */
export type UserAdminsByFillupFormUserIdAndAdminIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Admin` values, with data from `Scheduler`. */
export type UserAdminsBySchedulerUserIdAndAdminIdManyToManyConnection = {
  __typename?: 'UserAdminsBySchedulerUserIdAndAdminIdManyToManyConnection';
  /** A list of edges which contains the `Admin`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserAdminsBySchedulerUserIdAndAdminIdManyToManyEdge>;
  /** A list of `Admin` objects. */
  nodes: Array<Admin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Admin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type UserAdminsBySchedulerUserIdAndAdminIdManyToManyEdge = {
  __typename?: 'UserAdminsBySchedulerUserIdAndAdminIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Admin` at the end of the edge. */
  node: Admin;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Admin` edge in the connection, with data from `Scheduler`. */
export type UserAdminsBySchedulerUserIdAndAdminIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Company` values, with data from `CompanyUser`. */
export type UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyConnection = {
  __typename?: 'UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyConnection';
  /** A list of edges which contains the `Company`, info from the `CompanyUser`, and the cursor to aid in pagination. */
  edges: Array<UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyEdge>;
  /** A list of `Company` objects. */
  nodes: Array<Company>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Company` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Company` edge in the connection, with data from `CompanyUser`. */
export type UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyEdge = {
  __typename?: 'UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyEdge';
  /** Reads and enables pagination through a set of `CompanyUser`. */
  companyUsers: CompanyUsersConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Company` at the end of the edge. */
  node: Company;
};


/** A `Company` edge in the connection, with data from `CompanyUser`. */
export type UserCompaniesByCompanyUserUserIdAndCompanyIdManyToManyEdgeCompanyUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CompanyUserCondition>;
  filter?: InputMaybe<CompanyUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CompanyUsersOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `cardBrand` field. */
  cardBrand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cardLastFour` field. */
  cardLastFour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deviceName` field. */
  deviceName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailVerifiedAt` field. */
  emailVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `facebookId` field. */
  facebookId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `favoriteColor` field. */
  favoriteColor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `googleId` field. */
  googleId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phoneNumberVerificationCode` field. */
  phoneNumberVerificationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phoneNumberVerifiedAt` field. */
  phoneNumberVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rememberToken` field. */
  rememberToken?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stripeId` field. */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `trialEndsAt` field. */
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Equipment` values, with data from `Issuance`. */
export type UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyConnection = {
  __typename?: 'UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyConnection';
  /** A list of edges which contains the `Equipment`, info from the `Issuance`, and the cursor to aid in pagination. */
  edges: Array<UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyEdge>;
  /** A list of `Equipment` objects. */
  nodes: Array<Equipment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Equipment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Equipment` edge in the connection, with data from `Issuance`. */
export type UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyEdge = {
  __typename?: 'UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Issuance`. */
  issuances: IssuancesConnection;
  /** The `Equipment` at the end of the edge. */
  node: Equipment;
};


/** A `Equipment` edge in the connection, with data from `Issuance`. */
export type UserEquipmentByIssuanceUserIdAndEquipmentIdManyToManyEdgeIssuancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IssuanceCondition>;
  filter?: InputMaybe<IssuanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IssuancesOrderBy>>;
};

/** A connection to a list of `EquipmentType` values, with data from `Equipment`. */
export type UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyConnection = {
  __typename?: 'UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyConnection';
  /** A list of edges which contains the `EquipmentType`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyEdge>;
  /** A list of `EquipmentType` objects. */
  nodes: Array<EquipmentType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EquipmentType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EquipmentType` edge in the connection, with data from `Equipment`. */
export type UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyEdge = {
  __typename?: 'UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  /** The `EquipmentType` at the end of the edge. */
  node: EquipmentType;
};


/** A `EquipmentType` edge in the connection, with data from `Equipment`. */
export type UserEquipmentTypesByEquipmentPreparedByAndEquipmentTypeIdManyToManyEdgeEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** A connection to a list of `FillupForm` values, with data from `Scheduler`. */
export type UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyConnection = {
  __typename?: 'UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyConnection';
  /** A list of edges which contains the `FillupForm`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyEdge>;
  /** A list of `FillupForm` objects. */
  nodes: Array<FillupForm>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FillupForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyEdge = {
  __typename?: 'UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FillupForm` at the end of the edge. */
  node: FillupForm;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByFillupformId: SchedulersConnection;
};


/** A `FillupForm` edge in the connection, with data from `Scheduler`. */
export type UserFillupFormsBySchedulerUserIdAndFillupformIdManyToManyEdgeSchedulersByFillupformIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `cardBrand` field. */
  cardBrand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cardLastFour` field. */
  cardLastFour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deviceName` field. */
  deviceName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailVerifiedAt` field. */
  emailVerifiedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `facebookId` field. */
  facebookId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `favoriteColor` field. */
  favoriteColor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `googleId` field. */
  googleId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `password` field. */
  password?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phoneNumberVerificationCode` field. */
  phoneNumberVerificationCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phoneNumberVerifiedAt` field. */
  phoneNumberVerifiedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rememberToken` field. */
  rememberToken?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stripeId` field. */
  stripeId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trialEndsAt` field. */
  trialEndsAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `FormTemplate` values, with data from `FormTemplateUser`. */
export type UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `FormTemplateUser`, and the cursor to aid in pagination. */
  edges: Array<UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `FormTemplateUser`. */
export type UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'UserFormTemplatesByFormTemplateUserUserIdAndFormTemplateIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `FormTemplate` values, with data from `Scheduler`. */
export type UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyConnection = {
  __typename?: 'UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyConnection';
  /** A list of edges which contains the `FormTemplate`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyEdge>;
  /** A list of `FormTemplate` objects. */
  nodes: Array<FormTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FormTemplate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyEdge = {
  __typename?: 'UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FormTemplate` at the end of the edge. */
  node: FormTemplate;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `FormTemplate` edge in the connection, with data from `Scheduler`. */
export type UserFormTemplatesBySchedulerUserIdAndFormTemplateIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `FillupForm`. */
export type UserFormsByFillupFormApprovedByAndFormIdManyToManyConnection = {
  __typename?: 'UserFormsByFillupFormApprovedByAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserFormsByFillupFormApprovedByAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `FillupForm`. */
export type UserFormsByFillupFormApprovedByAndFormIdManyToManyEdge = {
  __typename?: 'UserFormsByFillupFormApprovedByAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Form` at the end of the edge. */
  node: Form;
};


/** A `Form` edge in the connection, with data from `FillupForm`. */
export type UserFormsByFillupFormApprovedByAndFormIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `FillupForm`. */
export type UserFormsByFillupFormUserIdAndFormIdManyToManyConnection = {
  __typename?: 'UserFormsByFillupFormUserIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserFormsByFillupFormUserIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `FillupForm`. */
export type UserFormsByFillupFormUserIdAndFormIdManyToManyEdge = {
  __typename?: 'UserFormsByFillupFormUserIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `Form` at the end of the edge. */
  node: Form;
};


/** A `Form` edge in the connection, with data from `FillupForm`. */
export type UserFormsByFillupFormUserIdAndFormIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `Form` values, with data from `FormUser`. */
export type UserFormsByFormUserUserIdAndFormIdManyToManyConnection = {
  __typename?: 'UserFormsByFormUserUserIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `FormUser`, and the cursor to aid in pagination. */
  edges: Array<UserFormsByFormUserUserIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `FormUser`. */
export type UserFormsByFormUserUserIdAndFormIdManyToManyEdge = {
  __typename?: 'UserFormsByFormUserUserIdAndFormIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Form` values, with data from `Scheduler`. */
export type UserFormsBySchedulerUserIdAndFormIdManyToManyConnection = {
  __typename?: 'UserFormsBySchedulerUserIdAndFormIdManyToManyConnection';
  /** A list of edges which contains the `Form`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserFormsBySchedulerUserIdAndFormIdManyToManyEdge>;
  /** A list of `Form` objects. */
  nodes: Array<Form>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Form` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Form` edge in the connection, with data from `Scheduler`. */
export type UserFormsBySchedulerUserIdAndFormIdManyToManyEdge = {
  __typename?: 'UserFormsBySchedulerUserIdAndFormIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Form` at the end of the edge. */
  node: Form;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Form` edge in the connection, with data from `Scheduler`. */
export type UserFormsBySchedulerUserIdAndFormIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsByGroupUserUserIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `GroupUser`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `GroupUser`. */
  groupUsers: GroupUsersConnection;
  /** The `Group` at the end of the edge. */
  node: Group;
};


/** A `Group` edge in the connection, with data from `GroupUser`. */
export type UserGroupsByGroupUserUserIdAndGroupIdManyToManyEdgeGroupUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupUserCondition>;
  filter?: InputMaybe<GroupUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupUsersOrderBy>>;
};

/** A connection to a list of `Group` values, with data from `Scheduler`. */
export type UserGroupsBySchedulerUserIdAndGroupIdManyToManyConnection = {
  __typename?: 'UserGroupsBySchedulerUserIdAndGroupIdManyToManyConnection';
  /** A list of edges which contains the `Group`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserGroupsBySchedulerUserIdAndGroupIdManyToManyEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection, with data from `Scheduler`. */
export type UserGroupsBySchedulerUserIdAndGroupIdManyToManyEdge = {
  __typename?: 'UserGroupsBySchedulerUserIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Group` edge in the connection, with data from `Scheduler`. */
export type UserGroupsBySchedulerUserIdAndGroupIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  cardBrand?: InputMaybe<Scalars['String']['input']>;
  cardLastFour?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  deviceName?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  emailVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  facebookId?: InputMaybe<Scalars['String']['input']>;
  favoriteColor?: InputMaybe<Scalars['String']['input']>;
  googleId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** The user_name on register form. */
  name: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  password: Scalars['String']['input'];
  /** Mobile number useful when sending verification code. */
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** Make sure to empty before sending another verification. */
  phoneNumberVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneNumberVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  rememberToken?: InputMaybe<Scalars['String']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

export type UserInvite = Node & {
  __typename?: 'UserInvite';
  /** Reads a single `User` that is related to this `UserInvite`. */
  admin?: Maybe<User>;
  adminId?: Maybe<Scalars['BigInt']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  email: Scalars['String']['output'];
  expiredAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `UserInvite`. */
  organization?: Maybe<Organization>;
  organizationId?: Maybe<Scalars['BigInt']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Role` that is related to this `UserInvite`. */
  role?: Maybe<Role>;
  roleId: Scalars['BigInt']['output'];
  status?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Team` that is related to this `UserInvite`. */
  team?: Maybe<Team>;
  teamId?: Maybe<Scalars['BigInt']['output']>;
  token: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `UserInvite` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserInviteCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expiredAt` field. */
  expiredAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `UserInvite` object types. All fields are combined with a logical ‘and.’ */
export type UserInviteFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserInviteFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiredAt` field. */
  expiredAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserInviteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserInviteFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `UserInvite` */
export type UserInviteInput = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  email: Scalars['String']['input'];
  expiredAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['BigInt']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `UserInvite`. Fields that are set will be updated. */
export type UserInvitePatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  expiredAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  roleId?: InputMaybe<Scalars['BigInt']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  teamId?: InputMaybe<Scalars['BigInt']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `UserInvite` values. */
export type UserInvitesConnection = {
  __typename?: 'UserInvitesConnection';
  /** A list of edges which contains the `UserInvite` and cursor to aid in pagination. */
  edges: Array<UserInvitesEdge>;
  /** A list of `UserInvite` objects. */
  nodes: Array<UserInvite>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserInvite` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserInvite` edge in the connection. */
export type UserInvitesEdge = {
  __typename?: 'UserInvitesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserInvite` at the end of the edge. */
  node: UserInvite;
};

/** Methods to use when ordering `UserInvite`. */
export enum UserInvitesOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  ExpiredAtAsc = 'EXPIRED_AT_ASC',
  ExpiredAtDesc = 'EXPIRED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TeamIdAsc = 'TEAM_ID_ASC',
  TeamIdDesc = 'TEAM_ID_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `JobSendingEmailCategory` values, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyConnection = {
  __typename?: 'UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyConnection';
  /** A list of edges which contains the `JobSendingEmailCategory`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyEdge>;
  /** A list of `JobSendingEmailCategory` objects. */
  nodes: Array<JobSendingEmailCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSendingEmailCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSendingEmailCategory` edge in the connection, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyEdge = {
  __typename?: 'UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsByCategoryId: JobSendingEmailsConnection;
  /** The `JobSendingEmailCategory` at the end of the edge. */
  node: JobSendingEmailCategory;
};


/** A `JobSendingEmailCategory` edge in the connection, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentFromAndCategoryIdManyToManyEdgeJobSendingEmailsByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** A connection to a list of `JobSendingEmailCategory` values, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyConnection = {
  __typename?: 'UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyConnection';
  /** A list of edges which contains the `JobSendingEmailCategory`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyEdge>;
  /** A list of `JobSendingEmailCategory` objects. */
  nodes: Array<JobSendingEmailCategory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JobSendingEmailCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JobSendingEmailCategory` edge in the connection, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyEdge = {
  __typename?: 'UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsByCategoryId: JobSendingEmailsConnection;
  /** The `JobSendingEmailCategory` at the end of the edge. */
  node: JobSendingEmailCategory;
};


/** A `JobSendingEmailCategory` edge in the connection, with data from `JobSendingEmail`. */
export type UserJobSendingEmailCategoriesByJobSendingEmailSentToAndCategoryIdManyToManyEdgeJobSendingEmailsByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Certification`. */
export type UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Certification`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Certification`. */
export type UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Certification`. */
  certifications: CertificationsConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Certification`. */
export type UserOrganizationsByCertificationAdminIdAndOrganizationIdManyToManyEdgeCertificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CertificationCondition>;
  filter?: InputMaybe<CertificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CertificationsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Course`. */
export type UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Course`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Course`. */
export type UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyEdge';
  /** Reads and enables pagination through a set of `Course`. */
  courses: CoursesConnection;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Course`. */
export type UserOrganizationsByCourseAdminIdAndOrganizationIdManyToManyEdgeCoursesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CourseCondition>;
  filter?: InputMaybe<CourseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CoursesOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Equipment`. */
export type UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Equipment`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Equipment`. */
export type UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Equipment`. */
  equipments: EquipmentConnection;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Equipment`. */
export type UserOrganizationsByEquipmentPreparedByAndOrganizationIdManyToManyEdgeEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EquipmentCondition>;
  filter?: InputMaybe<EquipmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EquipmentOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Job`. */
export type UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Job`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Job`. */
export type UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `Job`. */
  jobs: JobsConnection;
  /** The `Organization` at the end of the edge. */
  node: Organization;
};


/** A `Organization` edge in the connection, with data from `Job`. */
export type UserOrganizationsByJobAdminIdAndOrganizationIdManyToManyEdgeJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `OrganizationUser`. */
export type UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `OrganizationUser`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `OrganizationUser`. */
export type UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByOrganizationUserUserIdAndOrganizationIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Organization` values, with data from `RoleUserOrganization`. */
export type UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `RoleUserOrganization`. */
export type UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizationsByOrgId: RoleUserOrganizationsConnection;
};


/** A `Organization` edge in the connection, with data from `RoleUserOrganization`. */
export type UserOrganizationsByRoleUserOrganizationUserIdAndOrgIdManyToManyEdgeRoleUserOrganizationsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `Scheduler`. */
export type UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyConnection = {
  __typename?: 'UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyEdge = {
  __typename?: 'UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersByOrgId: SchedulersConnection;
};


/** A `Organization` edge in the connection, with data from `Scheduler`. */
export type UserOrganizationsBySchedulerUserIdAndOrgIdManyToManyEdgeSchedulersByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Organization` values, with data from `UserInvite`. */
export type UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyConnection = {
  __typename?: 'UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyConnection';
  /** A list of edges which contains the `Organization`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyEdge>;
  /** A list of `Organization` objects. */
  nodes: Array<Organization>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyEdge = {
  __typename?: 'UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Organization;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Organization` edge in the connection, with data from `UserInvite`. */
export type UserOrganizationsByUserInviteAdminIdAndOrganizationIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  cardBrand?: InputMaybe<Scalars['String']['input']>;
  cardLastFour?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  deviceName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  facebookId?: InputMaybe<Scalars['String']['input']>;
  favoriteColor?: InputMaybe<Scalars['String']['input']>;
  googleId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** The user_name on register form. */
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['BigInt']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  /** Mobile number useful when sending verification code. */
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** Make sure to empty before sending another verification. */
  phoneNumberVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneNumberVerifiedAt?: InputMaybe<Scalars['Datetime']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  rememberToken?: InputMaybe<Scalars['String']['input']>;
  stripeId?: InputMaybe<Scalars['String']['input']>;
  trialEndsAt?: InputMaybe<Scalars['Datetime']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `Project` values, with data from `ProjectUser`. */
export type UserProjectsByProjectUserUserIdAndProjectIdManyToManyConnection = {
  __typename?: 'UserProjectsByProjectUserUserIdAndProjectIdManyToManyConnection';
  /** A list of edges which contains the `Project`, info from the `ProjectUser`, and the cursor to aid in pagination. */
  edges: Array<UserProjectsByProjectUserUserIdAndProjectIdManyToManyEdge>;
  /** A list of `Project` objects. */
  nodes: Array<Project>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Project` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Project` edge in the connection, with data from `ProjectUser`. */
export type UserProjectsByProjectUserUserIdAndProjectIdManyToManyEdge = {
  __typename?: 'UserProjectsByProjectUserUserIdAndProjectIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Project` at the end of the edge. */
  node: Project;
  /** Reads and enables pagination through a set of `ProjectUser`. */
  projectUsers: ProjectUsersConnection;
};


/** A `Project` edge in the connection, with data from `ProjectUser`. */
export type UserProjectsByProjectUserUserIdAndProjectIdManyToManyEdgeProjectUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProjectUserCondition>;
  filter?: InputMaybe<ProjectUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
};

/** A connection to a list of `Role` values, with data from `RoleUserOrganization`. */
export type UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyConnection = {
  __typename?: 'UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `RoleUserOrganization`, and the cursor to aid in pagination. */
  edges: Array<UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `RoleUserOrganization`. */
export type UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyEdge = {
  __typename?: 'UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  /** Reads and enables pagination through a set of `RoleUserOrganization`. */
  roleUserOrganizations: RoleUserOrganizationsConnection;
};


/** A `Role` edge in the connection, with data from `RoleUserOrganization`. */
export type UserRolesByRoleUserOrganizationUserIdAndRoleIdManyToManyEdgeRoleUserOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RoleUserOrganizationCondition>;
  filter?: InputMaybe<RoleUserOrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RoleUserOrganizationsOrderBy>>;
};

/** A connection to a list of `Role` values, with data from `RoleUser`. */
export type UserRolesByRoleUserUserIdAndRoleIdManyToManyConnection = {
  __typename?: 'UserRolesByRoleUserUserIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `RoleUser`, and the cursor to aid in pagination. */
  edges: Array<UserRolesByRoleUserUserIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `RoleUser`. */
export type UserRolesByRoleUserUserIdAndRoleIdManyToManyEdge = {
  __typename?: 'UserRolesByRoleUserUserIdAndRoleIdManyToManyEdge';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
};

/** A connection to a list of `Role` values, with data from `UserInvite`. */
export type UserRolesByUserInviteAdminIdAndRoleIdManyToManyConnection = {
  __typename?: 'UserRolesByUserInviteAdminIdAndRoleIdManyToManyConnection';
  /** A list of edges which contains the `Role`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<UserRolesByUserInviteAdminIdAndRoleIdManyToManyEdge>;
  /** A list of `Role` objects. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Role` edge in the connection, with data from `UserInvite`. */
export type UserRolesByUserInviteAdminIdAndRoleIdManyToManyEdge = {
  __typename?: 'UserRolesByUserInviteAdminIdAndRoleIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Role` at the end of the edge. */
  node: Role;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Role` edge in the connection, with data from `UserInvite`. */
export type UserRolesByUserInviteAdminIdAndRoleIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `SchedulerField` values, with data from `Scheduler`. */
export type UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyConnection = {
  __typename?: 'UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyConnection';
  /** A list of edges which contains the `SchedulerField`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyEdge>;
  /** A list of `SchedulerField` objects. */
  nodes: Array<SchedulerField>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchedulerField` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyEdge = {
  __typename?: 'UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchedulerField` at the end of the edge. */
  node: SchedulerField;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulersBySchedulerFieldsId: SchedulersConnection;
};


/** A `SchedulerField` edge in the connection, with data from `Scheduler`. */
export type UserSchedulerFieldsBySchedulerUserIdAndSchedulerFieldsIdManyToManyEdgeSchedulersBySchedulerFieldsIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

export type UserSetting = Node & {
  __typename?: 'UserSetting';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Setting` that is related to this `UserSetting`. */
  setting?: Maybe<Setting>;
  settingId: Scalars['BigInt']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `UserSetting`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
  uuid?: Maybe<Scalars['UUID']['output']>;
  value: Scalars['JSON']['output'];
};

/**
 * A condition to be used against `UserSetting` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserSettingCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `settingId` field. */
  settingId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `UserSetting` object types. All fields are combined with a logical ‘and.’ */
export type UserSettingFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserSettingFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserSettingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserSettingFilter>>;
  /** Filter by the object’s `settingId` field. */
  settingId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `UserSetting` */
export type UserSettingInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  settingId: Scalars['BigInt']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  value: Scalars['JSON']['input'];
};

/** Represents an update to a `UserSetting`. Fields that are set will be updated. */
export type UserSettingPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  settingId?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `Setting` values, with data from `UserSetting`. */
export type UserSettingsByUserSettingUserIdAndSettingIdManyToManyConnection = {
  __typename?: 'UserSettingsByUserSettingUserIdAndSettingIdManyToManyConnection';
  /** A list of edges which contains the `Setting`, info from the `UserSetting`, and the cursor to aid in pagination. */
  edges: Array<UserSettingsByUserSettingUserIdAndSettingIdManyToManyEdge>;
  /** A list of `Setting` objects. */
  nodes: Array<Setting>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Setting` edge in the connection, with data from `UserSetting`. */
export type UserSettingsByUserSettingUserIdAndSettingIdManyToManyEdge = {
  __typename?: 'UserSettingsByUserSettingUserIdAndSettingIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Setting` at the end of the edge. */
  node: Setting;
  /** Reads and enables pagination through a set of `UserSetting`. */
  userSettings: UserSettingsConnection;
};


/** A `Setting` edge in the connection, with data from `UserSetting`. */
export type UserSettingsByUserSettingUserIdAndSettingIdManyToManyEdgeUserSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserSettingCondition>;
  filter?: InputMaybe<UserSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSettingsOrderBy>>;
};

/** A connection to a list of `UserSetting` values. */
export type UserSettingsConnection = {
  __typename?: 'UserSettingsConnection';
  /** A list of edges which contains the `UserSetting` and cursor to aid in pagination. */
  edges: Array<UserSettingsEdge>;
  /** A list of `UserSetting` objects. */
  nodes: Array<UserSetting>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserSetting` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserSetting` edge in the connection. */
export type UserSettingsEdge = {
  __typename?: 'UserSettingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserSetting` at the end of the edge. */
  node: UserSetting;
};

/** Methods to use when ordering `UserSetting`. */
export enum UserSettingsOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SettingIdAsc = 'SETTING_ID_ASC',
  SettingIdDesc = 'SETTING_ID_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

/** A connection to a list of `Team` values, with data from `Scheduler`. */
export type UserTeamsBySchedulerUserIdAndTeamIdManyToManyConnection = {
  __typename?: 'UserTeamsBySchedulerUserIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `Scheduler`, and the cursor to aid in pagination. */
  edges: Array<UserTeamsBySchedulerUserIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `Scheduler`. */
export type UserTeamsBySchedulerUserIdAndTeamIdManyToManyEdge = {
  __typename?: 'UserTeamsBySchedulerUserIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `Scheduler`. */
  schedulers: SchedulersConnection;
};


/** A `Team` edge in the connection, with data from `Scheduler`. */
export type UserTeamsBySchedulerUserIdAndTeamIdManyToManyEdgeSchedulersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchedulerCondition>;
  filter?: InputMaybe<SchedulerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `TeamUser`. */
export type UserTeamsByTeamUserUserIdAndTeamIdManyToManyConnection = {
  __typename?: 'UserTeamsByTeamUserUserIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `TeamUser`, and the cursor to aid in pagination. */
  edges: Array<UserTeamsByTeamUserUserIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `TeamUser`. */
export type UserTeamsByTeamUserUserIdAndTeamIdManyToManyEdge = {
  __typename?: 'UserTeamsByTeamUserUserIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `TeamUser`. */
  teamUsers: TeamUsersConnection;
};


/** A `Team` edge in the connection, with data from `TeamUser`. */
export type UserTeamsByTeamUserUserIdAndTeamIdManyToManyEdgeTeamUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TeamUserCondition>;
  filter?: InputMaybe<TeamUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamUsersOrderBy>>;
};

/** A connection to a list of `Team` values, with data from `UserInvite`. */
export type UserTeamsByUserInviteAdminIdAndTeamIdManyToManyConnection = {
  __typename?: 'UserTeamsByUserInviteAdminIdAndTeamIdManyToManyConnection';
  /** A list of edges which contains the `Team`, info from the `UserInvite`, and the cursor to aid in pagination. */
  edges: Array<UserTeamsByUserInviteAdminIdAndTeamIdManyToManyEdge>;
  /** A list of `Team` objects. */
  nodes: Array<Team>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Team` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Team` edge in the connection, with data from `UserInvite`. */
export type UserTeamsByUserInviteAdminIdAndTeamIdManyToManyEdge = {
  __typename?: 'UserTeamsByUserInviteAdminIdAndTeamIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Team` at the end of the edge. */
  node: Team;
  /** Reads and enables pagination through a set of `UserInvite`. */
  userInvites: UserInvitesConnection;
};


/** A `Team` edge in the connection, with data from `UserInvite`. */
export type UserTeamsByUserInviteAdminIdAndTeamIdManyToManyEdgeUserInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserInviteCondition>;
  filter?: InputMaybe<UserInviteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitesOrderBy>>;
};

/** A connection to a list of `Tool` values, with data from `ToolUser`. */
export type UserToolsByToolUserUserIdAndToolIdManyToManyConnection = {
  __typename?: 'UserToolsByToolUserUserIdAndToolIdManyToManyConnection';
  /** A list of edges which contains the `Tool`, info from the `ToolUser`, and the cursor to aid in pagination. */
  edges: Array<UserToolsByToolUserUserIdAndToolIdManyToManyEdge>;
  /** A list of `Tool` objects. */
  nodes: Array<Tool>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tool` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tool` edge in the connection, with data from `ToolUser`. */
export type UserToolsByToolUserUserIdAndToolIdManyToManyEdge = {
  __typename?: 'UserToolsByToolUserUserIdAndToolIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tool` at the end of the edge. */
  node: Tool;
  /** Reads and enables pagination through a set of `ToolUser`. */
  toolUsers: ToolUsersConnection;
};


/** A `Tool` edge in the connection, with data from `ToolUser`. */
export type UserToolsByToolUserUserIdAndToolIdManyToManyEdgeToolUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ToolUserCondition>;
  filter?: InputMaybe<ToolUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ToolUsersOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type UserUsersByFillupFormApprovedByAndUserIdManyToManyConnection = {
  __typename?: 'UserUsersByFillupFormApprovedByAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByFillupFormApprovedByAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type UserUsersByFillupFormApprovedByAndUserIdManyToManyEdge = {
  __typename?: 'UserUsersByFillupFormApprovedByAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupForms: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type UserUsersByFillupFormApprovedByAndUserIdManyToManyEdgeFillupFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `FillupForm`. */
export type UserUsersByFillupFormUserIdAndApprovedByManyToManyConnection = {
  __typename?: 'UserUsersByFillupFormUserIdAndApprovedByManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `FillupForm`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByFillupFormUserIdAndApprovedByManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `FillupForm`. */
export type UserUsersByFillupFormUserIdAndApprovedByManyToManyEdge = {
  __typename?: 'UserUsersByFillupFormUserIdAndApprovedByManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `FillupForm`. */
  fillupFormsByApprovedBy: FillupFormsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `FillupForm`. */
export type UserUsersByFillupFormUserIdAndApprovedByManyToManyEdgeFillupFormsByApprovedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FillupFormCondition>;
  filter?: InputMaybe<FillupFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FillupFormsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentFromAndSentToManyToManyConnection = {
  __typename?: 'UserUsersByJobSendingEmailSentFromAndSentToManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByJobSendingEmailSentFromAndSentToManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentFromAndSentToManyToManyEdge = {
  __typename?: 'UserUsersByJobSendingEmailSentFromAndSentToManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentTo: JobSendingEmailsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentFromAndSentToManyToManyEdgeJobSendingEmailsBySentToArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** A connection to a list of `User` values, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentToAndSentFromManyToManyConnection = {
  __typename?: 'UserUsersByJobSendingEmailSentToAndSentFromManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `JobSendingEmail`, and the cursor to aid in pagination. */
  edges: Array<UserUsersByJobSendingEmailSentToAndSentFromManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentToAndSentFromManyToManyEdge = {
  __typename?: 'UserUsersByJobSendingEmailSentToAndSentFromManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** Reads and enables pagination through a set of `JobSendingEmail`. */
  jobSendingEmailsBySentFrom: JobSendingEmailsConnection;
  /** The `User` at the end of the edge. */
  node: User;
};


/** A `User` edge in the connection, with data from `JobSendingEmail`. */
export type UserUsersByJobSendingEmailSentToAndSentFromManyToManyEdgeJobSendingEmailsBySentFromArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobSendingEmailCondition>;
  filter?: InputMaybe<JobSendingEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobSendingEmailsOrderBy>>;
};

/** A connection to a list of `VerificationTokenType` values, with data from `VerificationToken`. */
export type UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyConnection = {
  __typename?: 'UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyConnection';
  /** A list of edges which contains the `VerificationTokenType`, info from the `VerificationToken`, and the cursor to aid in pagination. */
  edges: Array<UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyEdge>;
  /** A list of `VerificationTokenType` objects. */
  nodes: Array<VerificationTokenType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VerificationTokenType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VerificationTokenType` edge in the connection, with data from `VerificationToken`. */
export type UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyEdge = {
  __typename?: 'UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VerificationTokenType` at the end of the edge. */
  node: VerificationTokenType;
  /** Reads and enables pagination through a set of `VerificationToken`. */
  verificationTokens: VerificationTokensConnection;
};


/** A `VerificationTokenType` edge in the connection, with data from `VerificationToken`. */
export type UserVerificationTokenTypesByVerificationTokenUserIdAndVerificationTokenTypeIdManyToManyEdgeVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenCondition>;
  filter?: InputMaybe<VerificationTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  CardBrandAsc = 'CARD_BRAND_ASC',
  CardBrandDesc = 'CARD_BRAND_DESC',
  CardLastFourAsc = 'CARD_LAST_FOUR_ASC',
  CardLastFourDesc = 'CARD_LAST_FOUR_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  DeviceNameAsc = 'DEVICE_NAME_ASC',
  DeviceNameDesc = 'DEVICE_NAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  EmailVerifiedAtAsc = 'EMAIL_VERIFIED_AT_ASC',
  EmailVerifiedAtDesc = 'EMAIL_VERIFIED_AT_DESC',
  FacebookIdAsc = 'FACEBOOK_ID_ASC',
  FacebookIdDesc = 'FACEBOOK_ID_DESC',
  FavoriteColorAsc = 'FAVORITE_COLOR_ASC',
  FavoriteColorDesc = 'FAVORITE_COLOR_DESC',
  GoogleIdAsc = 'GOOGLE_ID_ASC',
  GoogleIdDesc = 'GOOGLE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PasswordAsc = 'PASSWORD_ASC',
  PasswordDesc = 'PASSWORD_DESC',
  PhoneNumberAsc = 'PHONE_NUMBER_ASC',
  PhoneNumberDesc = 'PHONE_NUMBER_DESC',
  PhoneNumberVerificationCodeAsc = 'PHONE_NUMBER_VERIFICATION_CODE_ASC',
  PhoneNumberVerificationCodeDesc = 'PHONE_NUMBER_VERIFICATION_CODE_DESC',
  PhoneNumberVerifiedAtAsc = 'PHONE_NUMBER_VERIFIED_AT_ASC',
  PhoneNumberVerifiedAtDesc = 'PHONE_NUMBER_VERIFIED_AT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  RememberTokenAsc = 'REMEMBER_TOKEN_ASC',
  RememberTokenDesc = 'REMEMBER_TOKEN_DESC',
  StripeIdAsc = 'STRIPE_ID_ASC',
  StripeIdDesc = 'STRIPE_ID_DESC',
  TrialEndsAtAsc = 'TRIAL_ENDS_AT_ASC',
  TrialEndsAtDesc = 'TRIAL_ENDS_AT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type VerificationToken = Node & {
  __typename?: 'VerificationToken';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  expireAt: Scalars['Datetime']['output'];
  id: Scalars['BigInt']['output'];
  message: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sentVia: Scalars['String']['output'];
  token: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `VerificationToken`. */
  user?: Maybe<User>;
  userId: Scalars['BigInt']['output'];
  /** Reads a single `VerificationTokenType` that is related to this `VerificationToken`. */
  verificationTokenType?: Maybe<VerificationTokenType>;
  verificationTokenTypeId: Scalars['BigInt']['output'];
};

/**
 * A condition to be used against `VerificationToken` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VerificationTokenCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `expireAt` field. */
  expireAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sentVia` field. */
  sentVia?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `verificationTokenTypeId` field. */
  verificationTokenTypeId?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `VerificationToken` object types. All fields are combined with a logical ‘and.’ */
export type VerificationTokenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerificationTokenFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expireAt` field. */
  expireAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerificationTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerificationTokenFilter>>;
  /** Filter by the object’s `sentVia` field. */
  sentVia?: InputMaybe<StringFilter>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `verificationTokenTypeId` field. */
  verificationTokenTypeId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `VerificationToken` */
export type VerificationTokenInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  expireAt: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  message: Scalars['String']['input'];
  sentVia: Scalars['String']['input'];
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['BigInt']['input'];
  verificationTokenTypeId: Scalars['BigInt']['input'];
};

/** Represents an update to a `VerificationToken`. Fields that are set will be updated. */
export type VerificationTokenPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  expireAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  sentVia?: InputMaybe<Scalars['String']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['BigInt']['input']>;
  verificationTokenTypeId?: InputMaybe<Scalars['BigInt']['input']>;
};

export type VerificationTokenType = Node & {
  __typename?: 'VerificationTokenType';
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['BigInt']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  usersByVerificationTokenVerificationTokenTypeIdAndUserId: VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyConnection;
  /** Reads and enables pagination through a set of `VerificationToken`. */
  verificationTokens: VerificationTokensConnection;
};


export type VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type VerificationTokenTypeVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenCondition>;
  filter?: InputMaybe<VerificationTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/**
 * A condition to be used against `VerificationTokenType` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type VerificationTokenTypeCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `VerificationTokenType` object types. All fields are combined with a logical ‘and.’ */
export type VerificationTokenTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerificationTokenTypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerificationTokenTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerificationTokenTypeFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `VerificationTokenType` */
export type VerificationTokenTypeInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  description: Scalars['String']['input'];
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `VerificationTokenType`. Fields that are set will be updated. */
export type VerificationTokenTypePatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `User` values, with data from `VerificationToken`. */
export type VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyConnection = {
  __typename?: 'VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyConnection';
  /** A list of edges which contains the `User`, info from the `VerificationToken`, and the cursor to aid in pagination. */
  edges: Array<VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection, with data from `VerificationToken`. */
export type VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyEdge = {
  __typename?: 'VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
  /** Reads and enables pagination through a set of `VerificationToken`. */
  verificationTokens: VerificationTokensConnection;
};


/** A `User` edge in the connection, with data from `VerificationToken`. */
export type VerificationTokenTypeUsersByVerificationTokenVerificationTokenTypeIdAndUserIdManyToManyEdgeVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationTokenCondition>;
  filter?: InputMaybe<VerificationTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationTokensOrderBy>>;
};

/** A connection to a list of `VerificationTokenType` values. */
export type VerificationTokenTypesConnection = {
  __typename?: 'VerificationTokenTypesConnection';
  /** A list of edges which contains the `VerificationTokenType` and cursor to aid in pagination. */
  edges: Array<VerificationTokenTypesEdge>;
  /** A list of `VerificationTokenType` objects. */
  nodes: Array<VerificationTokenType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VerificationTokenType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VerificationTokenType` edge in the connection. */
export type VerificationTokenTypesEdge = {
  __typename?: 'VerificationTokenTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VerificationTokenType` at the end of the edge. */
  node: VerificationTokenType;
};

/** Methods to use when ordering `VerificationTokenType`. */
export enum VerificationTokenTypesOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** A connection to a list of `VerificationToken` values. */
export type VerificationTokensConnection = {
  __typename?: 'VerificationTokensConnection';
  /** A list of edges which contains the `VerificationToken` and cursor to aid in pagination. */
  edges: Array<VerificationTokensEdge>;
  /** A list of `VerificationToken` objects. */
  nodes: Array<VerificationToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VerificationToken` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VerificationToken` edge in the connection. */
export type VerificationTokensEdge = {
  __typename?: 'VerificationTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VerificationToken` at the end of the edge. */
  node: VerificationToken;
};

/** Methods to use when ordering `VerificationToken`. */
export enum VerificationTokensOrderBy {
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  ExpireAtAsc = 'EXPIRE_AT_ASC',
  ExpireAtDesc = 'EXPIRE_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SentViaAsc = 'SENT_VIA_ASC',
  SentViaDesc = 'SENT_VIA_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  VerificationTokenTypeIdAsc = 'VERIFICATION_TOKEN_TYPE_ID_ASC',
  VerificationTokenTypeIdDesc = 'VERIFICATION_TOKEN_TYPE_ID_DESC'
}

export type VwFieldPropertiesPivot = {
  __typename?: 'VwFieldPropertiesPivot';
  class?: Maybe<Scalars['String']['output']>;
  componentDesc?: Maybe<Scalars['String']['output']>;
  componentId?: Maybe<Scalars['BigInt']['output']>;
  css?: Maybe<Scalars['String']['output']>;
  data?: Maybe<Scalars['String']['output']>;
  datasource?: Maybe<Scalars['String']['output']>;
  enabled?: Maybe<Scalars['String']['output']>;
  fieldDeletedAt?: Maybe<Scalars['Datetime']['output']>;
  fieldId?: Maybe<Scalars['BigInt']['output']>;
  formId?: Maybe<Scalars['BigInt']['output']>;
  height?: Maybe<Scalars['String']['output']>;
  imageSrc?: Maybe<Scalars['String']['output']>;
  isRequired?: Maybe<Scalars['String']['output']>;
  isVisible?: Maybe<Scalars['String']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  option?: Maybe<Scalars['String']['output']>;
  sortOrder?: Maybe<Scalars['BigInt']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
  width?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VwFieldPropertiesPivot` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type VwFieldPropertiesPivotCondition = {
  /** Checks for equality with the object’s `class` field. */
  class?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `componentDesc` field. */
  componentDesc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `componentId` field. */
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `css` field. */
  css?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datasource` field. */
  datasource?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `imageSrc` field. */
  imageSrc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isRequired` field. */
  isRequired?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isVisible` field. */
  isVisible?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `option` field. */
  option?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `text` field. */
  text?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `width` field. */
  width?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VwFieldPropertiesPivot` object types. All fields are combined with a logical ‘and.’ */
export type VwFieldPropertiesPivotFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VwFieldPropertiesPivotFilter>>;
  /** Filter by the object’s `class` field. */
  class?: InputMaybe<StringFilter>;
  /** Filter by the object’s `componentDesc` field. */
  componentDesc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `componentId` field. */
  componentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `css` field. */
  css?: InputMaybe<StringFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datasource` field. */
  datasource?: InputMaybe<StringFilter>;
  /** Filter by the object’s `enabled` field. */
  enabled?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `height` field. */
  height?: InputMaybe<StringFilter>;
  /** Filter by the object’s `imageSrc` field. */
  imageSrc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isRequired` field. */
  isRequired?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isVisible` field. */
  isVisible?: InputMaybe<StringFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VwFieldPropertiesPivotFilter>;
  /** Filter by the object’s `option` field. */
  option?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VwFieldPropertiesPivotFilter>>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `text` field. */
  text?: InputMaybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
  /** Filter by the object’s `width` field. */
  width?: InputMaybe<StringFilter>;
};

/** A connection to a list of `VwFieldPropertiesPivot` values. */
export type VwFieldPropertiesPivotsConnection = {
  __typename?: 'VwFieldPropertiesPivotsConnection';
  /** A list of edges which contains the `VwFieldPropertiesPivot` and cursor to aid in pagination. */
  edges: Array<VwFieldPropertiesPivotsEdge>;
  /** A list of `VwFieldPropertiesPivot` objects. */
  nodes: Array<VwFieldPropertiesPivot>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VwFieldPropertiesPivot` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VwFieldPropertiesPivot` edge in the connection. */
export type VwFieldPropertiesPivotsEdge = {
  __typename?: 'VwFieldPropertiesPivotsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VwFieldPropertiesPivot` at the end of the edge. */
  node: VwFieldPropertiesPivot;
};

/** Methods to use when ordering `VwFieldPropertiesPivot`. */
export enum VwFieldPropertiesPivotsOrderBy {
  ClassAsc = 'CLASS_ASC',
  ClassDesc = 'CLASS_DESC',
  ComponentDescAsc = 'COMPONENT_DESC_ASC',
  ComponentDescDesc = 'COMPONENT_DESC_DESC',
  ComponentIdAsc = 'COMPONENT_ID_ASC',
  ComponentIdDesc = 'COMPONENT_ID_DESC',
  CssAsc = 'CSS_ASC',
  CssDesc = 'CSS_DESC',
  DatasourceAsc = 'DATASOURCE_ASC',
  DatasourceDesc = 'DATASOURCE_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EnabledAsc = 'ENABLED_ASC',
  EnabledDesc = 'ENABLED_DESC',
  FieldDeletedAtAsc = 'FIELD_DELETED_AT_ASC',
  FieldDeletedAtDesc = 'FIELD_DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  ImageSrcAsc = 'IMAGE_SRC_ASC',
  ImageSrcDesc = 'IMAGE_SRC_DESC',
  IsRequiredAsc = 'IS_REQUIRED_ASC',
  IsRequiredDesc = 'IS_REQUIRED_DESC',
  IsVisibleAsc = 'IS_VISIBLE_ASC',
  IsVisibleDesc = 'IS_VISIBLE_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OptionAsc = 'OPTION_ASC',
  OptionDesc = 'OPTION_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  TextAsc = 'TEXT_ASC',
  TextDesc = 'TEXT_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  WidthAsc = 'WIDTH_ASC',
  WidthDesc = 'WIDTH_DESC'
}

export type VwFieldPropertyOptionAnswer = {
  __typename?: 'VwFieldPropertyOptionAnswer';
  answer?: Maybe<Scalars['String']['output']>;
  fieldDeletedAt?: Maybe<Scalars['Datetime']['output']>;
  fillupFormFieldId?: Maybe<Scalars['BigInt']['output']>;
  fillupFormId?: Maybe<Scalars['BigInt']['output']>;
  formFieldId?: Maybe<Scalars['BigInt']['output']>;
  formId?: Maybe<Scalars['BigInt']['output']>;
  formUuid?: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `VwFieldPropertyOptionAnswer` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type VwFieldPropertyOptionAnswerCondition = {
  /** Checks for equality with the object’s `answer` field. */
  answer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fillupFormFieldId` field. */
  fillupFormFieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `fillupFormId` field. */
  fillupFormId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formFieldId` field. */
  formFieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formUuid` field. */
  formUuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `VwFieldPropertyOptionAnswer` object types. All fields are combined with a logical ‘and.’ */
export type VwFieldPropertyOptionAnswerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VwFieldPropertyOptionAnswerFilter>>;
  /** Filter by the object’s `answer` field. */
  answer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fillupFormFieldId` field. */
  fillupFormFieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `fillupFormId` field. */
  fillupFormId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formFieldId` field. */
  formFieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formUuid` field. */
  formUuid?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VwFieldPropertyOptionAnswerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VwFieldPropertyOptionAnswerFilter>>;
};

/** A connection to a list of `VwFieldPropertyOptionAnswer` values. */
export type VwFieldPropertyOptionAnswersConnection = {
  __typename?: 'VwFieldPropertyOptionAnswersConnection';
  /** A list of edges which contains the `VwFieldPropertyOptionAnswer` and cursor to aid in pagination. */
  edges: Array<VwFieldPropertyOptionAnswersEdge>;
  /** A list of `VwFieldPropertyOptionAnswer` objects. */
  nodes: Array<VwFieldPropertyOptionAnswer>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VwFieldPropertyOptionAnswer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VwFieldPropertyOptionAnswer` edge in the connection. */
export type VwFieldPropertyOptionAnswersEdge = {
  __typename?: 'VwFieldPropertyOptionAnswersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VwFieldPropertyOptionAnswer` at the end of the edge. */
  node: VwFieldPropertyOptionAnswer;
};

/** Methods to use when ordering `VwFieldPropertyOptionAnswer`. */
export enum VwFieldPropertyOptionAnswersOrderBy {
  AnswerAsc = 'ANSWER_ASC',
  AnswerDesc = 'ANSWER_DESC',
  FieldDeletedAtAsc = 'FIELD_DELETED_AT_ASC',
  FieldDeletedAtDesc = 'FIELD_DELETED_AT_DESC',
  FillupFormFieldIdAsc = 'FILLUP_FORM_FIELD_ID_ASC',
  FillupFormFieldIdDesc = 'FILLUP_FORM_FIELD_ID_DESC',
  FillupFormIdAsc = 'FILLUP_FORM_ID_ASC',
  FillupFormIdDesc = 'FILLUP_FORM_ID_DESC',
  FormFieldIdAsc = 'FORM_FIELD_ID_ASC',
  FormFieldIdDesc = 'FORM_FIELD_ID_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  FormUuidAsc = 'FORM_UUID_ASC',
  FormUuidDesc = 'FORM_UUID_DESC',
  Natural = 'NATURAL'
}

export type VwFieldPropertyOptionChoice = {
  __typename?: 'VwFieldPropertyOptionChoice';
  componentDesc?: Maybe<Scalars['String']['output']>;
  componentId?: Maybe<Scalars['BigInt']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fieldDeletedAt?: Maybe<Scalars['Datetime']['output']>;
  fieldId?: Maybe<Scalars['BigInt']['output']>;
  formId?: Maybe<Scalars['BigInt']['output']>;
  seqno?: Maybe<Scalars['BigInt']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VwFieldPropertyOptionChoice` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type VwFieldPropertyOptionChoiceCondition = {
  /** Checks for equality with the object’s `componentDesc` field. */
  componentDesc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `componentId` field. */
  componentId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `formId` field. */
  formId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `seqno` field. */
  seqno?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VwFieldPropertyOptionChoice` object types. All fields are combined with a logical ‘and.’ */
export type VwFieldPropertyOptionChoiceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VwFieldPropertyOptionChoiceFilter>>;
  /** Filter by the object’s `componentDesc` field. */
  componentDesc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `componentId` field. */
  componentId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldDeletedAt` field. */
  fieldDeletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `formId` field. */
  formId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VwFieldPropertyOptionChoiceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VwFieldPropertyOptionChoiceFilter>>;
  /** Filter by the object’s `seqno` field. */
  seqno?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<StringFilter>;
};

/** A connection to a list of `VwFieldPropertyOptionChoice` values. */
export type VwFieldPropertyOptionChoicesConnection = {
  __typename?: 'VwFieldPropertyOptionChoicesConnection';
  /** A list of edges which contains the `VwFieldPropertyOptionChoice` and cursor to aid in pagination. */
  edges: Array<VwFieldPropertyOptionChoicesEdge>;
  /** A list of `VwFieldPropertyOptionChoice` objects. */
  nodes: Array<VwFieldPropertyOptionChoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VwFieldPropertyOptionChoice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VwFieldPropertyOptionChoice` edge in the connection. */
export type VwFieldPropertyOptionChoicesEdge = {
  __typename?: 'VwFieldPropertyOptionChoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VwFieldPropertyOptionChoice` at the end of the edge. */
  node: VwFieldPropertyOptionChoice;
};

/** Methods to use when ordering `VwFieldPropertyOptionChoice`. */
export enum VwFieldPropertyOptionChoicesOrderBy {
  ComponentDescAsc = 'COMPONENT_DESC_ASC',
  ComponentDescDesc = 'COMPONENT_DESC_DESC',
  ComponentIdAsc = 'COMPONENT_ID_ASC',
  ComponentIdDesc = 'COMPONENT_ID_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  FieldDeletedAtAsc = 'FIELD_DELETED_AT_ASC',
  FieldDeletedAtDesc = 'FIELD_DELETED_AT_DESC',
  FieldIdAsc = 'FIELD_ID_ASC',
  FieldIdDesc = 'FIELD_ID_DESC',
  FormIdAsc = 'FORM_ID_ASC',
  FormIdDesc = 'FORM_ID_DESC',
  Natural = 'NATURAL',
  SeqnoAsc = 'SEQNO_ASC',
  SeqnoDesc = 'SEQNO_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

/** A connection to a list of `WebsocketsStatisticsEntry` values. */
export type WebsocketsStatisticsEntriesConnection = {
  __typename?: 'WebsocketsStatisticsEntriesConnection';
  /** A list of edges which contains the `WebsocketsStatisticsEntry` and cursor to aid in pagination. */
  edges: Array<WebsocketsStatisticsEntriesEdge>;
  /** A list of `WebsocketsStatisticsEntry` objects. */
  nodes: Array<WebsocketsStatisticsEntry>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WebsocketsStatisticsEntry` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WebsocketsStatisticsEntry` edge in the connection. */
export type WebsocketsStatisticsEntriesEdge = {
  __typename?: 'WebsocketsStatisticsEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WebsocketsStatisticsEntry` at the end of the edge. */
  node: WebsocketsStatisticsEntry;
};

/** Methods to use when ordering `WebsocketsStatisticsEntry`. */
export enum WebsocketsStatisticsEntriesOrderBy {
  ApiMessageCountAsc = 'API_MESSAGE_COUNT_ASC',
  ApiMessageCountDesc = 'API_MESSAGE_COUNT_DESC',
  AppIdAsc = 'APP_ID_ASC',
  AppIdDesc = 'APP_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PeakConnectionCountAsc = 'PEAK_CONNECTION_COUNT_ASC',
  PeakConnectionCountDesc = 'PEAK_CONNECTION_COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  WebsocketMessageCountAsc = 'WEBSOCKET_MESSAGE_COUNT_ASC',
  WebsocketMessageCountDesc = 'WEBSOCKET_MESSAGE_COUNT_DESC'
}

export type WebsocketsStatisticsEntry = Node & {
  __typename?: 'WebsocketsStatisticsEntry';
  apiMessageCount: Scalars['Int']['output'];
  appId: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  peakConnectionCount: Scalars['Int']['output'];
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  websocketMessageCount: Scalars['Int']['output'];
};

/**
 * A condition to be used against `WebsocketsStatisticsEntry` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type WebsocketsStatisticsEntryCondition = {
  /** Checks for equality with the object’s `apiMessageCount` field. */
  apiMessageCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `appId` field. */
  appId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `peakConnectionCount` field. */
  peakConnectionCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `websocketMessageCount` field. */
  websocketMessageCount?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `WebsocketsStatisticsEntry` object types. All fields are combined with a logical ‘and.’ */
export type WebsocketsStatisticsEntryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WebsocketsStatisticsEntryFilter>>;
  /** Filter by the object’s `apiMessageCount` field. */
  apiMessageCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `appId` field. */
  appId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WebsocketsStatisticsEntryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WebsocketsStatisticsEntryFilter>>;
  /** Filter by the object’s `peakConnectionCount` field. */
  peakConnectionCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `websocketMessageCount` field. */
  websocketMessageCount?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `WebsocketsStatisticsEntry` */
export type WebsocketsStatisticsEntryInput = {
  apiMessageCount: Scalars['Int']['input'];
  appId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  peakConnectionCount: Scalars['Int']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  websocketMessageCount: Scalars['Int']['input'];
};

/** Represents an update to a `WebsocketsStatisticsEntry`. Fields that are set will be updated. */
export type WebsocketsStatisticsEntryPatch = {
  apiMessageCount?: InputMaybe<Scalars['Int']['input']>;
  appId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  peakConnectionCount?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  websocketMessageCount?: InputMaybe<Scalars['Int']['input']>;
};

export type WorkType = Node & {
  __typename?: 'WorkType';
  adminId?: Maybe<Scalars['BigInt']['output']>;
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  deletedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['BigInt']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `WorkType`. */
  organization?: Maybe<Organization>;
  organizationId: Scalars['BigInt']['output'];
  qrValue?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  uuid?: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `WorkType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WorkTypeCondition = {
  /** Checks for equality with the object’s `adminId` field. */
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `qrValue` field. */
  qrValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `uuid` field. */
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `WorkType` object types. All fields are combined with a logical ‘and.’ */
export type WorkTypeFilter = {
  /** Filter by the object’s `adminId` field. */
  adminId?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WorkTypeFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deletedAt` field. */
  deletedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WorkTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WorkTypeFilter>>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `qrValue` field. */
  qrValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `uuid` field. */
  uuid?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `WorkType` */
export type WorkTypeInput = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['BigInt']['input'];
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `WorkType`. Fields that are set will be updated. */
export type WorkTypePatch = {
  adminId?: InputMaybe<Scalars['BigInt']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  deletedAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['BigInt']['input']>;
  qrValue?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  uuid?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `WorkType` values. */
export type WorkTypesConnection = {
  __typename?: 'WorkTypesConnection';
  /** A list of edges which contains the `WorkType` and cursor to aid in pagination. */
  edges: Array<WorkTypesEdge>;
  /** A list of `WorkType` objects. */
  nodes: Array<WorkType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WorkType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WorkType` edge in the connection. */
export type WorkTypesEdge = {
  __typename?: 'WorkTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WorkType` at the end of the edge. */
  node: WorkType;
};

/** Methods to use when ordering `WorkType`. */
export enum WorkTypesOrderBy {
  AdminIdAsc = 'ADMIN_ID_ASC',
  AdminIdDesc = 'ADMIN_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DeletedAtAsc = 'DELETED_AT_ASC',
  DeletedAtDesc = 'DELETED_AT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrganizationIdAsc = 'ORGANIZATION_ID_ASC',
  OrganizationIdDesc = 'ORGANIZATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QrValueAsc = 'QR_VALUE_ASC',
  QrValueDesc = 'QR_VALUE_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UuidAsc = 'UUID_ASC',
  UuidDesc = 'UUID_DESC'
}

export type GetFillupFormIdFromProfileQueryVariables = Exact<{
  userId: Scalars['BigInt']['input'];
}>;


export type GetFillupFormIdFromProfileQuery = { __typename?: 'Query', profiles?: { __typename?: 'ProfilesConnection', nodes: Array<{ __typename?: 'Profile', skills?: string | null }> } | null };

export type GetSkillDropdDownListQueryVariables = Exact<{
  fillupFormId?: InputMaybe<Array<Scalars['BigInt']['input']> | Scalars['BigInt']['input']>;
}>;


export type GetSkillDropdDownListQuery = { __typename?: 'Query', fillupFormFields?: { __typename?: 'FillupFormFieldsConnection', nodes: Array<{ __typename?: 'FillupFormField', id: any, fillupFormId: any, fieldId: any, answer: string, field?: { __typename?: 'Field', fieldProperties: { __typename?: 'FieldPropertiesConnection', nodes: Array<{ __typename?: 'FieldProperty', fieldId: any, propertyId: any, value: string, updatedAt?: any | null }> } } | null }> } | null };

export type GetUserDetailsByIdQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserDetailsByIdQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: any, name: string, email: string, phoneNumber?: string | null, password: string, facebookId?: string | null }> } | null };

export type LoginSpfQueryVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type LoginSpfQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: any, name: string, email: string, deviceName?: string | null }> } | null };



export const GetFillupFormIdFromProfileDocument = `
    query GetFillupFormIdFromProfile($userId: BigInt!) {
  profiles(condition: {userId: $userId, deletedAt: null}) {
    nodes {
      skills
    }
  }
}
    `;

export const useGetFillupFormIdFromProfileQuery = <
      TData = GetFillupFormIdFromProfileQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: GetFillupFormIdFromProfileQueryVariables,
      options?: UseQueryOptions<GetFillupFormIdFromProfileQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useQuery<GetFillupFormIdFromProfileQuery, TError, TData>(
      ['GetFillupFormIdFromProfile', variables],
      fetcher<GetFillupFormIdFromProfileQuery, GetFillupFormIdFromProfileQueryVariables>(client, GetFillupFormIdFromProfileDocument, variables, headers),
      options
    )};

export const useInfiniteGetFillupFormIdFromProfileQuery = <
      TData = GetFillupFormIdFromProfileQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: GetFillupFormIdFromProfileQueryVariables,
      options?: UseInfiniteQueryOptions<GetFillupFormIdFromProfileQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useInfiniteQuery<GetFillupFormIdFromProfileQuery, TError, TData>(
      ['GetFillupFormIdFromProfile.infinite', variables],
      (metaData) => fetcher<GetFillupFormIdFromProfileQuery, GetFillupFormIdFromProfileQueryVariables>(client, GetFillupFormIdFromProfileDocument, {...variables, ...(metaData.pageParam ?? {})}, headers)(),
      options
    )};

export const GetSkillDropdDownListDocument = `
    query GetSkillDropdDownList($fillupFormId: [BigInt!]) {
  fillupFormFields(filter: {fillupFormId: {in: $fillupFormId}}) {
    nodes {
      id
      fillupFormId
      fieldId
      answer
      field {
        fieldProperties(condition: {propertyId: "209"}) {
          nodes {
            fieldId
            propertyId
            value
            updatedAt
          }
        }
      }
    }
  }
}
    `;

export const useGetSkillDropdDownListQuery = <
      TData = GetSkillDropdDownListQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: GetSkillDropdDownListQueryVariables,
      options?: UseQueryOptions<GetSkillDropdDownListQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useQuery<GetSkillDropdDownListQuery, TError, TData>(
      variables === undefined ? ['GetSkillDropdDownList'] : ['GetSkillDropdDownList', variables],
      fetcher<GetSkillDropdDownListQuery, GetSkillDropdDownListQueryVariables>(client, GetSkillDropdDownListDocument, variables, headers),
      options
    )};

export const useInfiniteGetSkillDropdDownListQuery = <
      TData = GetSkillDropdDownListQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: GetSkillDropdDownListQueryVariables,
      options?: UseInfiniteQueryOptions<GetSkillDropdDownListQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useInfiniteQuery<GetSkillDropdDownListQuery, TError, TData>(
      variables === undefined ? ['GetSkillDropdDownList.infinite'] : ['GetSkillDropdDownList.infinite', variables],
      (metaData) => fetcher<GetSkillDropdDownListQuery, GetSkillDropdDownListQueryVariables>(client, GetSkillDropdDownListDocument, {...variables, ...(metaData.pageParam ?? {})}, headers)(),
      options
    )};

export const GetUserDetailsByIdDocument = `
    query GetUserDetailsById {
  users {
    nodes {
      id
      name
      email
      phoneNumber
      password
      facebookId
    }
  }
}
    `;

export const useGetUserDetailsByIdQuery = <
      TData = GetUserDetailsByIdQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: GetUserDetailsByIdQueryVariables,
      options?: UseQueryOptions<GetUserDetailsByIdQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useQuery<GetUserDetailsByIdQuery, TError, TData>(
      variables === undefined ? ['GetUserDetailsById'] : ['GetUserDetailsById', variables],
      fetcher<GetUserDetailsByIdQuery, GetUserDetailsByIdQueryVariables>(client, GetUserDetailsByIdDocument, variables, headers),
      options
    )};

export const useInfiniteGetUserDetailsByIdQuery = <
      TData = GetUserDetailsByIdQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables?: GetUserDetailsByIdQueryVariables,
      options?: UseInfiniteQueryOptions<GetUserDetailsByIdQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useInfiniteQuery<GetUserDetailsByIdQuery, TError, TData>(
      variables === undefined ? ['GetUserDetailsById.infinite'] : ['GetUserDetailsById.infinite', variables],
      (metaData) => fetcher<GetUserDetailsByIdQuery, GetUserDetailsByIdQueryVariables>(client, GetUserDetailsByIdDocument, {...variables, ...(metaData.pageParam ?? {})}, headers)(),
      options
    )};

export const LoginSpfDocument = `
    query loginSPF($email: String!) {
  users(condition: {email: $email, deletedAt: null}) {
    nodes {
      id
      name
      email
      deviceName
    }
  }
}
    `;

export const useLoginSpfQuery = <
      TData = LoginSpfQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: LoginSpfQueryVariables,
      options?: UseQueryOptions<LoginSpfQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useQuery<LoginSpfQuery, TError, TData>(
      ['loginSPF', variables],
      fetcher<LoginSpfQuery, LoginSpfQueryVariables>(client, LoginSpfDocument, variables, headers),
      options
    )};

export const useInfiniteLoginSpfQuery = <
      TData = LoginSpfQuery,
      TError = unknown
    >(
      client: GraphQLClient,
      variables: LoginSpfQueryVariables,
      options?: UseInfiniteQueryOptions<LoginSpfQuery, TError, TData>,
      headers?: RequestInit['headers']
    ) => {
    
    return useInfiniteQuery<LoginSpfQuery, TError, TData>(
      ['loginSPF.infinite', variables],
      (metaData) => fetcher<LoginSpfQuery, LoginSpfQueryVariables>(client, LoginSpfDocument, {...variables, ...(metaData.pageParam ?? {})}, headers)(),
      options
    )};
